
build/ch.elf:     file format elf32-littlearm


Disassembly of section startup:

00000000 <__ram1_start__>:
   0:	e59ff018 	ldr	pc, [pc, #24]	; 20 <_reset>
   4:	e59ff018 	ldr	pc, [pc, #24]	; 24 <_undefined>
   8:	e59ff018 	ldr	pc, [pc, #24]	; 28 <_swi>
   c:	e59ff018 	ldr	pc, [pc, #24]	; 2c <_prefetch>
  10:	e59ff018 	ldr	pc, [pc, #24]	; 30 <_abort>
  14:	e1a00000 	nop			; (mov r0, r0)
  18:	e59ff018 	ldr	pc, [pc, #24]	; 38 <_irq>
  1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_reset>:
  20:	00000040 	.word	0x00000040

00000024 <_undefined>:
  24:	0000003c 	.word	0x0000003c

00000028 <_swi>:
  28:	0000003c 	.word	0x0000003c

0000002c <_prefetch>:
  2c:	0000003c 	.word	0x0000003c

00000030 <_abort>:
  30:	0000003c 	.word	0x0000003c

00000034 <_fiq>:
  34:	0000003c 	.word	0x0000003c

00000038 <_irq>:
  38:	00000120 	.word	0x00000120

0000003c <Abort_Handler>:
  3c:	eafffffe 	b	3c <Abort_Handler>

Disassembly of section .text:

00000040 <Reset_Handler>:
      40:	e59f0098 	ldr	r0, [pc, #152]	; e0 <bssloop+0x18>
      44:	e321f0db 	msr	CPSR_c, #219	; 0xdb
      48:	e1a0d000 	mov	sp, r0
      4c:	e59f1090 	ldr	r1, [pc, #144]	; e4 <bssloop+0x1c>
      50:	e0400001 	sub	r0, r0, r1
      54:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
      58:	e1a0d000 	mov	sp, r0
      5c:	e59f1084 	ldr	r1, [pc, #132]	; e8 <bssloop+0x20>
      60:	e0400001 	sub	r0, r0, r1
      64:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
      68:	e1a0d000 	mov	sp, r0
      6c:	e59f1078 	ldr	r1, [pc, #120]	; ec <bssloop+0x24>
      70:	e0400001 	sub	r0, r0, r1
      74:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
      78:	e1a0d000 	mov	sp, r0
      7c:	e59f106c 	ldr	r1, [pc, #108]	; f0 <bssloop+0x28>
      80:	e0400001 	sub	r0, r0, r1
      84:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
      88:	e1a0d000 	mov	sp, r0
      8c:	e59f1060 	ldr	r1, [pc, #96]	; f4 <bssloop+0x2c>
      90:	e0400001 	sub	r0, r0, r1
      94:	e321f0df 	msr	CPSR_c, #223	; 0xdf
      98:	e1a0d000 	mov	sp, r0
      9c:	eb001f87 	bl	7ec0 <__early_init>
      a0:	e59f1050 	ldr	r1, [pc, #80]	; f8 <bssloop+0x30>
      a4:	e59f2050 	ldr	r2, [pc, #80]	; fc <bssloop+0x34>
      a8:	e59f3050 	ldr	r3, [pc, #80]	; 100 <bssloop+0x38>

000000ac <dataloop>:
      ac:	e1520003 	cmp	r2, r3
      b0:	34910004 	ldrcc	r0, [r1], #4
      b4:	34820004 	strcc	r0, [r2], #4
      b8:	3afffffb 	bcc	ac <dataloop>
      bc:	e3a00000 	mov	r0, #0
      c0:	e59f103c 	ldr	r1, [pc, #60]	; 104 <bssloop+0x3c>
      c4:	e59f203c 	ldr	r2, [pc, #60]	; 108 <bssloop+0x40>

000000c8 <bssloop>:
      c8:	e1510002 	cmp	r1, r2
      cc:	34810004 	strcc	r0, [r1], #4
      d0:	3afffffc 	bcc	c8 <bssloop>
      d4:	eb001fc1 	bl	7fe0 <__late_init>
      d8:	eb001d50 	bl	7620 <main>
      dc:	ea001fbb 	b	7fd0 <__default_exit>
      e0:	40000a58 	.word	0x40000a58
      e4:	00000008 	.word	0x00000008
      e8:	00000008 	.word	0x00000008
      ec:	00000040 	.word	0x00000040
      f0:	00000400 	.word	0x00000400
      f4:	00000008 	.word	0x00000008
      f8:	00008d68 	.word	0x00008d68
      fc:	40000a58 	.word	0x40000a58
     100:	40000b10 	.word	0x40000b10
     104:	40000b10 	.word	0x40000b10
     108:	400016e0 	.word	0x400016e0
     10c:	00000000 	.word	0x00000000

00000110 <_port_switch_arm>:
     110:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
     114:	e581d00c 	str	sp, [r1, #12]
     118:	e590d00c 	ldr	sp, [r0, #12]
     11c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

00000120 <Irq_Handler>:
     120:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
     124:	e59f0070 	ldr	r0, [pc, #112]	; 19c <_zombies+0x4>
     128:	e5900000 	ldr	r0, [r0]
     12c:	e59fe06c 	ldr	lr, [pc, #108]	; 1a0 <_zombies+0x8>
     130:	e12fff10 	bx	r0

00000134 <_irq_ret_arm>:
     134:	e3500000 	cmp	r0, #0
     138:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
     13c:	025ef004 	subseq	pc, lr, #4
     140:	e321f09f 	msr	CPSR_c, #159	; 0x9f
     144:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
     148:	e321f092 	msr	CPSR_c, #146	; 0x92
     14c:	e14f0000 	mrs	r0, SPSR
     150:	e1a0100e 	mov	r1, lr
     154:	e321f09f 	msr	CPSR_c, #159	; 0x9f
     158:	e92d0003 	push	{r0, r1}
     15c:	eb001f97 	bl	7fc0 <chSchDoReschedule>
     160:	e8bd0003 	pop	{r0, r1}
     164:	e321f092 	msr	CPSR_c, #146	; 0x92
     168:	e16ff000 	msr	SPSR_fsxc, r0
     16c:	e1a0e001 	mov	lr, r1
     170:	e321f09f 	msr	CPSR_c, #159	; 0x9f
     174:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
     178:	e321f092 	msr	CPSR_c, #146	; 0x92
     17c:	e25ef004 	subs	pc, lr, #4

00000180 <_port_thread_start>:
     180:	e321f01f 	msr	CPSR_c, #31
     184:	e1a00005 	mov	r0, r5
     188:	e1a0e00f 	mov	lr, pc
     18c:	e12fff14 	bx	r4
     190:	e3a00000 	mov	r0, #0
     194:	eb001f69 	bl	7f40 <chThdExit>

00000198 <_zombies>:
     198:	eafffffe 	b	198 <_zombies>
     19c:	fffff030 	.word	0xfffff030
     1a0:	00000134 	.word	0x00000134
	...

000001b0 <chEvtGetAndClearEvents.constprop.32>:
static inline void port_lock(void) {

#if defined(THUMB)
  __asm volatile ("bl     _port_lock_thumb" : : : "r3", "lr", "memory");
#else
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     1b0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
  currp->p_epending &= ~events;
     1b4:	e3a02000 	mov	r2, #0
  m = currp->p_epending & events;
     1b8:	e59f3010 	ldr	r3, [pc, #16]	; 1d0 <chEvtGetAndClearEvents.constprop.32+0x20>
     1bc:	e5933018 	ldr	r3, [r3, #24]
     1c0:	e5930038 	ldr	r0, [r3, #56]	; 0x38
  currp->p_epending &= ~events;
     1c4:	e5832038 	str	r2, [r3, #56]	; 0x38
static inline void port_unlock(void) {

#if defined(THUMB)
  __asm volatile ("bl     _port_unlock_thumb" : : : "r3", "lr", "memory");
#else
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     1c8:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();

  return m;
}
     1cc:	e12fff1e 	bx	lr
     1d0:	40000c00 	.word	0x40000c00
	...

000001e0 <sdObjectInit.constprop.6>:
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
     1e0:	e1a03000 	mov	r3, r0
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
     1e4:	e3a02001 	mov	r2, #1
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
     1e8:	e92d4030 	push	{r4, r5, lr}
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
     1ec:	e3a0c000 	mov	ip, #0
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
     1f0:	e3a05010 	mov	r5, #16
  sdp->vmt = &vmt;
     1f4:	e59fe068 	ldr	lr, [pc, #104]	; 264 <sdObjectInit.constprop.6+0x84>
     1f8:	e483e004 	str	lr, [r3], #4
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
     1fc:	e2804074 	add	r4, r0, #116	; 0x74
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
     200:	e280e00c 	add	lr, r0, #12
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
     204:	e5803004 	str	r3, [r0, #4]
  oqp->q_notify  = onfy;
     208:	e580104c 	str	r1, [r0, #76]	; 0x4c
  iqp->q_top     = bp + size;
     20c:	e2803064 	add	r3, r0, #100	; 0x64
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
     210:	e2801030 	add	r1, r0, #48	; 0x30
  sdp->state = SD_STOP;
     214:	e5c02008 	strb	r2, [r0, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
     218:	e2802054 	add	r2, r0, #84	; 0x54
  iqp->q_link    = link;
     21c:	e580002c 	str	r0, [r0, #44]	; 0x2c
  oqp->q_link    = link;
     220:	e5800050 	str	r0, [r0, #80]	; 0x50
  oqp->q_counter = size;
     224:	e5805038 	str	r5, [r0, #56]	; 0x38
  oqp->q_top     = bp + size;
     228:	e5804040 	str	r4, [r0, #64]	; 0x40
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
     22c:	e580e00c 	str	lr, [r0, #12]
  tqp->p_prev = (thread_t *)tqp;
     230:	e580e010 	str	lr, [r0, #16]
  iqp->q_buffer  = bp;
     234:	e5802018 	str	r2, [r0, #24]
  iqp->q_rdptr   = bp;
     238:	e5802024 	str	r2, [r0, #36]	; 0x24
  iqp->q_wrptr   = bp;
     23c:	e5802020 	str	r2, [r0, #32]
  iqp->q_top     = bp + size;
     240:	e580301c 	str	r3, [r0, #28]
  oqp->q_buffer  = bp;
     244:	e580303c 	str	r3, [r0, #60]	; 0x3c
  oqp->q_rdptr   = bp;
     248:	e5803048 	str	r3, [r0, #72]	; 0x48
  oqp->q_wrptr   = bp;
     24c:	e5803044 	str	r3, [r0, #68]	; 0x44
  tqp->p_next = (thread_t *)tqp;
     250:	e5801030 	str	r1, [r0, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
     254:	e5801034 	str	r1, [r0, #52]	; 0x34
  iqp->q_counter = 0;
     258:	e580c014 	str	ip, [r0, #20]
  iqp->q_notify  = infy;
     25c:	e580c028 	str	ip, [r0, #40]	; 0x28
}
     260:	e8bd8030 	pop	{r4, r5, pc}
     264:	00008d30 	.word	0x00008d30
	...

00000270 <tmr>:

static virtual_timer_t vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
     270:	e3a02001 	mov	r2, #1
     274:	e59f3004 	ldr	r3, [pc, #4]	; 280 <tmr+0x10>
     278:	e5c32000 	strb	r2, [r3]
}
     27c:	e12fff1e 	bx	lr
     280:	40001418 	.word	0x40001418
	...

00000290 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
     290:	eafffffe 	b	290 <_idle_thread>
	...

000002a0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
     2a0:	e1a03000 	mov	r3, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     2a4:	e321f09f 	msr	CPSR_c, #159	; 0x9f

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
     2a8:	e59f102c 	ldr	r1, [pc, #44]	; 2dc <chCoreAlloc+0x3c>
     2ac:	e59f202c 	ldr	r2, [pc, #44]	; 2e0 <chCoreAlloc+0x40>
     2b0:	e5910000 	ldr	r0, [r1]
     2b4:	e5922000 	ldr	r2, [r2]
  size = MEM_ALIGN_NEXT(size);
     2b8:	e2833007 	add	r3, r3, #7
     2bc:	e3c33007 	bic	r3, r3, #7
  if ((size_t)(endmem - nextmem) < size) {
     2c0:	e0422000 	sub	r2, r2, r0
     2c4:	e1530002 	cmp	r3, r2
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
     2c8:	90803003 	addls	r3, r0, r3
     2cc:	95813000 	strls	r3, [r1]
    return NULL;
     2d0:	83a00000 	movhi	r0, #0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     2d4:	e321f01f 	msr	CPSR_c, #31
}
     2d8:	e12fff1e 	bx	lr
     2dc:	40000dec 	.word	0x40000dec
     2e0:	40000d70 	.word	0x40000d70
	...

000002f0 <bmk12_setup>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
     2f0:	e3a02000 	mov	r2, #0
  tqp->p_next = (thread_t *)tqp;
     2f4:	e59f300c 	ldr	r3, [pc, #12]	; 308 <bmk12_setup+0x18>
     2f8:	e5832008 	str	r2, [r3, #8]
     2fc:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     300:	e5833004 	str	r3, [r3, #4]
 */

static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}
     304:	e12fff1e 	bx	lr
     308:	40000ddc 	.word	0x40000ddc
     30c:	00000000 	.word	0x00000000

00000310 <bmk11_setup>:
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
     310:	e3a02001 	mov	r2, #1
  tqp->p_next = (thread_t *)tqp;
     314:	e59f300c 	ldr	r3, [pc, #12]	; 328 <bmk11_setup+0x18>
     318:	e5832008 	str	r2, [r3, #8]
     31c:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     320:	e5833004 	str	r3, [r3, #4]
}
     324:	e12fff1e 	bx	lr
     328:	40000df0 	.word	0x40000df0
     32c:	00000000 	.word	0x00000000

00000330 <notify>:

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
  (void)qp;
}
     330:	e12fff1e 	bx	lr
	...

00000340 <tmo>:
     340:	e12fff1e 	bx	lr
	...

00000350 <bmk7_setup>:
     350:	e3a02000 	mov	r2, #0
  tqp->p_next = (thread_t *)tqp;
     354:	e59f300c 	ldr	r3, [pc, #12]	; 368 <bmk7_setup+0x18>
     358:	e5832008 	str	r2, [r3, #8]
     35c:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     360:	e5833004 	str	r3, [r3, #4]
}
     364:	e12fff1e 	bx	lr
     368:	40000df0 	.word	0x40000df0
     36c:	00000000 	.word	0x00000000

00000370 <sys2_execute>:
static inline void port_suspend(void) {

#if defined(THUMB)
  __asm volatile ("bl     _port_suspend_thumb" : : : "r3", "lr", "memory");
#else
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     370:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  __asm volatile ("mrs     r3, CPSR                       \n\t"
     374:	e10f3000 	mrs	r3, CPSR
     378:	e3833080 	orr	r3, r3, #128	; 0x80
     37c:	e121f003 	msr	CPSR_c, r3
     380:	e3833040 	orr	r3, r3, #64	; 0x40
     384:	e121f003 	msr	CPSR_c, r3
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     388:	e321f09f 	msr	CPSR_c, #159	; 0x9f
static inline void port_enable(void) {

#if defined(THUMB)
  __asm volatile ("bl     _port_enable_thumb" : : : "r3", "lr", "memory");
#else
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     38c:	e321f01f 	msr	CPSR_c, #31

  chSysSuspend();
  chSysDisable();
  chSysSuspend();
  chSysEnable();
}
     390:	e12fff1e 	bx	lr
	...

000003a0 <queues2_setup>:
  oqp->q_counter = size;
     3a0:	e3a0c004 	mov	ip, #4
  oqp->q_link    = link;
     3a4:	e3a01000 	mov	r1, #0
  oqp->q_buffer  = bp;
     3a8:	e59f2034 	ldr	r2, [pc, #52]	; 3e4 <queues2_setup+0x44>
  tqp->p_next = (thread_t *)tqp;
     3ac:	e59f3034 	ldr	r3, [pc, #52]	; 3e8 <queues2_setup+0x48>
  oqp->q_notify  = onfy;
     3b0:	e59f0034 	ldr	r0, [pc, #52]	; 3ec <queues2_setup+0x4c>
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
     3b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  oqp->q_top     = bp + size;
     3b8:	e082e00c 	add	lr, r2, ip
     3bc:	e583e010 	str	lr, [r3, #16]
     3c0:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     3c4:	e5833004 	str	r3, [r3, #4]
  oqp->q_buffer  = bp;
     3c8:	e583200c 	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
     3cc:	e5832018 	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
     3d0:	e5832014 	str	r2, [r3, #20]
  oqp->q_counter = size;
     3d4:	e583c008 	str	ip, [r3, #8]
  oqp->q_notify  = onfy;
     3d8:	e583001c 	str	r0, [r3, #28]
  oqp->q_link    = link;
     3dc:	e5831020 	str	r1, [r3, #32]

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}
     3e0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     3e4:	40000e00 	.word	0x40000e00
     3e8:	40000ae0 	.word	0x40000ae0
     3ec:	00000330 	.word	0x00000330

000003f0 <queues1_setup>:
  iqp->q_counter = 0;
     3f0:	e3a01000 	mov	r1, #0
  iqp->q_buffer  = bp;
     3f4:	e59f2030 	ldr	r2, [pc, #48]	; 42c <__irq_stack_size__+0x2c>
  tqp->p_next = (thread_t *)tqp;
     3f8:	e59f3030 	ldr	r3, [pc, #48]	; 430 <__irq_stack_size__+0x30>
  iqp->q_notify  = infy;
     3fc:	e59f0030 	ldr	r0, [pc, #48]	; 434 <__irq_stack_size__+0x34>
  iqp->q_top     = bp + size;
     400:	e282c004 	add	ip, r2, #4
     404:	e583c010 	str	ip, [r3, #16]
     408:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     40c:	e5833004 	str	r3, [r3, #4]
  iqp->q_buffer  = bp;
     410:	e583200c 	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
     414:	e5832018 	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
     418:	e5832014 	str	r2, [r3, #20]
  iqp->q_notify  = infy;
     41c:	e583001c 	str	r0, [r3, #28]
  iqp->q_counter = 0;
     420:	e5831008 	str	r1, [r3, #8]
  iqp->q_link    = link;
     424:	e5831020 	str	r1, [r3, #32]
}
     428:	e12fff1e 	bx	lr
     42c:	40000e00 	.word	0x40000e00
     430:	40000a68 	.word	0x40000a68
     434:	00000330 	.word	0x00000330
	...

00000440 <dyn2_setup>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
     440:	e3a02000 	mov	r2, #0
  mp->mp_object_size = size;
     444:	e3a01e13 	mov	r1, #304	; 0x130
  mp->mp_next = NULL;
     448:	e59f3008 	ldr	r3, [pc, #8]	; 458 <dyn2_setup+0x18>
     44c:	e5832000 	str	r2, [r3]
  mp->mp_object_size = size;
     450:	e9830006 	stmib	r3, {r1, r2}
 */

static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
     454:	e12fff1e 	bx	lr
     458:	40000dd0 	.word	0x40000dd0
     45c:	00000000 	.word	0x00000000

00000460 <dyn1_setup>:
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
     460:	e3a02000 	mov	r2, #0
     464:	e59f3028 	ldr	r3, [pc, #40]	; 494 <dyn1_setup+0x34>
  heapp->h_free.h.u.next = hp;
     468:	e59f1028 	ldr	r1, [pc, #40]	; 498 <dyn1_setup+0x38>
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
     46c:	e59fc028 	ldr	ip, [pc, #40]	; 49c <dyn1_setup+0x3c>
  tqp->p_next = (thread_t *)tqp;
     470:	e2830010 	add	r0, r3, #16
     474:	e5830010 	str	r0, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
     478:	e5830014 	str	r0, [r3, #20]
  heapp->h_provider = NULL;
     47c:	e5832000 	str	r2, [r3]
  heapp->h_free.h.size = 0;
     480:	e583200c 	str	r2, [r3, #12]
     484:	e5832018 	str	r2, [r3, #24]
  heapp->h_free.h.u.next = hp;
     488:	e5831008 	str	r1, [r3, #8]
  hp->h.size = size - sizeof(union heap_header);
     48c:	e8811004 	stm	r1, {r2, ip}
}
     490:	e12fff1e 	bx	lr
     494:	40000d78 	.word	0x40000d78
     498:	40000e00 	.word	0x40000e00
     49c:	000005e8 	.word	0x000005e8

000004a0 <dyn3_setup>:
     4a0:	eaffffee 	b	460 <dyn1_setup>
	...

000004b0 <null_provider>:

static void *null_provider(size_t size) {

  (void)size;
  return NULL;
}
     4b0:	e3a00000 	mov	r0, #0
     4b4:	e12fff1e 	bx	lr
	...

000004c0 <pools1_setup>:
  mp->mp_next = NULL;
     4c0:	e3a02000 	mov	r2, #0
  mp->mp_object_size = size;
     4c4:	e3a01e13 	mov	r1, #304	; 0x130
  mp->mp_next = NULL;
     4c8:	e59f3008 	ldr	r3, [pc, #8]	; 4d8 <pools1_setup+0x18>
     4cc:	e5832000 	str	r2, [r3]
  mp->mp_object_size = size;
     4d0:	e9830006 	stmib	r3, {r1, r2}

static void pools1_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
     4d4:	e12fff1e 	bx	lr
     4d8:	40000ad4 	.word	0x40000ad4
     4dc:	00000000 	.word	0x00000000

000004e0 <heap1_setup>:
  heapp->h_provider = NULL;
     4e0:	e3a02000 	mov	r2, #0
     4e4:	e59f3028 	ldr	r3, [pc, #40]	; 514 <heap1_setup+0x34>
  heapp->h_free.h.u.next = hp;
     4e8:	e59f1028 	ldr	r1, [pc, #40]	; 518 <heap1_setup+0x38>
  hp->h.size = size - sizeof(union heap_header);
     4ec:	e59fc028 	ldr	ip, [pc, #40]	; 51c <heap1_setup+0x3c>
  tqp->p_next = (thread_t *)tqp;
     4f0:	e2830010 	add	r0, r3, #16
     4f4:	e5830010 	str	r0, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
     4f8:	e5830014 	str	r0, [r3, #20]
  heapp->h_provider = NULL;
     4fc:	e5832000 	str	r2, [r3]
  heapp->h_free.h.size = 0;
     500:	e583200c 	str	r2, [r3, #12]
     504:	e5832018 	str	r2, [r3, #24]
  heapp->h_free.h.u.next = hp;
     508:	e5831008 	str	r1, [r3, #8]
  hp->h.size = size - sizeof(union heap_header);
     50c:	e8811004 	stm	r1, {r2, ip}
 */

static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}
     510:	e12fff1e 	bx	lr
     514:	400013f8 	.word	0x400013f8
     518:	40000e00 	.word	0x40000e00
     51c:	000005e8 	.word	0x000005e8

00000520 <evt1_setup>:
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
     520:	eaffff22 	b	1b0 <chEvtGetAndClearEvents.constprop.32>
	...

00000530 <evt3_setup>:
     530:	eafffffa 	b	520 <evt1_setup>
	...

00000540 <evt2_setup>:
     540:	eafffff6 	b	520 <evt1_setup>
	...

00000550 <mbox1_setup>:
     550:	e3a0c005 	mov	ip, #5
     554:	e3a00000 	mov	r0, #0
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
     558:	e59f303c 	ldr	r3, [pc, #60]	; 59c <mbox1_setup+0x4c>
     55c:	e59f203c 	ldr	r2, [pc, #60]	; 5a0 <mbox1_setup+0x50>
 * Messages are posted/fetched from a mailbox in carefully designed sequences
 * in order to stimulate all the possible code paths inside the mailbox.<br>
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {
     560:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  tqp->p_next = (thread_t *)tqp;
     564:	e283101c 	add	r1, r3, #28
  mbp->mb_rdptr = buf;
  mbp->mb_wrptr = buf;
  mbp->mb_top = &buf[n];
     568:	e282e014 	add	lr, r2, #20
  mbp->mb_buffer = buf;
     56c:	e5832000 	str	r2, [r3]
  mbp->mb_rdptr = buf;
     570:	e583200c 	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
     574:	e5832008 	str	r2, [r3, #8]
     578:	e2832010 	add	r2, r3, #16
  mbp->mb_top = &buf[n];
     57c:	e583e004 	str	lr, [r3, #4]
     580:	e583c024 	str	ip, [r3, #36]	; 0x24
     584:	e5830018 	str	r0, [r3, #24]
     588:	e583101c 	str	r1, [r3, #28]
  tqp->p_prev = (thread_t *)tqp;
     58c:	e5831020 	str	r1, [r3, #32]
  tqp->p_next = (thread_t *)tqp;
     590:	e5832010 	str	r2, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
     594:	e5832014 	str	r2, [r3, #20]

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}
     598:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     59c:	40000aac 	.word	0x40000aac
     5a0:	40000e00 	.word	0x40000e00
	...

000005b0 <mtx8_setup>:
     5b0:	e3a00000 	mov	r0, #0
  tqp->p_next = (thread_t *)tqp;
     5b4:	e59f2028 	ldr	r2, [pc, #40]	; 5e4 <mtx8_setup+0x34>
     5b8:	e59f3028 	ldr	r3, [pc, #40]	; 5e8 <mtx8_setup+0x38>
     5bc:	e59f1028 	ldr	r1, [pc, #40]	; 5ec <mtx8_setup+0x3c>
     5c0:	e5820008 	str	r0, [r2, #8]
     5c4:	e5822000 	str	r2, [r2]
  tqp->p_prev = (thread_t *)tqp;
     5c8:	e5822004 	str	r2, [r2, #4]
     5cc:	e5830008 	str	r0, [r3, #8]
  tqp->p_next = (thread_t *)tqp;
     5d0:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     5d4:	e5833004 	str	r3, [r3, #4]
  tqp->p_next = (thread_t *)tqp;
     5d8:	e5811000 	str	r1, [r1]
  tqp->p_prev = (thread_t *)tqp;
     5dc:	e5811004 	str	r1, [r1, #4]
static void mtx8_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
     5e0:	e12fff1e 	bx	lr
     5e4:	40000a8c 	.word	0x40000a8c
     5e8:	40000a9c 	.word	0x40000a9c
     5ec:	40000a58 	.word	0x40000a58

000005f0 <mtx6_setup>:
     5f0:	e3a01000 	mov	r1, #0
  tqp->p_next = (thread_t *)tqp;
     5f4:	e59f3018 	ldr	r3, [pc, #24]	; 614 <mtx6_setup+0x24>
     5f8:	e59f2018 	ldr	r2, [pc, #24]	; 618 <mtx6_setup+0x28>
     5fc:	e5831008 	str	r1, [r3, #8]
     600:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     604:	e5833004 	str	r3, [r3, #4]
  tqp->p_next = (thread_t *)tqp;
     608:	e5822000 	str	r2, [r2]
  tqp->p_prev = (thread_t *)tqp;
     60c:	e5822004 	str	r2, [r2, #4]
}
     610:	e12fff1e 	bx	lr
     614:	40000a8c 	.word	0x40000a8c
     618:	40000a58 	.word	0x40000a58
     61c:	00000000 	.word	0x00000000

00000620 <mtx7_setup>:
     620:	eafffff2 	b	5f0 <mtx6_setup>
	...

00000630 <mtx3_setup>:
     630:	e3a01000 	mov	r1, #0
  tqp->p_next = (thread_t *)tqp;
     634:	e59f201c 	ldr	r2, [pc, #28]	; 658 <mtx3_setup+0x28>
     638:	e59f301c 	ldr	r3, [pc, #28]	; 65c <mtx3_setup+0x2c>
     63c:	e5821008 	str	r1, [r2, #8]
     640:	e5822000 	str	r2, [r2]
  tqp->p_prev = (thread_t *)tqp;
     644:	e5822004 	str	r2, [r2, #4]
     648:	e5831008 	str	r1, [r3, #8]
  tqp->p_next = (thread_t *)tqp;
     64c:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     650:	e5833004 	str	r3, [r3, #4]
}
     654:	e12fff1e 	bx	lr
     658:	40000a8c 	.word	0x40000a8c
     65c:	40000a9c 	.word	0x40000a9c

00000660 <mtx4_setup>:
     660:	eafffff2 	b	630 <mtx3_setup>
	...

00000670 <mtx1_setup>:
     670:	e3a02000 	mov	r2, #0
  tqp->p_next = (thread_t *)tqp;
     674:	e59f300c 	ldr	r3, [pc, #12]	; 688 <mtx1_setup+0x18>
     678:	e5832008 	str	r2, [r3, #8]
     67c:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     680:	e5833004 	str	r3, [r3, #4]
}
     684:	e12fff1e 	bx	lr
     688:	40000a8c 	.word	0x40000a8c
     68c:	00000000 	.word	0x00000000

00000690 <mtx5_setup>:
     690:	eafffff6 	b	670 <mtx1_setup>
	...

000006a0 <mtx2_setup>:
     6a0:	eafffff2 	b	670 <mtx1_setup>
	...

000006b0 <sem1_setup>:
     6b0:	e3a02000 	mov	r2, #0
  tqp->p_next = (thread_t *)tqp;
     6b4:	e59f300c 	ldr	r3, [pc, #12]	; 6c8 <sem1_setup+0x18>
     6b8:	e5832008 	str	r2, [r3, #8]
     6bc:	e5833000 	str	r3, [r3]
  tqp->p_prev = (thread_t *)tqp;
     6c0:	e5833004 	str	r3, [r3, #4]
 */

static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
}
     6c4:	e12fff1e 	bx	lr
     6c8:	40000b04 	.word	0x40000b04
     6cc:	00000000 	.word	0x00000000

000006d0 <sem3_setup>:
     6d0:	eafffff6 	b	6b0 <sem1_setup>
	...

000006e0 <sem2_setup>:
     6e0:	eafffff2 	b	6b0 <sem1_setup>
	...

000006f0 <test_printn.part.1>:
    while (n)
     6f0:	e3500000 	cmp	r0, #0
     6f4:	012fff1e 	bxeq	lr
void test_printn(uint32_t n) {
     6f8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
     6fc:	e24dd014 	sub	sp, sp, #20
    p = buf;
     700:	e1a0500d 	mov	r5, sp
      *p++ = (n % 10) + '0', n /= 10;
     704:	e59fc068 	ldr	ip, [pc, #104]	; 774 <test_printn.part.1+0x84>
    p = buf;
     708:	e1a04005 	mov	r4, r5
     70c:	ea000000 	b	714 <test_printn.part.1+0x24>
    while (n)
     710:	e1a04002 	mov	r4, r2
      *p++ = (n % 10) + '0', n /= 10;
     714:	e1a02004 	mov	r2, r4
     718:	e0876c90 	umull	r6, r7, r0, ip
     71c:	e1a031a7 	lsr	r3, r7, #3
     720:	e0831103 	add	r1, r3, r3, lsl #2
     724:	e0400081 	sub	r0, r0, r1, lsl #1
     728:	e2801030 	add	r1, r0, #48	; 0x30
     72c:	e20110ff 	and	r1, r1, #255	; 0xff
    while (n)
     730:	e2530000 	subs	r0, r3, #0
      *p++ = (n % 10) + '0', n /= 10;
     734:	e4c21001 	strb	r1, [r2], #1
    while (n)
     738:	1afffff4 	bne	710 <test_printn.part.1+0x20>
    while (p > buf)
     73c:	e1520005 	cmp	r2, r5
     740:	9a000009 	bls	76c <test_printn.part.1+0x7c>
     744:	e59f602c 	ldr	r6, [pc, #44]	; 778 <test_printn.part.1+0x88>
     748:	ea000000 	b	750 <test_printn.part.1+0x60>
     74c:	e5741001 	ldrb	r1, [r4, #-1]!
      chSequentialStreamPut(chp, *--p);
     750:	e5960000 	ldr	r0, [r6]
     754:	e5903000 	ldr	r3, [r0]
     758:	e5933008 	ldr	r3, [r3, #8]
     75c:	e1a0e00f 	mov	lr, pc
     760:	e12fff13 	bx	r3
    while (p > buf)
     764:	e1550004 	cmp	r5, r4
     768:	1afffff7 	bne	74c <test_printn.part.1+0x5c>
}
     76c:	e28dd014 	add	sp, sp, #20
     770:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
     774:	cccccccd 	.word	0xcccccccd
     778:	40000d48 	.word	0x40000d48
     77c:	00000000 	.word	0x00000000

00000780 <test_printn>:
  if (!n)
     780:	e3500000 	cmp	r0, #0
     784:	1a000005 	bne	7a0 <test_printn+0x20>
    chSequentialStreamPut(chp, '0');
     788:	e59f3014 	ldr	r3, [pc, #20]	; 7a4 <test_printn+0x24>
     78c:	e5930000 	ldr	r0, [r3]
     790:	e5903000 	ldr	r3, [r0]
     794:	e3a01030 	mov	r1, #48	; 0x30
     798:	e5933008 	ldr	r3, [r3, #8]
     79c:	e12fff13 	bx	r3
     7a0:	eaffffd2 	b	6f0 <test_printn.part.1>
     7a4:	40000d48 	.word	0x40000d48
	...

000007b0 <print_line>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
     7b0:	e92d4070 	push	{r4, r5, r6, lr}
     7b4:	e3a0404c 	mov	r4, #76	; 0x4c
     7b8:	e59f5038 	ldr	r5, [pc, #56]	; 7f8 <print_line+0x48>
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
     7bc:	e5950000 	ldr	r0, [r5]
     7c0:	e5903000 	ldr	r3, [r0]
     7c4:	e3a0102d 	mov	r1, #45	; 0x2d
     7c8:	e5933008 	ldr	r3, [r3, #8]
     7cc:	e1a0e00f 	mov	lr, pc
     7d0:	e12fff13 	bx	r3
  for (i = 0; i < 76; i++)
     7d4:	e2544001 	subs	r4, r4, #1
     7d8:	1afffff7 	bne	7bc <print_line+0xc>
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
     7dc:	e5950000 	ldr	r0, [r5]
     7e0:	e5903000 	ldr	r3, [r0]
     7e4:	e3a02002 	mov	r2, #2
     7e8:	e5933000 	ldr	r3, [r3]
     7ec:	e59f1008 	ldr	r1, [pc, #8]	; 7fc <print_line+0x4c>
}
     7f0:	e8bd4070 	pop	{r4, r5, r6, lr}
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
     7f4:	e12fff13 	bx	r3
     7f8:	40000d48 	.word	0x40000d48
     7fc:	000082c4 	.word	0x000082c4

00000800 <test_cpu_pulse>:
  end = start + MS2ST(duration);
     800:	e0603280 	rsb	r3, r0, r0, lsl #5
     804:	e0800103 	add	r0, r0, r3, lsl #2
     808:	e1a00180 	lsl	r0, r0, #3
     80c:	e59f1064 	ldr	r1, [pc, #100]	; 878 <__stacks_total_size__+0x20>
     810:	e2800ff9 	add	r0, r0, #996	; 0x3e4
     814:	e2800003 	add	r0, r0, #3
     818:	e0832190 	umull	r2, r3, r0, r1
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
     81c:	e59f1058 	ldr	r1, [pc, #88]	; 87c <__stacks_total_size__+0x24>
     820:	e591c018 	ldr	ip, [r1, #24]
 * @xclass
 */
#if (CH_DBG_THREADS_PROFILING == TRUE) || defined(__DOXYGEN__)
static inline systime_t chThdGetTicksX(thread_t *tp) {

  return tp->p_time;
     824:	e59c1020 	ldr	r1, [ip, #32]
     828:	e0810323 	add	r0, r1, r3, lsr #6
     82c:	ea000006 	b	84c <test_cpu_pulse+0x4c>
  while (end > start ? (now >= start) && (now < end) :
     830:	e1510002 	cmp	r1, r2
     834:	93a03001 	movls	r3, #1
     838:	83a03000 	movhi	r3, #0
     83c:	e1500002 	cmp	r0, r2
     840:	93a03000 	movls	r3, #0
                       (now >= start) || (now < end));
     844:	e3530000 	cmp	r3, #0
     848:	012fff1e 	bxeq	lr
  while (end > start ? (now >= start) && (now < end) :
     84c:	e1500001 	cmp	r0, r1
     850:	e59c2020 	ldr	r2, [ip, #32]
     854:	8afffff5 	bhi	830 <test_cpu_pulse+0x30>
                       (now >= start) || (now < end));
     858:	e1500002 	cmp	r0, r2
     85c:	93a03000 	movls	r3, #0
     860:	83a03001 	movhi	r3, #1
     864:	e1510002 	cmp	r1, r2
     868:	93833001 	orrls	r3, r3, #1
     86c:	e3530000 	cmp	r3, #0
     870:	1afffff5 	bne	84c <test_cpu_pulse+0x4c>
     874:	e12fff1e 	bx	lr
     878:	10624dd3 	.word	0x10624dd3
     87c:	40000c00 	.word	0x40000c00

00000880 <test_terminate_threads>:
void test_terminate_threads(void) {
     880:	e59f302c 	ldr	r3, [pc, #44]	; 8b4 <test_terminate_threads+0x34>
     884:	e2830014 	add	r0, r3, #20
    if (threads[i])
     888:	e4932004 	ldr	r2, [r3], #4
     88c:	e3520000 	cmp	r2, #0
     890:	0a000004 	beq	8a8 <test_terminate_threads+0x28>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     894:	e321f09f 	msr	CPSR_c, #159	; 0x9f
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->p_flags |= CH_FLAG_TERMINATE;
     898:	e5d2101d 	ldrb	r1, [r2, #29]
     89c:	e3811004 	orr	r1, r1, #4
     8a0:	e5c2101d 	strb	r1, [r2, #29]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     8a4:	e321f01f 	msr	CPSR_c, #31
  for (i = 0; i < MAX_THREADS; i++)
     8a8:	e1530000 	cmp	r3, r0
     8ac:	1afffff5 	bne	888 <test_terminate_threads+0x8>
     8b0:	e12fff1e 	bx	lr
     8b4:	4000141c 	.word	0x4000141c
	...

000008c0 <_test_assert_time_window>:
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     8c0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
     8c4:	e59f3038 	ldr	r3, [pc, #56]	; 904 <_test_assert_time_window+0x44>
     8c8:	e5933028 	ldr	r3, [r3, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     8cc:	e321f01f 	msr	CPSR_c, #31
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((time - start) < (end - start));
     8d0:	e0433001 	sub	r3, r3, r1
     8d4:	e0422001 	sub	r2, r2, r1
  if (!condition)
     8d8:	e1530002 	cmp	r3, r2
  test_global_fail = TRUE;
     8dc:	23a03001 	movcs	r3, #1
  return FALSE;
     8e0:	33a03000 	movcc	r3, #0
  test_global_fail = TRUE;
     8e4:	259fc01c 	ldrcs	ip, [pc, #28]	; 908 <_test_assert_time_window+0x48>
  local_fail = TRUE;
     8e8:	259f101c 	ldrcs	r1, [pc, #28]	; 90c <_test_assert_time_window+0x4c>
  failpoint = point;
     8ec:	259f201c 	ldrcs	r2, [pc, #28]	; 910 <_test_assert_time_window+0x50>
  test_global_fail = TRUE;
     8f0:	25cc3000 	strbcs	r3, [ip]
  failpoint = point;
     8f4:	25820000 	strcs	r0, [r2]
  local_fail = TRUE;
     8f8:	25c13000 	strbcs	r3, [r1]
}
     8fc:	e1a00003 	mov	r0, r3
     900:	e12fff1e 	bx	lr
     904:	40000c00 	.word	0x40000c00
     908:	400013f0 	.word	0x400013f0
     90c:	40000dcc 	.word	0x40000dcc
     910:	40000d74 	.word	0x40000d74
	...

00000920 <_test_assert_sequence>:
bool _test_assert_sequence(unsigned point, char *expected) {
     920:	e92d4030 	push	{r4, r5, lr}
  while (cp < tokp) {
     924:	e59f4060 	ldr	r4, [pc, #96]	; 98c <_test_assert_sequence+0x6c>
  char *cp = tokens_buffer;
     928:	e59f5060 	ldr	r5, [pc, #96]	; 990 <_test_assert_sequence+0x70>
     92c:	e2411001 	sub	r1, r1, #1
  while (cp < tokp) {
     930:	e594e000 	ldr	lr, [r4]
  char *cp = tokens_buffer;
     934:	e1a03005 	mov	r3, r5
     938:	ea000002 	b	948 <_test_assert_sequence+0x28>
    if (*cp++ != *expected++)
     93c:	e4d3c001 	ldrb	ip, [r3], #1
     940:	e15c0002 	cmp	ip, r2
     944:	1a000007 	bne	968 <_test_assert_sequence+0x48>
  while (cp < tokp) {
     948:	e15e0003 	cmp	lr, r3
     94c:	e5f12001 	ldrb	r2, [r1, #1]!
     950:	8afffff9 	bhi	93c <_test_assert_sequence+0x1c>
  if (*expected)
     954:	e3520000 	cmp	r2, #0
     958:	1a000002 	bne	968 <_test_assert_sequence+0x48>
  tokp = tokens_buffer;
     95c:	e5845000 	str	r5, [r4]
}
     960:	e1a00002 	mov	r0, r2
     964:	e8bd8030 	pop	{r4, r5, pc}
  test_global_fail = TRUE;
     968:	e3a02001 	mov	r2, #1
     96c:	e59fc020 	ldr	ip, [pc, #32]	; 994 <_test_assert_sequence+0x74>
  local_fail = TRUE;
     970:	e59f1020 	ldr	r1, [pc, #32]	; 998 <_test_assert_sequence+0x78>
  failpoint = point;
     974:	e59f3020 	ldr	r3, [pc, #32]	; 99c <_test_assert_sequence+0x7c>
  test_global_fail = TRUE;
     978:	e5cc2000 	strb	r2, [ip]
  failpoint = point;
     97c:	e5830000 	str	r0, [r3]
  local_fail = TRUE;
     980:	e5c12000 	strb	r2, [r1]
}
     984:	e1a00002 	mov	r0, r2
     988:	e8bd8030 	pop	{r4, r5, pc}
     98c:	40001440 	.word	0x40001440
     990:	40001430 	.word	0x40001430
     994:	400013f0 	.word	0x400013f0
     998:	40000dcc 	.word	0x40000dcc
     99c:	40000d74 	.word	0x40000d74

000009a0 <_test_assert>:
  if (!condition)
     9a0:	e3510000 	cmp	r1, #0
  test_global_fail = TRUE;
     9a4:	03a03001 	moveq	r3, #1
  return FALSE;
     9a8:	13a03000 	movne	r3, #0
  test_global_fail = TRUE;
     9ac:	059fc018 	ldreq	ip, [pc, #24]	; 9cc <_test_assert+0x2c>
  local_fail = TRUE;
     9b0:	059f1018 	ldreq	r1, [pc, #24]	; 9d0 <_test_assert+0x30>
  failpoint = point;
     9b4:	059f2018 	ldreq	r2, [pc, #24]	; 9d4 <_test_assert+0x34>
  test_global_fail = TRUE;
     9b8:	05cc3000 	strbeq	r3, [ip]
  failpoint = point;
     9bc:	05820000 	streq	r0, [r2]
  local_fail = TRUE;
     9c0:	05c13000 	strbeq	r3, [r1]
}
     9c4:	e1a00003 	mov	r0, r3
     9c8:	e12fff1e 	bx	lr
     9cc:	400013f0 	.word	0x400013f0
     9d0:	40000dcc 	.word	0x40000dcc
     9d4:	40000d74 	.word	0x40000d74
	...

000009e0 <test_emit_token>:
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     9e0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  *tokp++ = token;
     9e4:	e59f3014 	ldr	r3, [pc, #20]	; a00 <test_emit_token+0x20>
     9e8:	e5932000 	ldr	r2, [r3]
     9ec:	e2821001 	add	r1, r2, #1
     9f0:	e5c20000 	strb	r0, [r2]
     9f4:	e5831000 	str	r1, [r3]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     9f8:	e321f01f 	msr	CPSR_c, #31
}
     9fc:	e12fff1e 	bx	lr
     a00:	40001440 	.word	0x40001440
	...

00000a10 <h3>:
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
     a10:	e3a00043 	mov	r0, #67	; 0x43
     a14:	eafffff1 	b	9e0 <test_emit_token>
	...

00000a20 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
     a20:	e3a00042 	mov	r0, #66	; 0x42
     a24:	eaffffed 	b	9e0 <test_emit_token>
	...

00000a30 <h1>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
     a30:	e3a00041 	mov	r0, #65	; 0x41
     a34:	eaffffe9 	b	9e0 <test_emit_token>
	...

00000a40 <thread.lto_priv.53>:
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
     a40:	e5d00000 	ldrb	r0, [r0]
     a44:	eaffffe5 	b	9e0 <test_emit_token>
	...

00000a50 <thread.lto_priv.55>:
     a50:	eafffffa 	b	a40 <thread.lto_priv.53>
	...

00000a60 <test_println>:
void test_println(const char *msgp) {
     a60:	e92d4070 	push	{r4, r5, r6, lr}
  while (*msgp)
     a64:	e5d01000 	ldrb	r1, [r0]
     a68:	e3510000 	cmp	r1, #0
     a6c:	059f5044 	ldreq	r5, [pc, #68]	; ab8 <test_println+0x58>
     a70:	0a000009 	beq	a9c <test_println+0x3c>
     a74:	e1a04000 	mov	r4, r0
     a78:	e59f5038 	ldr	r5, [pc, #56]	; ab8 <test_println+0x58>
    chSequentialStreamPut(chp, *msgp++);
     a7c:	e5950000 	ldr	r0, [r5]
     a80:	e5903000 	ldr	r3, [r0]
     a84:	e5933008 	ldr	r3, [r3, #8]
     a88:	e1a0e00f 	mov	lr, pc
     a8c:	e12fff13 	bx	r3
  while (*msgp)
     a90:	e5f41001 	ldrb	r1, [r4, #1]!
     a94:	e3510000 	cmp	r1, #0
     a98:	1afffff7 	bne	a7c <test_println+0x1c>
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
     a9c:	e5950000 	ldr	r0, [r5]
     aa0:	e5903000 	ldr	r3, [r0]
     aa4:	e3a02002 	mov	r2, #2
     aa8:	e5933000 	ldr	r3, [r3]
     aac:	e59f1008 	ldr	r1, [pc, #8]	; abc <test_println+0x5c>
}
     ab0:	e8bd4070 	pop	{r4, r5, r6, lr}
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
     ab4:	e12fff13 	bx	r3
     ab8:	40000d48 	.word	0x40000d48
     abc:	000082c4 	.word	0x000082c4

00000ac0 <test_print>:
  while (*msgp)
     ac0:	e5d01000 	ldrb	r1, [r0]
     ac4:	e3510000 	cmp	r1, #0
     ac8:	012fff1e 	bxeq	lr
void test_print(const char *msgp) {
     acc:	e92d4070 	push	{r4, r5, r6, lr}
     ad0:	e1a04000 	mov	r4, r0
     ad4:	e59f5020 	ldr	r5, [pc, #32]	; afc <test_print+0x3c>
    chSequentialStreamPut(chp, *msgp++);
     ad8:	e5950000 	ldr	r0, [r5]
     adc:	e5903000 	ldr	r3, [r0]
     ae0:	e5933008 	ldr	r3, [r3, #8]
     ae4:	e1a0e00f 	mov	lr, pc
     ae8:	e12fff13 	bx	r3
  while (*msgp)
     aec:	e5f41001 	ldrb	r1, [r4, #1]!
     af0:	e3510000 	cmp	r1, #0
     af4:	1afffff7 	bne	ad8 <test_print+0x18>
     af8:	e8bd8070 	pop	{r4, r5, r6, pc}
     afc:	40000d48 	.word	0x40000d48

00000b00 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
     b00:	e1a03000 	mov	r3, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     b04:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  objp = mp->mp_next;
     b08:	e5900000 	ldr	r0, [r0]
  if (objp != NULL) {
     b0c:	e3500000 	cmp	r0, #0
     b10:	0a000003 	beq	b24 <chPoolAlloc+0x24>
    mp->mp_next = mp->mp_next->ph_next;
     b14:	e5902000 	ldr	r2, [r0]
     b18:	e5832000 	str	r2, [r3]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     b1c:	e321f01f 	msr	CPSR_c, #31
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
     b20:	e12fff1e 	bx	lr
  else if (mp->mp_provider != NULL) {
     b24:	e5932008 	ldr	r2, [r3, #8]
     b28:	e3520000 	cmp	r2, #0
     b2c:	0afffffa 	beq	b1c <chPoolAlloc+0x1c>
void *chPoolAlloc(memory_pool_t *mp) {
     b30:	e92d4010 	push	{r4, lr}
    objp = mp->mp_provider(mp->mp_object_size);
     b34:	e5930004 	ldr	r0, [r3, #4]
     b38:	e1a0e00f 	mov	lr, pc
     b3c:	e12fff12 	bx	r2
     b40:	e321f01f 	msr	CPSR_c, #31
}
     b44:	e8bd8010 	pop	{r4, pc}
	...

00000b50 <pools1_execute>:

static void pools1_execute(void) {
     b50:	e3a02005 	mov	r2, #5
     b54:	e92d4070 	push	{r4, r5, r6, lr}
     b58:	e59f311c 	ldr	r3, [pc, #284]	; c7c <pools1_execute+0x12c>
     b5c:	e59f411c 	ldr	r4, [pc, #284]	; c80 <pools1_execute+0x130>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     b60:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
     b64:	e5941000 	ldr	r1, [r4]
  mp->mp_next = php;
     b68:	e5843000 	str	r3, [r4]
  php->ph_next = mp->mp_next;
     b6c:	e5831000 	str	r1, [r3]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     b70:	e321f01f 	msr	CPSR_c, #31
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
     b74:	e5941004 	ldr	r1, [r4, #4]
  while (n != 0U) {
     b78:	e2522001 	subs	r2, r2, #1
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
     b7c:	e0833001 	add	r3, r3, r1
  while (n != 0U) {
     b80:	1afffff6 	bne	b60 <pools1_execute+0x10>
     b84:	e3a05005 	mov	r5, #5
  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
     b88:	e59f60f0 	ldr	r6, [pc, #240]	; c80 <pools1_execute+0x130>
     b8c:	e1a00006 	mov	r0, r6
     b90:	ebffffda 	bl	b00 <chPoolAlloc>
     b94:	e2901000 	adds	r1, r0, #0
     b98:	13a01001 	movne	r1, #1
     b9c:	e3a00001 	mov	r0, #1
     ba0:	ebffff7e 	bl	9a0 <_test_assert>
     ba4:	e3500000 	cmp	r0, #0
     ba8:	18bd8070 	popne	{r4, r5, r6, pc}
  for (i = 0; i < MAX_THREADS; i++)
     bac:	e2555001 	subs	r5, r5, #1
     bb0:	1afffff5 	bne	b8c <pools1_execute+0x3c>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
     bb4:	e59f00c4 	ldr	r0, [pc, #196]	; c80 <pools1_execute+0x130>
     bb8:	ebffffd0 	bl	b00 <chPoolAlloc>
     bbc:	e2701001 	rsbs	r1, r0, #1
     bc0:	33a01000 	movcc	r1, #0
     bc4:	e3a00002 	mov	r0, #2
     bc8:	ebffff74 	bl	9a0 <_test_assert>
     bcc:	e3500000 	cmp	r0, #0
     bd0:	18bd8070 	popne	{r4, r5, r6, pc}
     bd4:	e59f20a8 	ldr	r2, [pc, #168]	; c84 <pools1_execute+0x134>
     bd8:	e59f309c 	ldr	r3, [pc, #156]	; c7c <pools1_execute+0x12c>
     bdc:	e2820010 	add	r0, r2, #16
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     be0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  php->ph_next = mp->mp_next;
     be4:	e5941000 	ldr	r1, [r4]
     be8:	e5831000 	str	r1, [r3]
  mp->mp_next = php;
     bec:	e5843000 	str	r3, [r4]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     bf0:	e321f01f 	msr	CPSR_c, #31

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
     bf4:	e1500002 	cmp	r0, r2
     bf8:	14923004 	ldrne	r3, [r2], #4
     bfc:	1afffff7 	bne	be0 <pools1_execute+0x90>
     c00:	e3a05005 	mov	r5, #5
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
     c04:	e59f6074 	ldr	r6, [pc, #116]	; c80 <pools1_execute+0x130>
     c08:	e1a00006 	mov	r0, r6
     c0c:	ebffffbb 	bl	b00 <chPoolAlloc>
     c10:	e2901000 	adds	r1, r0, #0
     c14:	13a01001 	movne	r1, #1
     c18:	e3a00003 	mov	r0, #3
     c1c:	ebffff5f 	bl	9a0 <_test_assert>
     c20:	e3500000 	cmp	r0, #0
     c24:	18bd8070 	popne	{r4, r5, r6, pc}
  for (i = 0; i < MAX_THREADS; i++)
     c28:	e2555001 	subs	r5, r5, #1
     c2c:	1afffff5 	bne	c08 <pools1_execute+0xb8>

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
     c30:	e59f0048 	ldr	r0, [pc, #72]	; c80 <pools1_execute+0x130>
     c34:	ebffffb1 	bl	b00 <chPoolAlloc>
     c38:	e2701001 	rsbs	r1, r0, #1
     c3c:	33a01000 	movcc	r1, #0
     c40:	e3a00004 	mov	r0, #4
     c44:	ebffff55 	bl	9a0 <_test_assert>
     c48:	e3500000 	cmp	r0, #0
     c4c:	18bd8070 	popne	{r4, r5, r6, pc}
  mp->mp_object_size = size;
     c50:	e3a02010 	mov	r2, #16
  mp->mp_provider = provider;
     c54:	e59f302c 	ldr	r3, [pc, #44]	; c88 <pools1_execute+0x138>

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
     c58:	e59f0020 	ldr	r0, [pc, #32]	; c80 <pools1_execute+0x130>
  mp->mp_next = NULL;
     c5c:	e5845000 	str	r5, [r4]
  mp->mp_provider = provider;
     c60:	e984000c 	stmib	r4, {r2, r3}
     c64:	ebffffa5 	bl	b00 <chPoolAlloc>
     c68:	e2701001 	rsbs	r1, r0, #1
     c6c:	33a01000 	movcc	r1, #0
     c70:	e3a00005 	mov	r0, #5
}
     c74:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
     c78:	eaffff48 	b	9a0 <_test_assert>
     c7c:	40000e00 	.word	0x40000e00
     c80:	40000ad4 	.word	0x40000ad4
     c84:	00008d54 	.word	0x00008d54
     c88:	000004b0 	.word	0x000004b0
     c8c:	00000000 	.word	0x00000000

00000c90 <chEvtUnregister>:
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     c90:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  p = (event_listener_t *)esp;
     c94:	e1a02000 	mov	r2, r0
     c98:	ea000002 	b	ca8 <chEvtUnregister+0x18>
    if (p->el_next == elp) {
     c9c:	e1530001 	cmp	r3, r1
     ca0:	0a000005 	beq	cbc <chEvtUnregister+0x2c>
     ca4:	e1a02003 	mov	r2, r3
  while (p->el_next != (event_listener_t *)esp) {
     ca8:	e5923000 	ldr	r3, [r2]
     cac:	e1500003 	cmp	r0, r3
     cb0:	1afffff9 	bne	c9c <chEvtUnregister+0xc>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     cb4:	e321f01f 	msr	CPSR_c, #31
}
     cb8:	e12fff1e 	bx	lr
      p->el_next = elp->el_next;
     cbc:	e5913000 	ldr	r3, [r1]
     cc0:	e5823000 	str	r3, [r2]
     cc4:	e321f01f 	msr	CPSR_c, #31
}
     cc8:	e12fff1e 	bx	lr
     ccc:	00000000 	andeq	r0, r0, r0

00000cd0 <evt1_execute>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
     cd0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
     cd4:	e59f4134 	ldr	r4, [pc, #308]	; e10 <evt1_execute+0x140>
     cd8:	e24dd028 	sub	sp, sp, #40	; 0x28
     cdc:	e5844000 	str	r4, [r4]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     ce0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  elp->el_events   = events;
     ce4:	e3a07001 	mov	r7, #1
  elp->el_flags    = (eventflags_t)0;
     ce8:	e3a02000 	mov	r2, #0
  elp->el_wflags   = wflags;
     cec:	e3e03000 	mvn	r3, #0
  elp->el_next     = esp->es_next;
     cf0:	e594c000 	ldr	ip, [r4]
  elp->el_listener = currp;
     cf4:	e59f1118 	ldr	r1, [pc, #280]	; e14 <evt1_execute+0x144>
  elp->el_next     = esp->es_next;
     cf8:	e28d5028 	add	r5, sp, #40	; 0x28
  elp->el_listener = currp;
     cfc:	e5910018 	ldr	r0, [r1, #24]
  elp->el_next     = esp->es_next;
     d00:	e525c014 	str	ip, [r5, #-20]!	; 0xffffffec
  elp->el_listener = currp;
     d04:	e58d0018 	str	r0, [sp, #24]
  esp->es_next     = elp;
     d08:	e5845000 	str	r5, [r4]
  elp->el_events   = events;
     d0c:	e58d701c 	str	r7, [sp, #28]
  elp->el_flags    = (eventflags_t)0;
     d10:	e58d2020 	str	r2, [sp, #32]
  elp->el_wflags   = wflags;
     d14:	e58d3024 	str	r3, [sp, #36]	; 0x24
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     d18:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
     d1c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  elp->el_events   = events;
     d20:	e3a08002 	mov	r8, #2
  elp->el_next     = esp->es_next;
     d24:	e5940000 	ldr	r0, [r4]
     d28:	e28d6028 	add	r6, sp, #40	; 0x28
  elp->el_listener = currp;
     d2c:	e5911018 	ldr	r1, [r1, #24]
  elp->el_next     = esp->es_next;
     d30:	e5260028 	str	r0, [r6, #-40]!	; 0xffffffd8
  elp->el_listener = currp;
     d34:	e58d1004 	str	r1, [sp, #4]
  elp->el_flags    = (eventflags_t)0;
     d38:	e58d200c 	str	r2, [sp, #12]
  elp->el_wflags   = wflags;
     d3c:	e58d3010 	str	r3, [sp, #16]
  esp->es_next     = elp;
     d40:	e5846000 	str	r6, [r4]
  elp->el_events   = events;
     d44:	e58d8008 	str	r8, [sp, #8]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
     d48:	e321f01f 	msr	CPSR_c, #31
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->es_next);
     d4c:	e5941000 	ldr	r1, [r4]
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
     d50:	e0511004 	subs	r1, r1, r4
     d54:	13a01001 	movne	r1, #1
     d58:	e1a00007 	mov	r0, r7
     d5c:	ebffff0f 	bl	9a0 <_test_assert>
     d60:	e3500000 	cmp	r0, #0
     d64:	0a000001 	beq	d70 <evt1_execute+0xa0>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
     d68:	e28dd028 	add	sp, sp, #40	; 0x28
     d6c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  chEvtUnregister(&es1, &el1);
     d70:	e1a01005 	mov	r1, r5
     d74:	e1a00004 	mov	r0, r4
     d78:	ebffffc4 	bl	c90 <chEvtUnregister>
     d7c:	e5941000 	ldr	r1, [r4]
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
     d80:	e0511004 	subs	r1, r1, r4
     d84:	13a01001 	movne	r1, #1
     d88:	e1a00008 	mov	r0, r8
     d8c:	ebffff03 	bl	9a0 <_test_assert>
     d90:	e3500000 	cmp	r0, #0
     d94:	1afffff3 	bne	d68 <evt1_execute+0x98>
  chEvtUnregister(&es1, &el2);
     d98:	e1a00004 	mov	r0, r4
     d9c:	e1a01006 	mov	r1, r6
     da0:	ebffffba 	bl	c90 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
     da4:	e5941000 	ldr	r1, [r4]
     da8:	e0413004 	sub	r3, r1, r4
     dac:	e2731000 	rsbs	r1, r3, #0
     db0:	e0a11003 	adc	r1, r1, r3
     db4:	e3a00003 	mov	r0, #3
     db8:	ebfffef8 	bl	9a0 <_test_assert>
     dbc:	e2504000 	subs	r4, r0, #0
     dc0:	1affffe8 	bne	d68 <evt1_execute+0x98>
     dc4:	e3a05007 	mov	r5, #7
     dc8:	e59f6048 	ldr	r6, [pc, #72]	; e18 <evt1_execute+0x148>

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
     dcc:	e1a03435 	lsr	r3, r5, r4
     dd0:	e3130001 	tst	r3, #1
     dd4:	0a00000b 	beq	e08 <evt1_execute+0x138>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
     dd8:	e1c55417 	bic	r5, r5, r7, lsl r4
      handlers[eid](eid);
     ddc:	e7963104 	ldr	r3, [r6, r4, lsl #2]
     de0:	e1a00004 	mov	r0, r4
     de4:	e1a0e00f 	mov	lr, pc
     de8:	e12fff13 	bx	r3
  while (events != (eventmask_t)0) {
     dec:	e3550000 	cmp	r5, #0
    }
    eid++;
     df0:	e2844001 	add	r4, r4, #1
  while (events != (eventmask_t)0) {
     df4:	1afffff4 	bne	dcc <evt1_execute+0xfc>
  test_assert_sequence(4, "ABC");
     df8:	e59f101c 	ldr	r1, [pc, #28]	; e1c <evt1_execute+0x14c>
     dfc:	e3a00004 	mov	r0, #4
     e00:	ebfffec6 	bl	920 <_test_assert_sequence>
     e04:	eaffffd7 	b	d68 <evt1_execute+0x98>
    eid++;
     e08:	e2844001 	add	r4, r4, #1
     e0c:	eaffffee 	b	dcc <evt1_execute+0xfc>
     e10:	40000a60 	.word	0x40000a60
     e14:	40000c00 	.word	0x40000c00
     e18:	000081b0 	.word	0x000081b0
     e1c:	000081c0 	.word	0x000081c0

00000e20 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
     e20:	e59f301c 	ldr	r3, [pc, #28]	; e44 <chSchIsPreemptionRequired+0x24>
     e24:	e5932000 	ldr	r2, [r3]
  tprio_t p2 = currp->p_prio;
     e28:	e5933018 	ldr	r3, [r3, #24]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
     e2c:	e5920008 	ldr	r0, [r2, #8]
     e30:	e5933008 	ldr	r3, [r3, #8]
#endif
}
     e34:	e1500003 	cmp	r0, r3
     e38:	93a00000 	movls	r0, #0
     e3c:	83a00001 	movhi	r0, #1
     e40:	e12fff1e 	bx	lr
     e44:	40000c00 	.word	0x40000c00
	...

00000e50 <T0IrqHandler>:
 * Timer 0 IRQ handling here.
 */
static CH_IRQ_HANDLER(T0IrqHandler) {

  CH_IRQ_PROLOGUE();
  T0IR = 1;             /* Clear interrupt on match MR0. */
     e50:	e3a01001 	mov	r1, #1
static CH_IRQ_HANDLER(T0IrqHandler) {
     e54:	e92d4070 	push	{r4, r5, r6, lr}
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
     e58:	e59f4088 	ldr	r4, [pc, #136]	; ee8 <T0IrqHandler+0x98>

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
     e5c:	e1a06004 	mov	r6, r4
  T0IR = 1;             /* Clear interrupt on match MR0. */
     e60:	e59f3084 	ldr	r3, [pc, #132]	; eec <T0IrqHandler+0x9c>
     e64:	e5942018 	ldr	r2, [r4, #24]
     e68:	e5831000 	str	r1, [r3]
     e6c:	e5923020 	ldr	r3, [r2, #32]
     e70:	e0833001 	add	r3, r3, r1
     e74:	e5823020 	str	r3, [r2, #32]
     e78:	e5b6301c 	ldr	r3, [r6, #28]!
  ch.vtlist.vt_systime++;
     e7c:	e5942028 	ldr	r2, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
     e80:	e1530006 	cmp	r3, r6
  ch.vtlist.vt_systime++;
     e84:	e0822001 	add	r2, r2, r1
     e88:	e5842028 	str	r2, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
     e8c:	0a000010 	beq	ed4 <T0IrqHandler+0x84>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
     e90:	e5935008 	ldr	r5, [r3, #8]
     e94:	e2455001 	sub	r5, r5, #1
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
     e98:	e3550000 	cmp	r5, #0
    --ch.vtlist.vt_next->vt_delta;
     e9c:	e5835008 	str	r5, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
     ea0:	1a00000b 	bne	ed4 <T0IrqHandler+0x84>
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
      vtp->vt_func = NULL;
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     ea4:	e5932000 	ldr	r2, [r3]
      fn = vtp->vt_func;
     ea8:	e593100c 	ldr	r1, [r3, #12]
      ch.vtlist.vt_next = vtp->vt_next;
      chSysUnlockFromISR();
      fn(vtp->vt_par);
     eac:	e5930010 	ldr	r0, [r3, #16]
      vtp->vt_func = NULL;
     eb0:	e583500c 	str	r5, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
     eb4:	e5826004 	str	r6, [r2, #4]
      ch.vtlist.vt_next = vtp->vt_next;
     eb8:	e584201c 	str	r2, [r4, #28]
      fn(vtp->vt_par);
     ebc:	e1a0e00f 	mov	lr, pc
     ec0:	e12fff11 	bx	r1
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
     ec4:	e594301c 	ldr	r3, [r4, #28]
     ec8:	e5932008 	ldr	r2, [r3, #8]
     ecc:	e3520000 	cmp	r2, #0
     ed0:	0afffff3 	beq	ea4 <T0IrqHandler+0x54>

  chSysLockFromISR();
  chSysTimerHandlerI();
  chSysUnlockFromISR();

  VICVectAddr = 0;
     ed4:	e3e03c0f 	mvn	r3, #3840	; 0xf00
     ed8:	e3a02000 	mov	r2, #0
  CH_IRQ_EPILOGUE();
}
     edc:	e8bd4070 	pop	{r4, r5, r6, lr}
  VICVectAddr = 0;
     ee0:	e50320cf 	str	r2, [r3, #-207]	; 0xffffff31
  CH_IRQ_EPILOGUE();
     ee4:	eaffffcd 	b	e20 <chSchIsPreemptionRequired>
     ee8:	40000c00 	.word	0x40000c00
     eec:	e0004000 	.word	0xe0004000

00000ef0 <irq_handler>:

  CH_IRQ_PROLOGUE();

  LPC214x_NON_VECTORED_IRQ_HOOK();

  VICVectAddr = 0;
     ef0:	e3e03c0f 	mvn	r3, #3840	; 0xf00
     ef4:	e3a02000 	mov	r2, #0
     ef8:	e50320cf 	str	r2, [r3, #-207]	; 0xffffff31
  CH_IRQ_EPILOGUE();
     efc:	eaffffc7 	b	e20 <chSchIsPreemptionRequired>

00000f00 <wakeup>:
  switch (tp->p_state) {
     f00:	e5d0301c 	ldrb	r3, [r0, #28]
     f04:	e3530007 	cmp	r3, #7
     f08:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
     f0c:	ea00000f 	b	f50 <wakeup+0x50>
     f10:	00000f8c 	.word	0x00000f8c
     f14:	00000f50 	.word	0x00000f50
     f18:	00000f50 	.word	0x00000f50
     f1c:	00000f90 	.word	0x00000f90
     f20:	00000f40 	.word	0x00000f40
     f24:	00000f30 	.word	0x00000f30
     f28:	00000f50 	.word	0x00000f50
     f2c:	00000f40 	.word	0x00000f40
    chSemFastSignalI(tp->p_u.wtsemp);
     f30:	e5902024 	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
     f34:	e5923008 	ldr	r3, [r2, #8]
     f38:	e2833001 	add	r3, r3, #1
     f3c:	e5823008 	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
     f40:	e890000c 	ldm	r0, {r2, r3}
     f44:	e5832000 	str	r2, [r3]
  tp->p_next->p_prev = tp->p_prev;
     f48:	e5902000 	ldr	r2, [r0]
     f4c:	e5823004 	str	r3, [r2, #4]
  tp->p_state = CH_STATE_READY;
     f50:	e3a03000 	mov	r3, #0
  tp->p_u.rdymsg = MSG_TIMEOUT;
     f54:	e3e02000 	mvn	r2, #0
  tp->p_state = CH_STATE_READY;
     f58:	e5c0301c 	strb	r3, [r0, #28]
  tp->p_u.rdymsg = MSG_TIMEOUT;
     f5c:	e5802024 	str	r2, [r0, #36]	; 0x24
  } while (cp->p_prio >= tp->p_prio);
     f60:	e5901008 	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
     f64:	e59f3034 	ldr	r3, [pc, #52]	; fa0 <wakeup+0xa0>
    cp = cp->p_next;
     f68:	e5933000 	ldr	r3, [r3]
  } while (cp->p_prio >= tp->p_prio);
     f6c:	e5932008 	ldr	r2, [r3, #8]
     f70:	e1520001 	cmp	r2, r1
     f74:	2afffffb 	bcs	f68 <wakeup+0x68>
  tp->p_prev = cp->p_prev;
     f78:	e5932004 	ldr	r2, [r3, #4]
  tp->p_next = cp;
     f7c:	e5803000 	str	r3, [r0]
  tp->p_prev = cp->p_prev;
     f80:	e5802004 	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
     f84:	e5820000 	str	r0, [r2]
  cp->p_prev = tp;
     f88:	e5830004 	str	r0, [r3, #4]
}
     f8c:	e12fff1e 	bx	lr
    *tp->p_u.wttrp = NULL;
     f90:	e3a02000 	mov	r2, #0
     f94:	e5903024 	ldr	r3, [r0, #36]	; 0x24
     f98:	e5832000 	str	r2, [r3]
     f9c:	eaffffeb 	b	f50 <wakeup+0x50>
     fa0:	40000c00 	.word	0x40000c00
	...

00000fb0 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
     fb0:	e1a01000 	mov	r1, r0
  tp->p_state = CH_STATE_READY;
     fb4:	e3a03000 	mov	r3, #0
  } while (cp->p_prio >= tp->p_prio);
     fb8:	e5900008 	ldr	r0, [r0, #8]
  tp->p_state = CH_STATE_READY;
     fbc:	e5c1301c 	strb	r3, [r1, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
     fc0:	e59f3028 	ldr	r3, [pc, #40]	; ff0 <chSchReadyI+0x40>
    cp = cp->p_next;
     fc4:	e5933000 	ldr	r3, [r3]
  } while (cp->p_prio >= tp->p_prio);
     fc8:	e5932008 	ldr	r2, [r3, #8]
     fcc:	e1520000 	cmp	r2, r0
     fd0:	2afffffb 	bcs	fc4 <chSchReadyI+0x14>
  tp->p_prev = cp->p_prev;
     fd4:	e5932004 	ldr	r2, [r3, #4]
}
     fd8:	e1a00001 	mov	r0, r1
  tp->p_next = cp;
     fdc:	e5813000 	str	r3, [r1]
  tp->p_prev = cp->p_prev;
     fe0:	e5812004 	str	r2, [r1, #4]
  tp->p_prev->p_next = tp;
     fe4:	e5821000 	str	r1, [r2]
  cp->p_prev = tp;
     fe8:	e5831004 	str	r1, [r3, #4]
}
     fec:	e12fff1e 	bx	lr
     ff0:	40000c00 	.word	0x40000c00
	...

00001000 <chCondSignalI.constprop.39>:
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1000:	e59f3024 	ldr	r3, [pc, #36]	; 102c <chCondSignalI.constprop.39+0x2c>
    1004:	e5932000 	ldr	r2, [r3]
void chCondSignalI(condition_variable_t *cp) {

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
    1008:	e1520003 	cmp	r2, r3
    100c:	012fff1e 	bxeq	lr
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
    1010:	e3a0c000 	mov	ip, #0
  tqp->p_next = tp->p_next;
    1014:	e5921000 	ldr	r1, [r2]
    (void) chSchReadyI(tp);
    1018:	e1a00002 	mov	r0, r2
  tqp->p_next->p_prev = (thread_t *)tqp;
    101c:	e5813004 	str	r3, [r1, #4]
  tqp->p_next = tp->p_next;
    1020:	e5831000 	str	r1, [r3]
    tp->p_u.rdymsg = MSG_OK;
    1024:	e582c024 	str	ip, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
    1028:	eaffffe0 	b	fb0 <chSchReadyI>
    102c:	40000a58 	.word	0x40000a58

00001030 <chIQPutI>:
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
    1030:	e2802014 	add	r2, r0, #20
    1034:	e892000c 	ldm	r2, {r2, r3}
    1038:	e1520003 	cmp	r2, r3
    103c:	e5903008 	ldr	r3, [r0, #8]
    1040:	0a00001d 	beq	10bc <chIQPutI+0x8c>
  iqp->q_counter++;
    1044:	e2833001 	add	r3, r3, #1
  *iqp->q_wrptr++ = b;
    1048:	e282c001 	add	ip, r2, #1
  iqp->q_counter++;
    104c:	e5803008 	str	r3, [r0, #8]
  *iqp->q_wrptr++ = b;
    1050:	e580c014 	str	ip, [r0, #20]
    1054:	e5c21000 	strb	r1, [r2]
  if (iqp->q_wrptr >= iqp->q_top) {
    1058:	e5902014 	ldr	r2, [r0, #20]
    105c:	e5903010 	ldr	r3, [r0, #16]
    1060:	e1520003 	cmp	r2, r3
    1064:	2a00000d 	bcs	10a0 <chIQPutI+0x70>
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1068:	e5902000 	ldr	r2, [r0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
    106c:	e1500002 	cmp	r0, r2
    1070:	0a00000f 	beq	10b4 <chIQPutI+0x84>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
    1074:	e92d4010 	push	{r4, lr}
    1078:	e1a03000 	mov	r3, r0

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
    107c:	e3a04000 	mov	r4, #0
  tqp->p_next = tp->p_next;
    1080:	e5921000 	ldr	r1, [r2]
  (void) chSchReadyI(tp);
    1084:	e1a00002 	mov	r0, r2
    1088:	e5831000 	str	r1, [r3]
  tqp->p_next->p_prev = (thread_t *)tqp;
    108c:	e5813004 	str	r3, [r1, #4]
  tp->p_u.rdymsg = msg;
    1090:	e5824024 	str	r4, [r2, #36]	; 0x24
  (void) chSchReadyI(tp);
    1094:	ebffffc5 	bl	fb0 <chSchReadyI>
  return Q_OK;
    1098:	e1a00004 	mov	r0, r4
}
    109c:	e8bd8010 	pop	{r4, pc}
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    10a0:	e5902000 	ldr	r2, [r0]
    iqp->q_wrptr = iqp->q_buffer;
    10a4:	e590300c 	ldr	r3, [r0, #12]
    10a8:	e1500002 	cmp	r0, r2
    10ac:	e5803014 	str	r3, [r0, #20]
    10b0:	1affffef 	bne	1074 <chIQPutI+0x44>
  return Q_OK;
    10b4:	e3a00000 	mov	r0, #0
}
    10b8:	e12fff1e 	bx	lr
    10bc:	e3530000 	cmp	r3, #0
    10c0:	0affffdf 	beq	1044 <chIQPutI+0x14>
    return Q_FULL;
    10c4:	e3e00003 	mvn	r0, #3
    10c8:	e12fff1e 	bx	lr
    10cc:	00000000 	andeq	r0, r0, r0

000010d0 <chOQGetI>:
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    10d0:	e5903014 	ldr	r3, [r0, #20]
    10d4:	e5902018 	ldr	r2, [r0, #24]
    10d8:	e1530002 	cmp	r3, r2
    10dc:	e5903008 	ldr	r3, [r0, #8]
    10e0:	0a000017 	beq	1144 <chOQGetI+0x74>
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
    10e4:	e92d4010 	push	{r4, lr}
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
    10e8:	e2821001 	add	r1, r2, #1
  oqp->q_counter++;
    10ec:	e2833001 	add	r3, r3, #1
  if (oqp->q_rdptr >= oqp->q_top) {
    10f0:	e590c010 	ldr	ip, [r0, #16]
  oqp->q_counter++;
    10f4:	e5803008 	str	r3, [r0, #8]
  b = *oqp->q_rdptr++;
    10f8:	e5801018 	str	r1, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
    10fc:	e151000c 	cmp	r1, ip
  b = *oqp->q_rdptr++;
    1100:	e5d24000 	ldrb	r4, [r2]
  if (oqp->q_rdptr >= oqp->q_top) {
    1104:	2a00000b 	bcs	1138 <chOQGetI+0x68>
    1108:	e5903000 	ldr	r3, [r0]
    110c:	e1500003 	cmp	r0, r3
    1110:	0a000006 	beq	1130 <chOQGetI+0x60>
  tp->p_u.rdymsg = msg;
    1114:	e3a01000 	mov	r1, #0
  tqp->p_next = tp->p_next;
    1118:	e5932000 	ldr	r2, [r3]
    111c:	e5802000 	str	r2, [r0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1120:	e5820004 	str	r0, [r2, #4]
  (void) chSchReadyI(tp);
    1124:	e1a00003 	mov	r0, r3
  tp->p_u.rdymsg = msg;
    1128:	e5831024 	str	r1, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
    112c:	ebffff9f 	bl	fb0 <chSchReadyI>
    oqp->q_rdptr = oqp->q_buffer;
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);

  return (msg_t)b;
    1130:	e1a00004 	mov	r0, r4
}
    1134:	e8bd8010 	pop	{r4, pc}
    oqp->q_rdptr = oqp->q_buffer;
    1138:	e590300c 	ldr	r3, [r0, #12]
    113c:	e5803018 	str	r3, [r0, #24]
    1140:	eafffff0 	b	1108 <chOQGetI+0x38>
    1144:	e3530000 	cmp	r3, #0
    1148:	0affffe5 	beq	10e4 <chOQGetI+0x14>
    return Q_EMPTY;
    114c:	e3e00002 	mvn	r0, #2
}
    1150:	e12fff1e 	bx	lr
	...

00001160 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {
    1160:	e1a03000 	mov	r3, r0
  tp->p_epending |= events;
    1164:	e5902038 	ldr	r2, [r0, #56]	; 0x38
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    1168:	e5d0001c 	ldrb	r0, [r0, #28]
  tp->p_epending |= events;
    116c:	e1811002 	orr	r1, r1, r2
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    1170:	e350000a 	cmp	r0, #10
  tp->p_epending |= events;
    1174:	e5831038 	str	r1, [r3, #56]	; 0x38
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    1178:	0a000008 	beq	11a0 <chEvtSignalI+0x40>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    117c:	e350000b 	cmp	r0, #11
    1180:	112fff1e 	bxne	lr
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    1184:	e5932024 	ldr	r2, [r3, #36]	; 0x24
      ((tp->p_state == CH_STATE_WTANDEVT) &&
    1188:	e1d22001 	bics	r2, r2, r1
    118c:	112fff1e 	bxne	lr
    tp->p_u.rdymsg = MSG_OK;
    1190:	e3a02000 	mov	r2, #0
    (void) chSchReadyI(tp);
    1194:	e1a00003 	mov	r0, r3
    tp->p_u.rdymsg = MSG_OK;
    1198:	e5832024 	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    119c:	eaffff83 	b	fb0 <chSchReadyI>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
    11a0:	e5932024 	ldr	r2, [r3, #36]	; 0x24
  if (((tp->p_state == CH_STATE_WTOREVT) &&
    11a4:	e1110002 	tst	r1, r2
    11a8:	012fff1e 	bxeq	lr
    tp->p_u.rdymsg = MSG_OK;
    11ac:	e3a02000 	mov	r2, #0
    (void) chSchReadyI(tp);
    11b0:	e1a00003 	mov	r0, r3
    tp->p_u.rdymsg = MSG_OK;
    11b4:	e5832024 	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    11b8:	eaffff7c 	b	fb0 <chSchReadyI>
    11bc:	00000000 	andeq	r0, r0, r0

000011c0 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
    11c0:	e92d4070 	push	{r4, r5, r6, lr}
  elp = esp->es_next;
    11c4:	e5904000 	ldr	r4, [r0]
  while (elp != (event_listener_t *)esp) {
    11c8:	e1500004 	cmp	r0, r4
    11cc:	08bd8070 	popeq	{r4, r5, r6, pc}
    11d0:	e1a06000 	mov	r6, r0
    11d4:	e1a05001 	mov	r5, r1
    elp->el_flags |= flags;
    11d8:	e594300c 	ldr	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
    11dc:	e3550000 	cmp	r5, #0
    elp->el_flags |= flags;
    11e0:	e1853003 	orr	r3, r5, r3
    11e4:	e584300c 	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
    11e8:	0a000002 	beq	11f8 <chEvtBroadcastFlagsI+0x38>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
    11ec:	e5942010 	ldr	r2, [r4, #16]
    if ((flags == (eventflags_t)0) ||
    11f0:	e1130002 	tst	r3, r2
    11f4:	0a000001 	beq	1200 <chEvtBroadcastFlagsI+0x40>
      chEvtSignalI(elp->el_listener, elp->el_events);
    11f8:	e9940003 	ldmib	r4, {r0, r1}
    11fc:	ebffffd7 	bl	1160 <chEvtSignalI>
    elp = elp->el_next;
    1200:	e5944000 	ldr	r4, [r4]
  while (elp != (event_listener_t *)esp) {
    1204:	e1560004 	cmp	r6, r4
    1208:	1afffff2 	bne	11d8 <chEvtBroadcastFlagsI+0x18>
    120c:	e8bd8070 	pop	{r4, r5, r6, pc}

00001210 <preload>:
}

/**
 * @brief   Attempts a TX FIFO preload.
 */
static void preload(SerialDriver *sdp) {
    1210:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  UART *u = sdp->uart;
    1214:	e5905074 	ldr	r5, [r0, #116]	; 0x74

  if (u->UART_LSR & LSR_THRE) {
    1218:	e5953014 	ldr	r3, [r5, #20]
    121c:	e3130020 	tst	r3, #32
    1220:	0a00000e 	beq	1260 <preload+0x50>
    1224:	e1a07000 	mov	r7, r0
    1228:	e3a04010 	mov	r4, #16
    122c:	e2806030 	add	r6, r0, #48	; 0x30
    1230:	ea000002 	b	1240 <preload+0x30>
      if (b < Q_OK) {
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
        return;
      }
      u->UART_THR = b;
    } while (--i);
    1234:	e2544001 	subs	r4, r4, #1
      u->UART_THR = b;
    1238:	e5850000 	str	r0, [r5]
    } while (--i);
    123c:	0a000007 	beq	1260 <preload+0x50>
      msg_t b = chOQGetI(&sdp->oqueue);
    1240:	e1a00006 	mov	r0, r6
    1244:	ebffffa1 	bl	10d0 <chOQGetI>
      if (b < Q_OK) {
    1248:	e3500000 	cmp	r0, #0
    124c:	aafffff8 	bge	1234 <preload+0x24>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
    1250:	e2870004 	add	r0, r7, #4
    1254:	e3a01008 	mov	r1, #8
  }
  u->UART_IER |= IER_THRE;
}
    1258:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
    125c:	eaffffd7 	b	11c0 <chEvtBroadcastFlagsI>
  u->UART_IER |= IER_THRE;
    1260:	e5953004 	ldr	r3, [r5, #4]
    1264:	e3833002 	orr	r3, r3, #2
    1268:	e5853004 	str	r3, [r5, #4]
}
    126c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00001270 <notify1>:
 */
#if USE_LPC214x_UART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  preload(&SD1);
    1270:	e59f0000 	ldr	r0, [pc]	; 1278 <notify1+0x8>
    1274:	eaffffe5 	b	1210 <preload>
    1278:	40000b10 	.word	0x40000b10
    127c:	00000000 	.word	0x00000000

00001280 <notify2>:
 */
#if USE_LPC214x_UART1 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  preload(&SD2);
    1280:	e59f0000 	ldr	r0, [pc]	; 1288 <notify2+0x8>
    1284:	eaffffe1 	b	1210 <preload>
    1288:	40000b88 	.word	0x40000b88
    128c:	00000000 	.word	0x00000000

00001290 <serve_interrupt>:
static void serve_interrupt(SerialDriver *sdp) {
    1290:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    1294:	e1a06000 	mov	r6, r0
  UART *u = sdp->uart;
    1298:	e5904074 	ldr	r4, [r0, #116]	; 0x74
        if (chIQPutI(&sdp->iqueue, u->UART_RBR) < Q_OK)
    129c:	e280500c 	add	r5, r0, #12
    switch (u->UART_IIR & IIR_SRC_MASK) {
    12a0:	e5943008 	ldr	r3, [r4, #8]
    12a4:	e203300f 	and	r3, r3, #15
    12a8:	e2433001 	sub	r3, r3, #1
    12ac:	e353000b 	cmp	r3, #11
    12b0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    12b4:	ea000039 	b	13a0 <serve_interrupt+0x110>
    12b8:	0000139c 	.word	0x0000139c
    12bc:	00001360 	.word	0x00001360
    12c0:	000013a0 	.word	0x000013a0
    12c4:	0000131c 	.word	0x0000131c
    12c8:	000013a0 	.word	0x000013a0
    12cc:	000012e8 	.word	0x000012e8
    12d0:	000013a0 	.word	0x000013a0
    12d4:	000013a0 	.word	0x000013a0
    12d8:	000013a0 	.word	0x000013a0
    12dc:	000013a0 	.word	0x000013a0
    12e0:	000013a0 	.word	0x000013a0
    12e4:	0000131c 	.word	0x0000131c
      set_error(sdp, u->UART_LSR);
    12e8:	e5943014 	ldr	r3, [r4, #20]
  eventflags_t sts = 0;
    12ec:	e3130002 	tst	r3, #2
    12f0:	13a01080 	movne	r1, #128	; 0x80
    12f4:	03a01000 	moveq	r1, #0
  if (err & LSR_PARITY)
    12f8:	e3130004 	tst	r3, #4
    sts |= SD_PARITY_ERROR;
    12fc:	13811020 	orrne	r1, r1, #32
  if (err & LSR_FRAMING)
    1300:	e3130008 	tst	r3, #8
    sts |= SD_FRAMING_ERROR;
    1304:	13811040 	orrne	r1, r1, #64	; 0x40
  if (err & LSR_BREAK)
    1308:	e3130010 	tst	r3, #16
    sts |= SD_BREAK_DETECTED;
    130c:	13811c02 	orrne	r1, r1, #512	; 0x200
    1310:	e2860004 	add	r0, r6, #4
    1314:	ebffffa9 	bl	11c0 <chEvtBroadcastFlagsI>
    1318:	eaffffe0 	b	12a0 <serve_interrupt+0x10>
      if (chIQIsEmptyI(&sdp->iqueue))
    131c:	e5963014 	ldr	r3, [r6, #20]
    1320:	e3530000 	cmp	r3, #0
    1324:	0a000020 	beq	13ac <serve_interrupt+0x11c>
          chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    1328:	e2867004 	add	r7, r6, #4
      while (u->UART_LSR & LSR_RBR_FULL) {
    132c:	e5943014 	ldr	r3, [r4, #20]
    1330:	e3130001 	tst	r3, #1
    1334:	0affffd9 	beq	12a0 <serve_interrupt+0x10>
        if (chIQPutI(&sdp->iqueue, u->UART_RBR) < Q_OK)
    1338:	e5941000 	ldr	r1, [r4]
    133c:	e1a00005 	mov	r0, r5
    1340:	e20110ff 	and	r1, r1, #255	; 0xff
    1344:	ebffff39 	bl	1030 <chIQPutI>
    1348:	e3500000 	cmp	r0, #0
    134c:	aafffff6 	bge	132c <serve_interrupt+0x9c>
    1350:	e3a01080 	mov	r1, #128	; 0x80
    1354:	e1a00007 	mov	r0, r7
    1358:	ebffff98 	bl	11c0 <chEvtBroadcastFlagsI>
    135c:	eafffff2 	b	132c <serve_interrupt+0x9c>
    switch (u->UART_IIR & IIR_SRC_MASK) {
    1360:	e3a07010 	mov	r7, #16
    1364:	e2868030 	add	r8, r6, #48	; 0x30
    1368:	ea000002 	b	1378 <serve_interrupt+0xe8>
        } while (--i);
    136c:	e2577001 	subs	r7, r7, #1
          u->UART_THR = b;
    1370:	e5840000 	str	r0, [r4]
        } while (--i);
    1374:	0affffc9 	beq	12a0 <serve_interrupt+0x10>
          b = chOQGetI(&sdp->oqueue);
    1378:	e1a00008 	mov	r0, r8
    137c:	ebffff53 	bl	10d0 <chOQGetI>
          if (b < Q_OK) {
    1380:	e3500000 	cmp	r0, #0
    1384:	aafffff8 	bge	136c <serve_interrupt+0xdc>
            u->UART_IER &= ~IER_THRE;
    1388:	e5943004 	ldr	r3, [r4, #4]
    138c:	e3c33002 	bic	r3, r3, #2
    1390:	e5843004 	str	r3, [r4, #4]
    1394:	e3a01008 	mov	r1, #8
    1398:	eaffffdc 	b	1310 <serve_interrupt+0x80>
}
    139c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
      (void) u->UART_THR;
    13a0:	e5943000 	ldr	r3, [r4]
      (void) u->UART_RBR;
    13a4:	e5943000 	ldr	r3, [r4]
    13a8:	eaffffbc 	b	12a0 <serve_interrupt+0x10>
    13ac:	e3a01004 	mov	r1, #4
    13b0:	e0860001 	add	r0, r6, r1
    13b4:	ebffff81 	bl	11c0 <chEvtBroadcastFlagsI>
    13b8:	eaffffda 	b	1328 <serve_interrupt+0x98>
    13bc:	00000000 	andeq	r0, r0, r0

000013c0 <UART0IrqHandler>:
 * @brief   UART0 IRQ handler.
 *
 * @isr
 */
#if USE_LPC214x_UART0 || defined(__DOXYGEN__)
CH_IRQ_HANDLER(UART0IrqHandler) {
    13c0:	e92d4010 	push	{r4, lr}

  CH_IRQ_PROLOGUE();

  serve_interrupt(&SD1);
    13c4:	e59f0014 	ldr	r0, [pc, #20]	; 13e0 <UART0IrqHandler+0x20>
    13c8:	ebffffb0 	bl	1290 <serve_interrupt>
  VICVectAddr = 0;
    13cc:	e3e03c0f 	mvn	r3, #3840	; 0xf00
    13d0:	e3a02000 	mov	r2, #0

  CH_IRQ_EPILOGUE();
}
    13d4:	e8bd4010 	pop	{r4, lr}
  VICVectAddr = 0;
    13d8:	e50320cf 	str	r2, [r3, #-207]	; 0xffffff31
  CH_IRQ_EPILOGUE();
    13dc:	eafffe8f 	b	e20 <chSchIsPreemptionRequired>
    13e0:	40000b10 	.word	0x40000b10
	...

000013f0 <UART1IrqHandler>:
 * @brief   UART1 IRQ handler.
 *
 * @isr
 */
#if USE_LPC214x_UART1 || defined(__DOXYGEN__)
CH_IRQ_HANDLER(UART1IrqHandler) {
    13f0:	e92d4010 	push	{r4, lr}

  CH_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
    13f4:	e59f0014 	ldr	r0, [pc, #20]	; 1410 <UART1IrqHandler+0x20>
    13f8:	ebffffa4 	bl	1290 <serve_interrupt>
  VICVectAddr = 0;
    13fc:	e3e03c0f 	mvn	r3, #3840	; 0xf00
    1400:	e3a02000 	mov	r2, #0

  CH_IRQ_EPILOGUE();
}
    1404:	e8bd4010 	pop	{r4, lr}
  VICVectAddr = 0;
    1408:	e50320cf 	str	r2, [r3, #-207]	; 0xffffff31
  CH_IRQ_EPILOGUE();
    140c:	eafffe83 	b	e20 <chSchIsPreemptionRequired>
    1410:	40000b88 	.word	0x40000b88
	...

00001420 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
    1420:	e1a0c000 	mov	ip, r0
  thread_t *ctp = currp;
    1424:	e59f2080 	ldr	r2, [pc, #128]	; 14ac <chMtxUnlockS+0x8c>
void chMtxUnlockS(mutex_t *mp) {
    1428:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    142c:	e590e000 	ldr	lr, [r0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
    1430:	e590300c 	ldr	r3, [r0, #12]
  thread_t *ctp = currp;
    1434:	e5920018 	ldr	r0, [r2, #24]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
    1438:	e15e000c 	cmp	lr, ip
    ctp->p_mtxlist = mp->m_next;
    143c:	e580303c 	str	r3, [r0, #60]	; 0x3c
    if (chMtxQueueNotEmptyS(mp)) {
    1440:	0a000016 	beq	14a0 <chMtxUnlockS+0x80>

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
    1444:	e3530000 	cmp	r3, #0
      tprio_t newprio = ctp->p_realprio;
    1448:	e5901040 	ldr	r1, [r0, #64]	; 0x40
      while (lmp != NULL) {
    144c:	0a000008 	beq	1474 <chMtxUnlockS+0x54>
    1450:	e5932000 	ldr	r2, [r3]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
    1454:	e1530002 	cmp	r3, r2
    1458:	0a000002 	beq	1468 <chMtxUnlockS+0x48>
    145c:	e5922008 	ldr	r2, [r2, #8]
    1460:	e1510002 	cmp	r1, r2
    1464:	31a01002 	movcc	r1, r2
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
    1468:	e593300c 	ldr	r3, [r3, #12]
      while (lmp != NULL) {
    146c:	e3530000 	cmp	r3, #0
    1470:	1afffff6 	bne	1450 <chMtxUnlockS+0x30>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
    1474:	e59e203c 	ldr	r2, [lr, #60]	; 0x3c
  tqp->p_next = tp->p_next;
    1478:	e59e3000 	ldr	r3, [lr]
      ctp->p_prio = newprio;
    147c:	e5801008 	str	r1, [r0, #8]
    1480:	e58c3000 	str	r3, [ip]
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
    1484:	e1a0000e 	mov	r0, lr
  tqp->p_next->p_prev = (thread_t *)tqp;
    1488:	e583c004 	str	ip, [r3, #4]
      mp->m_owner = tp;
    148c:	e58ce008 	str	lr, [ip, #8]
      mp->m_next = tp->p_mtxlist;
    1490:	e58c200c 	str	r2, [ip, #12]
      tp->p_mtxlist = mp;
    1494:	e58ec03c 	str	ip, [lr, #60]	; 0x3c
      mp->m_owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
    1498:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
      (void) chSchReadyI(tp);
    149c:	eafffec3 	b	fb0 <chSchReadyI>
      mp->m_owner = NULL;
    14a0:	e3a03000 	mov	r3, #0
    14a4:	e58e3008 	str	r3, [lr, #8]
}
    14a8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    14ac:	40000c00 	.word	0x40000c00

000014b0 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
    14b0:	e5903008 	ldr	r3, [r0, #8]
    14b4:	e2833001 	add	r3, r3, #1
    14b8:	e3530000 	cmp	r3, #0
void chSemSignalI(semaphore_t *sp) {
    14bc:	e1a02000 	mov	r2, r0
  if (++sp->s_cnt <= (cnt_t)0) {
    14c0:	e5803008 	str	r3, [r0, #8]
    14c4:	c12fff1e 	bxgt	lr
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
    14c8:	e3a0c000 	mov	ip, #0
  thread_t *tp = tqp->p_next;
    14cc:	e5903000 	ldr	r3, [r0]
  tqp->p_next = tp->p_next;
    14d0:	e5931000 	ldr	r1, [r3]
    (void) chSchReadyI(tp);
    14d4:	e1a00003 	mov	r0, r3
    14d8:	e5821000 	str	r1, [r2]
  tqp->p_next->p_prev = (thread_t *)tqp;
    14dc:	e5812004 	str	r2, [r1, #4]
    tp->p_u.rdymsg = MSG_OK;
    14e0:	e583c024 	str	ip, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
    14e4:	eafffeb1 	b	fb0 <chSchReadyI>
	...

000014f0 <chMBPostI.constprop.15>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    14f0:	e59f304c 	ldr	r3, [pc, #76]	; 1544 <chMBPostI.constprop.15+0x54>
    14f4:	e5932024 	ldr	r2, [r3, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    14f8:	e3520000 	cmp	r2, #0
    14fc:	da00000e 	ble	153c <chMBPostI.constprop.15+0x4c>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
    1500:	e5931008 	ldr	r1, [r3, #8]
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
    1504:	e92d4010 	push	{r4, lr}
  if (mbp->mb_wrptr >= mbp->mb_top) {
    1508:	e593e004 	ldr	lr, [r3, #4]
  *mbp->mb_wrptr++ = msg;
    150c:	e281c004 	add	ip, r1, #4
  sp->s_cnt--;
    1510:	e2422001 	sub	r2, r2, #1
  if (mbp->mb_wrptr >= mbp->mb_top) {
    1514:	e15c000e 	cmp	ip, lr
    1518:	e5832024 	str	r2, [r3, #36]	; 0x24
     mbp->mb_wrptr = mbp->mb_buffer;
    151c:	25932000 	ldrcs	r2, [r3]
  *mbp->mb_wrptr++ = msg;
    1520:	e583c008 	str	ip, [r3, #8]
    1524:	e5810000 	str	r0, [r1]
  }
  chSemSignalI(&mbp->mb_fullsem);
    1528:	e59f0018 	ldr	r0, [pc, #24]	; 1548 <chMBPostI.constprop.15+0x58>
     mbp->mb_wrptr = mbp->mb_buffer;
    152c:	25832008 	strcs	r2, [r3, #8]
  chSemSignalI(&mbp->mb_fullsem);
    1530:	ebffffde 	bl	14b0 <chSemSignalI>

  return MSG_OK;
    1534:	e3a00000 	mov	r0, #0
}
    1538:	e8bd8010 	pop	{r4, pc}
    return MSG_TIMEOUT;
    153c:	e3e00000 	mvn	r0, #0
}
    1540:	e12fff1e 	bx	lr
    1544:	40000aac 	.word	0x40000aac
    1548:	40000abc 	.word	0x40000abc
    154c:	00000000 	.word	0x00000000

00001550 <chMBPostAheadI.constprop.13>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
    1550:	e59f2050 	ldr	r2, [pc, #80]	; 15a8 <chMBPostAheadI.constprop.13+0x58>
    1554:	e5921024 	ldr	r1, [r2, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    1558:	e3510000 	cmp	r1, #0
    155c:	da00000f 	ble	15a0 <chMBPostAheadI.constprop.13+0x50>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
    1560:	e592300c 	ldr	r3, [r2, #12]
    1564:	e592c000 	ldr	ip, [r2]
    1568:	e2433004 	sub	r3, r3, #4
    156c:	e153000c 	cmp	r3, ip
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
    1570:	e92d4010 	push	{r4, lr}
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
    1574:	e582300c 	str	r3, [r2, #12]
    mbp->mb_rdptr = mbp->mb_top - 1;
    1578:	35923004 	ldrcc	r3, [r2, #4]
    157c:	e2411001 	sub	r1, r1, #1
    1580:	32433004 	subcc	r3, r3, #4
    1584:	e5821024 	str	r1, [r2, #36]	; 0x24
    1588:	3582300c 	strcc	r3, [r2, #12]
  }
  *mbp->mb_rdptr = msg;
    158c:	e5830000 	str	r0, [r3]
  chSemSignalI(&mbp->mb_fullsem);
    1590:	e59f0014 	ldr	r0, [pc, #20]	; 15ac <chMBPostAheadI.constprop.13+0x5c>
    1594:	ebffffc5 	bl	14b0 <chSemSignalI>

  return MSG_OK;
    1598:	e3a00000 	mov	r0, #0
}
    159c:	e8bd8010 	pop	{r4, pc}
    return MSG_TIMEOUT;
    15a0:	e3e00000 	mvn	r0, #0
}
    15a4:	e12fff1e 	bx	lr
    15a8:	40000aac 	.word	0x40000aac
    15ac:	40000abc 	.word	0x40000abc

000015b0 <chMBFetchI.constprop.11>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
    15b0:	e59f3050 	ldr	r3, [pc, #80]	; 1608 <chMBFetchI.constprop.11+0x58>
    15b4:	e5932018 	ldr	r2, [r3, #24]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    15b8:	e3520000 	cmp	r2, #0
    15bc:	da00000f 	ble	1600 <chMBFetchI.constprop.11+0x50>
    15c0:	e2422001 	sub	r2, r2, #1
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
    15c4:	e92d4010 	push	{r4, lr}
    15c8:	e5832018 	str	r2, [r3, #24]
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
    15cc:	e593200c 	ldr	r2, [r3, #12]
  if (mbp->mb_rdptr >= mbp->mb_top) {
    15d0:	e593c004 	ldr	ip, [r3, #4]
  *msgp = *mbp->mb_rdptr++;
    15d4:	e5921000 	ldr	r1, [r2]
    15d8:	e2822004 	add	r2, r2, #4
  if (mbp->mb_rdptr >= mbp->mb_top) {
    15dc:	e152000c 	cmp	r2, ip
  *msgp = *mbp->mb_rdptr++;
    15e0:	e583200c 	str	r2, [r3, #12]
    mbp->mb_rdptr = mbp->mb_buffer;
    15e4:	25932000 	ldrcs	r2, [r3]
  *msgp = *mbp->mb_rdptr++;
    15e8:	e5801000 	str	r1, [r0]
  }
  chSemSignalI(&mbp->mb_emptysem);
    15ec:	e59f0018 	ldr	r0, [pc, #24]	; 160c <chMBFetchI.constprop.11+0x5c>
    mbp->mb_rdptr = mbp->mb_buffer;
    15f0:	2583200c 	strcs	r2, [r3, #12]
  chSemSignalI(&mbp->mb_emptysem);
    15f4:	ebffffad 	bl	14b0 <chSemSignalI>

  return MSG_OK;
    15f8:	e3a00000 	mov	r0, #0
}
    15fc:	e8bd8010 	pop	{r4, pc}
    return MSG_TIMEOUT;
    1600:	e3e00000 	mvn	r0, #0
}
    1604:	e12fff1e 	bx	lr
    1608:	40000aac 	.word	0x40000aac
    160c:	40000ac8 	.word	0x40000ac8

00001610 <chSemResetI>:
void chSemResetI(semaphore_t *sp, cnt_t n) {
    1610:	e92d4070 	push	{r4, r5, r6, lr}
  cnt = sp->s_cnt;
    1614:	e5905008 	ldr	r5, [r0, #8]
  while (++cnt <= (cnt_t)0) {
    1618:	e2855001 	add	r5, r5, #1
    161c:	e3550000 	cmp	r5, #0
  sp->s_cnt = n;
    1620:	e5801008 	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
    1624:	c8bd8070 	popgt	{r4, r5, r6, pc}
    1628:	e1a04000 	mov	r4, r0
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
    162c:	e3e06001 	mvn	r6, #1
  thread_t *tp = tqp->p_prev;
    1630:	e5940004 	ldr	r0, [r4, #4]
  tqp->p_prev = tp->p_prev;
    1634:	e5903004 	ldr	r3, [r0, #4]
    1638:	e5843004 	str	r3, [r4, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
    163c:	e5834000 	str	r4, [r3]
    1640:	ebfffe5a 	bl	fb0 <chSchReadyI>
  while (++cnt <= (cnt_t)0) {
    1644:	e2855001 	add	r5, r5, #1
    1648:	e3550001 	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
    164c:	e5806024 	str	r6, [r0, #36]	; 0x24
  while (++cnt <= (cnt_t)0) {
    1650:	1afffff6 	bne	1630 <chSemResetI+0x20>
    1654:	e8bd8070 	pop	{r4, r5, r6, pc}
	...

00001660 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
    1660:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
    1664:	e3e0c000 	mvn	ip, #0
  vtp->vt_func = NULL;
    1668:	e3a0e000 	mov	lr, #0
  vtp->vt_next->vt_delta += vtp->vt_delta;
    166c:	e5903000 	ldr	r3, [r0]
    1670:	e5901008 	ldr	r1, [r0, #8]
    1674:	e5932008 	ldr	r2, [r3, #8]
    1678:	e0822001 	add	r2, r2, r1
  vtp->vt_prev->vt_next = vtp->vt_next;
    167c:	e5901004 	ldr	r1, [r0, #4]
  vtp->vt_next->vt_delta += vtp->vt_delta;
    1680:	e5832008 	str	r2, [r3, #8]
  vtp->vt_prev->vt_next = vtp->vt_next;
    1684:	e5813000 	str	r3, [r1]
  ch.vtlist.vt_delta = (systime_t)-1;
    1688:	e59f3010 	ldr	r3, [pc, #16]	; 16a0 <chVTDoResetI+0x40>
  vtp->vt_next->vt_prev = vtp->vt_prev;
    168c:	e5902000 	ldr	r2, [r0]
    1690:	e5821004 	str	r1, [r2, #4]
  vtp->vt_func = NULL;
    1694:	e580e00c 	str	lr, [r0, #12]
  ch.vtlist.vt_delta = (systime_t)-1;
    1698:	e583c024 	str	ip, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
    169c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    16a0:	40000c00 	.word	0x40000c00
	...

000016b0 <chVTDoSetI>:
                vtfunc_t vtfunc, void *par) {
    16b0:	e92d4010 	push	{r4, lr}
  p = ch.vtlist.vt_next;
    16b4:	e59f4058 	ldr	r4, [pc, #88]	; 1714 <chVTDoSetI+0x64>
    16b8:	e594c01c 	ldr	ip, [r4, #28]
  while (p->vt_delta < delta) {
    16bc:	e59ce008 	ldr	lr, [ip, #8]
    16c0:	e151000e 	cmp	r1, lr
  vtp->vt_par = par;
    16c4:	e5803010 	str	r3, [r0, #16]
  vtp->vt_func = vtfunc;
    16c8:	e580200c 	str	r2, [r0, #12]
  while (p->vt_delta < delta) {
    16cc:	9a000004 	bls	16e4 <chVTDoSetI+0x34>
    p = p->vt_next;
    16d0:	e59cc000 	ldr	ip, [ip]
    delta -= p->vt_delta;
    16d4:	e041100e 	sub	r1, r1, lr
  while (p->vt_delta < delta) {
    16d8:	e59ce008 	ldr	lr, [ip, #8]
    16dc:	e15e0001 	cmp	lr, r1
    16e0:	3afffffa 	bcc	16d0 <chVTDoSetI+0x20>
  ch.vtlist.vt_delta = (systime_t)-1;
    16e4:	e3e02000 	mvn	r2, #0
  vtp->vt_prev = vtp->vt_next->vt_prev;
    16e8:	e59c3004 	ldr	r3, [ip, #4]
  vtp->vt_next = p;
    16ec:	e580c000 	str	ip, [r0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
    16f0:	e5803004 	str	r3, [r0, #4]
  vtp->vt_prev->vt_next = vtp;
    16f4:	e5830000 	str	r0, [r3]
  p->vt_prev = vtp;
    16f8:	e58c0004 	str	r0, [ip, #4]
  vtp->vt_delta = delta
    16fc:	e5801008 	str	r1, [r0, #8]
  p->vt_delta -= delta;
    1700:	e59c3008 	ldr	r3, [ip, #8]
    1704:	e0431001 	sub	r1, r3, r1
    1708:	e58c1008 	str	r1, [ip, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
    170c:	e5842024 	str	r2, [r4, #36]	; 0x24
}
    1710:	e8bd8010 	pop	{r4, pc}
    1714:	40000c00 	.word	0x40000c00
	...

00001720 <test_start_timer.constprop.1>:
  test_timer_done = FALSE;
    1720:	e3a02000 	mov	r2, #0
    1724:	e59f3034 	ldr	r3, [pc, #52]	; 1760 <test_start_timer.constprop.1+0x40>
void test_start_timer(unsigned ms) {
    1728:	e92d4010 	push	{r4, lr}
  test_timer_done = FALSE;
    172c:	e5c32000 	strb	r2, [r3]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    1730:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (chVTIsArmedI(vtp)) {
    1734:	e59f0028 	ldr	r0, [pc, #40]	; 1764 <test_start_timer.constprop.1+0x44>
    1738:	e590300c 	ldr	r3, [r0, #12]
    173c:	e1530002 	cmp	r3, r2
    chVTDoResetI(vtp);
    1740:	1bffffc6 	blne	1660 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
    1744:	e3a03000 	mov	r3, #0
    1748:	e59f2018 	ldr	r2, [pc, #24]	; 1768 <test_start_timer.constprop.1+0x48>
    174c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
    1750:	e59f000c 	ldr	r0, [pc, #12]	; 1764 <test_start_timer.constprop.1+0x44>
    1754:	ebffffd5 	bl	16b0 <chVTDoSetI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1758:	e321f01f 	msr	CPSR_c, #31
}
    175c:	e8bd8010 	pop	{r4, pc}
    1760:	40001418 	.word	0x40001418
    1764:	40001444 	.word	0x40001444
    1768:	00000270 	.word	0x00000270
    176c:	00000000 	.word	0x00000000

00001770 <chSysGetStatusAndLockX>:
  __asm volatile ("mrs     %[p0], CPSR" : [p0] "=r" (sts) :);
    1770:	e10f0000 	mrs	r0, CPSR
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    1774:	e3100080 	tst	r0, #128	; 0x80
    1778:	112fff1e 	bxne	lr
  __asm volatile ("mrs     %[p0], CPSR" : [p0] "=r" (sts) :);
    177c:	e10f3000 	mrs	r3, CPSR
  return (sts & (syssts_t)0x1F) == (syssts_t)0x12;
    1780:	e203301f 	and	r3, r3, #31
    if (port_is_isr_context()) {
    1784:	e3530012 	cmp	r3, #18
    1788:	012fff1e 	bxeq	lr
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    178c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    else {
      chSysLock();
    }
  }
  return sts;
}
    1790:	e12fff1e 	bx	lr
	...

000017a0 <chSysIntegrityCheckI>:
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    17a0:	e3100001 	tst	r0, #1
    17a4:	0a000011 	beq	17f0 <chSysIntegrityCheckI+0x50>
    tp = ch.rlist.r_queue.p_next;
    17a8:	e59f311c 	ldr	r3, [pc, #284]	; 18cc <chSysIntegrityCheckI+0x12c>
    17ac:	e5931000 	ldr	r1, [r3]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
    17b0:	e1510003 	cmp	r1, r3
    17b4:	e593c004 	ldr	ip, [r3, #4]
    17b8:	0a000038 	beq	18a0 <chSysIntegrityCheckI+0x100>
    n = (cnt_t)0;
    17bc:	e3a02000 	mov	r2, #0
      tp = tp->p_next;
    17c0:	e5911000 	ldr	r1, [r1]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
    17c4:	e1510003 	cmp	r1, r3
      n++;
    17c8:	e2822001 	add	r2, r2, #1
    while (tp != (thread_t *)&ch.rlist.r_queue) {
    17cc:	1afffffb 	bne	17c0 <chSysIntegrityCheckI+0x20>
    while (tp != (thread_t *)&ch.rlist.r_queue) {
    17d0:	e15c0001 	cmp	ip, r1
    17d4:	0a00002f 	beq	1898 <chSysIntegrityCheckI+0xf8>
      tp = tp->p_prev;
    17d8:	e59cc004 	ldr	ip, [ip, #4]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
    17dc:	e15c0003 	cmp	ip, r3
      n--;
    17e0:	e2422001 	sub	r2, r2, #1
    while (tp != (thread_t *)&ch.rlist.r_queue) {
    17e4:	1afffffb 	bne	17d8 <chSysIntegrityCheckI+0x38>
    if (n != (cnt_t)0) {
    17e8:	e3520000 	cmp	r2, #0
    17ec:	1a000029 	bne	1898 <chSysIntegrityCheckI+0xf8>
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    17f0:	e3100002 	tst	r0, #2
    17f4:	0a000012 	beq	1844 <chSysIntegrityCheckI+0xa4>
    vtp = ch.vtlist.vt_next;
    17f8:	e59f30cc 	ldr	r3, [pc, #204]	; 18cc <chSysIntegrityCheckI+0x12c>
    17fc:	e593201c 	ldr	r2, [r3, #28]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
    1800:	e283c01c 	add	ip, r3, #28
    1804:	e152000c 	cmp	r2, ip
    1808:	e5931020 	ldr	r1, [r3, #32]
    180c:	0a000027 	beq	18b0 <chSysIntegrityCheckI+0x110>
    n = (cnt_t)0;
    1810:	e3a03000 	mov	r3, #0
      vtp = vtp->vt_next;
    1814:	e5922000 	ldr	r2, [r2]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
    1818:	e152000c 	cmp	r2, ip
      n++;
    181c:	e2833001 	add	r3, r3, #1
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
    1820:	1afffffb 	bne	1814 <chSysIntegrityCheckI+0x74>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
    1824:	e1510002 	cmp	r1, r2
    1828:	0a00001a 	beq	1898 <chSysIntegrityCheckI+0xf8>
      vtp = vtp->vt_prev;
    182c:	e5911004 	ldr	r1, [r1, #4]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
    1830:	e151000c 	cmp	r1, ip
      n--;
    1834:	e2433001 	sub	r3, r3, #1
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
    1838:	1afffffb 	bne	182c <chSysIntegrityCheckI+0x8c>
    if (n != (cnt_t)0) {
    183c:	e3530000 	cmp	r3, #0
    1840:	1a000014 	bne	1898 <chSysIntegrityCheckI+0xf8>
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    1844:	e2100004 	ands	r0, r0, #4
    1848:	012fff1e 	bxeq	lr
    tp = ch.rlist.r_newer;
    184c:	e59f3078 	ldr	r3, [pc, #120]	; 18cc <chSysIntegrityCheckI+0x12c>
    1850:	e5932010 	ldr	r2, [r3, #16]
    while (tp != (thread_t *)&ch.rlist) {
    1854:	e1520003 	cmp	r2, r3
    n = (cnt_t)0;
    1858:	e3a00000 	mov	r0, #0
    185c:	e5931014 	ldr	r1, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
    1860:	0a000016 	beq	18c0 <chSysIntegrityCheckI+0x120>
      tp = tp->p_newer;
    1864:	e5922010 	ldr	r2, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
    1868:	e1520003 	cmp	r2, r3
      n++;
    186c:	e2800001 	add	r0, r0, #1
    while (tp != (thread_t *)&ch.rlist) {
    1870:	1afffffb 	bne	1864 <chSysIntegrityCheckI+0xc4>
    while (tp != (thread_t *)&ch.rlist) {
    1874:	e1510002 	cmp	r1, r2
    1878:	0a000006 	beq	1898 <chSysIntegrityCheckI+0xf8>
      tp = tp->p_older;
    187c:	e5911014 	ldr	r1, [r1, #20]
    while (tp != (thread_t *)&ch.rlist) {
    1880:	e1510003 	cmp	r1, r3
      n--;
    1884:	e2400001 	sub	r0, r0, #1
    while (tp != (thread_t *)&ch.rlist) {
    1888:	1afffffb 	bne	187c <chSysIntegrityCheckI+0xdc>
    if (n != (cnt_t)0) {
    188c:	e2900000 	adds	r0, r0, #0
    1890:	13a00001 	movne	r0, #1
    1894:	e12fff1e 	bx	lr
      return true;
    1898:	e3a00001 	mov	r0, #1
}
    189c:	e12fff1e 	bx	lr
    while (tp != (thread_t *)&ch.rlist.r_queue) {
    18a0:	e15c0003 	cmp	ip, r3
    n = (cnt_t)0;
    18a4:	13a02000 	movne	r2, #0
    while (tp != (thread_t *)&ch.rlist.r_queue) {
    18a8:	1affffca 	bne	17d8 <chSysIntegrityCheckI+0x38>
    18ac:	eaffffcf 	b	17f0 <chSysIntegrityCheckI+0x50>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
    18b0:	e151000c 	cmp	r1, ip
    n = (cnt_t)0;
    18b4:	13a03000 	movne	r3, #0
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
    18b8:	1affffdb 	bne	182c <chSysIntegrityCheckI+0x8c>
    18bc:	eaffffe0 	b	1844 <chSysIntegrityCheckI+0xa4>
    while (tp != (thread_t *)&ch.rlist) {
    18c0:	e1510002 	cmp	r1, r2
    18c4:	1affffec 	bne	187c <chSysIntegrityCheckI+0xdc>
    18c8:	e12fff1e 	bx	lr
    18cc:	40000c00 	.word	0x40000c00

000018d0 <sys3_execute>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
    18d0:	e92d4010 	push	{r4, lr}
    18d4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  bool result;

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
    18d8:	e3a00001 	mov	r0, #1
    18dc:	ebffffaf 	bl	17a0 <chSysIntegrityCheckI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    18e0:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");
    18e4:	e2201001 	eor	r1, r0, #1
    18e8:	e20110ff 	and	r1, r1, #255	; 0xff
    18ec:	e3a00001 	mov	r0, #1
    18f0:	ebfffc2a 	bl	9a0 <_test_assert>
    18f4:	e3500000 	cmp	r0, #0
    18f8:	18bd8010 	popne	{r4, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    18fc:	e321f09f 	msr	CPSR_c, #159	; 0x9f

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
    1900:	e3a00002 	mov	r0, #2
    1904:	ebffffa5 	bl	17a0 <chSysIntegrityCheckI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1908:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();
  test_assert(2, result == false, "virtual timers list check failed");
    190c:	e2201001 	eor	r1, r0, #1
    1910:	e20110ff 	and	r1, r1, #255	; 0xff
    1914:	e3a00002 	mov	r0, #2
    1918:	ebfffc20 	bl	9a0 <_test_assert>
    191c:	e3500000 	cmp	r0, #0
    1920:	18bd8010 	popne	{r4, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    1924:	e321f09f 	msr	CPSR_c, #159	; 0x9f

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
    1928:	e3a00004 	mov	r0, #4
    192c:	ebffff9b 	bl	17a0 <chSysIntegrityCheckI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1930:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();
  test_assert(3, result == false, "registry list check failed");
    1934:	e2201001 	eor	r1, r0, #1
    1938:	e20110ff 	and	r1, r1, #255	; 0xff
    193c:	e3a00003 	mov	r0, #3
    1940:	ebfffc16 	bl	9a0 <_test_assert>
    1944:	e3500000 	cmp	r0, #0
    1948:	18bd8010 	popne	{r4, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    194c:	e321f09f 	msr	CPSR_c, #159	; 0x9f

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
    1950:	e3a00008 	mov	r0, #8
    1954:	ebffff91 	bl	17a0 <chSysIntegrityCheckI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1958:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
    195c:	e2201001 	eor	r1, r0, #1
    1960:	e20110ff 	and	r1, r1, #255	; 0xff
    1964:	e3a00004 	mov	r0, #4
}
    1968:	e8bd4010 	pop	{r4, lr}
  test_assert(4, result == false, "port layer check failed");
    196c:	eafffc0b 	b	9a0 <_test_assert>

00001970 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
    1970:	e92d4010 	push	{r4, lr}

  test_print("--- System: ");
    1974:	e59f00f0 	ldr	r0, [pc, #240]	; 1a6c <bmk13_execute+0xfc>
  test_printn(sizeof(ch_system_t));
  test_println(" bytes");
    1978:	e59f40f0 	ldr	r4, [pc, #240]	; 1a70 <bmk13_execute+0x100>
  test_print("--- System: ");
    197c:	ebfffc4f 	bl	ac0 <test_print>
    1980:	e3a00f52 	mov	r0, #328	; 0x148
    1984:	ebfffb59 	bl	6f0 <test_printn.part.1>
  test_println(" bytes");
    1988:	e1a00004 	mov	r0, r4
    198c:	ebfffc33 	bl	a60 <test_println>
  test_print("--- Thread: ");
    1990:	e59f00dc 	ldr	r0, [pc, #220]	; 1a74 <bmk13_execute+0x104>
    1994:	ebfffc49 	bl	ac0 <test_print>
    1998:	e3a00048 	mov	r0, #72	; 0x48
    199c:	ebfffb53 	bl	6f0 <test_printn.part.1>
  test_printn(sizeof(thread_t));
  test_println(" bytes");
    19a0:	e1a00004 	mov	r0, r4
    19a4:	ebfffc2d 	bl	a60 <test_println>
  test_print("--- Timer : ");
    19a8:	e59f00c8 	ldr	r0, [pc, #200]	; 1a78 <bmk13_execute+0x108>
    19ac:	ebfffc43 	bl	ac0 <test_print>
    19b0:	e3a00014 	mov	r0, #20
    19b4:	ebfffb4d 	bl	6f0 <test_printn.part.1>
  test_printn(sizeof(virtual_timer_t));
  test_println(" bytes");
    19b8:	e1a00004 	mov	r0, r4
    19bc:	ebfffc27 	bl	a60 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
    19c0:	e59f00b4 	ldr	r0, [pc, #180]	; 1a7c <bmk13_execute+0x10c>
    19c4:	ebfffc3d 	bl	ac0 <test_print>
    19c8:	e3a0000c 	mov	r0, #12
    19cc:	ebfffb47 	bl	6f0 <test_printn.part.1>
  test_printn(sizeof(semaphore_t));
  test_println(" bytes");
    19d0:	e1a00004 	mov	r0, r4
    19d4:	ebfffc21 	bl	a60 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
    19d8:	e59f00a0 	ldr	r0, [pc, #160]	; 1a80 <bmk13_execute+0x110>
    19dc:	ebfffc37 	bl	ac0 <test_print>
    19e0:	e3a00004 	mov	r0, #4
    19e4:	ebfffb41 	bl	6f0 <test_printn.part.1>
  test_printn(sizeof(event_source_t));
  test_println(" bytes");
    19e8:	e1a00004 	mov	r0, r4
    19ec:	ebfffc1b 	bl	a60 <test_println>
  test_print("--- EventL: ");
    19f0:	e59f008c 	ldr	r0, [pc, #140]	; 1a84 <bmk13_execute+0x114>
    19f4:	ebfffc31 	bl	ac0 <test_print>
    19f8:	e3a00014 	mov	r0, #20
    19fc:	ebfffb3b 	bl	6f0 <test_printn.part.1>
  test_printn(sizeof(event_listener_t));
  test_println(" bytes");
    1a00:	e1a00004 	mov	r0, r4
    1a04:	ebfffc15 	bl	a60 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
    1a08:	e59f0078 	ldr	r0, [pc, #120]	; 1a88 <bmk13_execute+0x118>
    1a0c:	ebfffc2b 	bl	ac0 <test_print>
    1a10:	e3a00010 	mov	r0, #16
    1a14:	ebfffb35 	bl	6f0 <test_printn.part.1>
  test_printn(sizeof(mutex_t));
  test_println(" bytes");
    1a18:	e1a00004 	mov	r0, r4
    1a1c:	ebfffc0f 	bl	a60 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
    1a20:	e59f0064 	ldr	r0, [pc, #100]	; 1a8c <bmk13_execute+0x11c>
    1a24:	ebfffc25 	bl	ac0 <test_print>
    1a28:	e3a00008 	mov	r0, #8
    1a2c:	ebfffb2f 	bl	6f0 <test_printn.part.1>
  test_printn(sizeof(condition_variable_t));
  test_println(" bytes");
    1a30:	e1a00004 	mov	r0, r4
    1a34:	ebfffc09 	bl	a60 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
    1a38:	e59f0050 	ldr	r0, [pc, #80]	; 1a90 <bmk13_execute+0x120>
    1a3c:	ebfffc1f 	bl	ac0 <test_print>
    1a40:	e3a00024 	mov	r0, #36	; 0x24
    1a44:	ebfffb29 	bl	6f0 <test_printn.part.1>
  test_printn(sizeof(io_queue_t));
  test_println(" bytes");
    1a48:	e1a00004 	mov	r0, r4
    1a4c:	ebfffc03 	bl	a60 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
    1a50:	e59f003c 	ldr	r0, [pc, #60]	; 1a94 <bmk13_execute+0x124>
    1a54:	ebfffc19 	bl	ac0 <test_print>
    1a58:	e3a00028 	mov	r0, #40	; 0x28
    1a5c:	ebfffb23 	bl	6f0 <test_printn.part.1>
  test_printn(sizeof(mailbox_t));
  test_println(" bytes");
    1a60:	e1a00004 	mov	r0, r4
#endif
}
    1a64:	e8bd4010 	pop	{r4, lr}
  test_println(" bytes");
    1a68:	eafffbfc 	b	a60 <test_println>
    1a6c:	00008050 	.word	0x00008050
    1a70:	00008060 	.word	0x00008060
    1a74:	00008068 	.word	0x00008068
    1a78:	00008078 	.word	0x00008078
    1a7c:	00008088 	.word	0x00008088
    1a80:	00008098 	.word	0x00008098
    1a84:	000080a8 	.word	0x000080a8
    1a88:	000080b8 	.word	0x000080b8
    1a8c:	000080c8 	.word	0x000080c8
    1a90:	000080d8 	.word	0x000080d8
    1a94:	000080e8 	.word	0x000080e8
	...

00001aa0 <chThdYield>:
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    1aa0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
    1aa4:	e59f2078 	ldr	r2, [pc, #120]	; 1b24 <chThdYield+0x84>
    1aa8:	e5920000 	ldr	r0, [r2]
    1aac:	e592c018 	ldr	ip, [r2, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
    1ab0:	e5903008 	ldr	r3, [r0, #8]
  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
    1ab4:	e59c1008 	ldr	r1, [ip, #8]
  if (chSchCanYieldS()) {
    1ab8:	e1530001 	cmp	r3, r1
    1abc:	2a000001 	bcs	1ac8 <chThdYield+0x28>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1ac0:	e321f01f 	msr	CPSR_c, #31
    1ac4:	e12fff1e 	bx	lr
void chThdYield(void) {
    1ac8:	e92d4010 	push	{r4, lr}
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
    1acc:	e3a04001 	mov	r4, #1
  tp->p_state = CH_STATE_READY;
    1ad0:	e3a0e000 	mov	lr, #0
  tqp->p_next = tp->p_next;
    1ad4:	e5903000 	ldr	r3, [r0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1ad8:	e5832004 	str	r2, [r3, #4]
  tqp->p_next = tp->p_next;
    1adc:	e5823000 	str	r3, [r2]
  currp->p_state = CH_STATE_CURRENT;
    1ae0:	e5c0401c 	strb	r4, [r0, #28]
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    1ae4:	e5820018 	str	r0, [r2, #24]
  tp->p_state = CH_STATE_READY;
    1ae8:	e5cce01c 	strb	lr, [ip, #28]
    1aec:	ea000000 	b	1af4 <chThdYield+0x54>
    1af0:	e5933000 	ldr	r3, [r3]
  } while (cp->p_prio >= tp->p_prio);
    1af4:	e5932008 	ldr	r2, [r3, #8]
    1af8:	e1510002 	cmp	r1, r2
    1afc:	9afffffb 	bls	1af0 <chThdYield+0x50>
  tp->p_prev = cp->p_prev;
    1b00:	e5932004 	ldr	r2, [r3, #4]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
    1b04:	e1a0100c 	mov	r1, ip
  tp->p_next = cp;
    1b08:	e58c3000 	str	r3, [ip]
  tp->p_prev = cp->p_prev;
    1b0c:	e58c2004 	str	r2, [ip, #4]
  tp->p_prev->p_next = tp;
    1b10:	e582c000 	str	ip, [r2]
  cp->p_prev = tp;
    1b14:	e583c004 	str	ip, [r3, #4]
  chSysSwitch(currp, otp);
    1b18:	ebfff97c 	bl	110 <_port_switch_arm>
    1b1c:	e321f01f 	msr	CPSR_c, #31
}
    1b20:	e8bd8010 	pop	{r4, pc}
    1b24:	40000c00 	.word	0x40000c00
	...

00001b30 <thread8>:
static THD_FUNCTION(thread8, p) {
    1b30:	e92d4070 	push	{r4, r5, r6, lr}
    1b34:	e1a04000 	mov	r4, r0
    1b38:	e59f502c 	ldr	r5, [pc, #44]	; 1b6c <thread8+0x3c>
    chThdYield();
    1b3c:	ebffffd7 	bl	1aa0 <chThdYield>
    chThdYield();
    1b40:	ebffffd6 	bl	1aa0 <chThdYield>
    chThdYield();
    1b44:	ebffffd5 	bl	1aa0 <chThdYield>
    chThdYield();
    1b48:	ebffffd4 	bl	1aa0 <chThdYield>
    (*(uint32_t *)p) += 4;
    1b4c:	e5943000 	ldr	r3, [r4]
    1b50:	e2833004 	add	r3, r3, #4
    1b54:	e5843000 	str	r3, [r4]
  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
    1b58:	e5953018 	ldr	r3, [r5, #24]
  } while(!chThdShouldTerminateX());
    1b5c:	e5d3301d 	ldrb	r3, [r3, #29]
    1b60:	e3130004 	tst	r3, #4
    1b64:	0afffff4 	beq	1b3c <thread8+0xc>
    1b68:	e8bd8070 	pop	{r4, r5, r6, pc}
    1b6c:	40000c00 	.word	0x40000c00

00001b70 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
    1b70:	e92d4010 	push	{r4, lr}
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
    1b74:	e3a04001 	mov	r4, #1

  otp->p_state = CH_STATE_READY;
    1b78:	e3a0e000 	mov	lr, #0
  otp = currp;
    1b7c:	e59f2054 	ldr	r2, [pc, #84]	; 1bd8 <chSchDoRescheduleAhead+0x68>
  thread_t *tp = tqp->p_next;
    1b80:	e5920000 	ldr	r0, [r2]
    1b84:	e592c018 	ldr	ip, [r2, #24]
  tqp->p_next = tp->p_next;
    1b88:	e5903000 	ldr	r3, [r0]
  if (otp->p_prio == IDLEPRIO) {
    1b8c:	e59c1008 	ldr	r1, [ip, #8]
    1b90:	e5823000 	str	r3, [r2]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1b94:	e5832004 	str	r2, [r3, #4]
  currp->p_state = CH_STATE_CURRENT;
    1b98:	e5c0401c 	strb	r4, [r0, #28]
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    1b9c:	e5820018 	str	r0, [r2, #24]
  otp->p_state = CH_STATE_READY;
    1ba0:	e5cce01c 	strb	lr, [ip, #28]
    1ba4:	ea000000 	b	1bac <chSchDoRescheduleAhead+0x3c>
    1ba8:	e5933000 	ldr	r3, [r3]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
    1bac:	e5932008 	ldr	r2, [r3, #8]
    1bb0:	e1510002 	cmp	r1, r2
    1bb4:	3afffffb 	bcc	1ba8 <chSchDoRescheduleAhead+0x38>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
    1bb8:	e5932004 	ldr	r2, [r3, #4]
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
    1bbc:	e1a0100c 	mov	r1, ip
  otp->p_next = cp;
    1bc0:	e58c3000 	str	r3, [ip]
  otp->p_prev = cp->p_prev;
    1bc4:	e58c2004 	str	r2, [ip, #4]
}
    1bc8:	e8bd4010 	pop	{r4, lr}
  otp->p_prev->p_next = otp;
    1bcc:	e582c000 	str	ip, [r2]
  cp->p_prev = otp;
    1bd0:	e583c004 	str	ip, [r3, #4]
  chSysSwitch(currp, otp);
    1bd4:	eafff94d 	b	110 <_port_switch_arm>
    1bd8:	40000c00 	.word	0x40000c00
    1bdc:	00000000 	.word	0x00000000

00001be0 <chSchRescheduleS>:
  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
    1be0:	e59f3018 	ldr	r3, [pc, #24]	; 1c00 <chSchRescheduleS+0x20>
    1be4:	e5932000 	ldr	r2, [r3]
    1be8:	e5933018 	ldr	r3, [r3, #24]
  if (chSchIsRescRequiredI()) {
    1bec:	e5922008 	ldr	r2, [r2, #8]
    1bf0:	e5933008 	ldr	r3, [r3, #8]
    1bf4:	e1520003 	cmp	r2, r3
    1bf8:	912fff1e 	bxls	lr
    chSchDoRescheduleAhead();
    1bfc:	eaffffdb 	b	1b70 <chSchDoRescheduleAhead>
    1c00:	40000c00 	.word	0x40000c00
	...

00001c10 <thread4.lto_priv.67>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
    1c10:	e92d4010 	push	{r4, lr}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    1c14:	e321f09f 	msr	CPSR_c, #159	; 0x9f
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    1c18:	e5903008 	ldr	r3, [r0, #8]
    1c1c:	e3530000 	cmp	r3, #0
    1c20:	da000002 	ble	1c30 <thread4.lto_priv.67+0x20>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
    1c24:	ebffffed 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1c28:	e321f01f 	msr	CPSR_c, #31

  chBSemSignal((binary_semaphore_t *)p);
}
    1c2c:	e8bd8010 	pop	{r4, pc}
    chSemSignalI(&bsp->bs_sem);
    1c30:	ebfffe1e 	bl	14b0 <chSemSignalI>
    1c34:	eafffffa 	b	1c24 <thread4.lto_priv.67+0x14>
	...

00001c40 <chMtxUnlockAll>:
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
    1c40:	e59f3078 	ldr	r3, [pc, #120]	; 1cc0 <chMtxUnlockAll+0x80>
void chMtxUnlockAll(void) {
    1c44:	e92d4070 	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
    1c48:	e5934018 	ldr	r4, [r3, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    1c4c:	e321f09f 	msr	CPSR_c, #159	; 0x9f

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    1c50:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
    1c54:	e3530000 	cmp	r3, #0
    1c58:	0a000016 	beq	1cb8 <chMtxUnlockAll+0x78>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
    1c5c:	e3a05000 	mov	r5, #0
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    1c60:	e5932000 	ldr	r2, [r3]
      ctp->p_mtxlist = mp->m_next;
    1c64:	e593100c 	ldr	r1, [r3, #12]
      if (chMtxQueueNotEmptyS(mp)) {
    1c68:	e1530002 	cmp	r3, r2
      ctp->p_mtxlist = mp->m_next;
    1c6c:	e584103c 	str	r1, [r4, #60]	; 0x3c
        mp->m_owner = NULL;
    1c70:	05835008 	streq	r5, [r3, #8]
    1c74:	01a03001 	moveq	r3, r1
      if (chMtxQueueNotEmptyS(mp)) {
    1c78:	0a000009 	beq	1ca4 <chMtxUnlockAll+0x64>
        mp->m_next = tp->p_mtxlist;
    1c7c:	e592c03c 	ldr	ip, [r2, #60]	; 0x3c
  tqp->p_next = tp->p_next;
    1c80:	e5921000 	ldr	r1, [r2]
        (void) chSchReadyI(tp);
    1c84:	e1a00002 	mov	r0, r2
    1c88:	e5831000 	str	r1, [r3]
  tqp->p_next->p_prev = (thread_t *)tqp;
    1c8c:	e5813004 	str	r3, [r1, #4]
        mp->m_owner = tp;
    1c90:	e5832008 	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
    1c94:	e583c00c 	str	ip, [r3, #12]
        tp->p_mtxlist = mp;
    1c98:	e582303c 	str	r3, [r2, #60]	; 0x3c
        (void) chSchReadyI(tp);
    1c9c:	ebfffcc3 	bl	fb0 <chSchReadyI>
    1ca0:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
      }
    } while (ctp->p_mtxlist != NULL);
    1ca4:	e3530000 	cmp	r3, #0
    1ca8:	1affffec 	bne	1c60 <chMtxUnlockAll+0x20>
    ctp->p_prio = ctp->p_realprio;
    1cac:	e5943040 	ldr	r3, [r4, #64]	; 0x40
    1cb0:	e5843008 	str	r3, [r4, #8]
    chSchRescheduleS();
    1cb4:	ebffffc9 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1cb8:	e321f01f 	msr	CPSR_c, #31
  }
  chSysUnlock();
}
    1cbc:	e8bd8070 	pop	{r4, r5, r6, pc}
    1cc0:	40000c00 	.word	0x40000c00
	...

00001cd0 <chThdSetPriority>:
tprio_t chThdSetPriority(tprio_t newprio) {
    1cd0:	e92d4010 	push	{r4, lr}
    1cd4:	e1a01000 	mov	r1, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    1cd8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  oldprio = currp->p_realprio;
    1cdc:	e59f3038 	ldr	r3, [pc, #56]	; 1d1c <chThdSetPriority+0x4c>
    1ce0:	e5933018 	ldr	r3, [r3, #24]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
    1ce4:	e5930008 	ldr	r0, [r3, #8]
  oldprio = currp->p_realprio;
    1ce8:	e5934040 	ldr	r4, [r3, #64]	; 0x40
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
    1cec:	e040c004 	sub	ip, r0, r4
    1cf0:	e27c2000 	rsbs	r2, ip, #0
    1cf4:	e0a2200c 	adc	r2, r2, ip
    1cf8:	e1500001 	cmp	r0, r1
    1cfc:	33822001 	orrcc	r2, r2, #1
    1d00:	e3520000 	cmp	r2, #0
    currp->p_prio = newprio;
    1d04:	15831008 	strne	r1, [r3, #8]
  currp->p_realprio = newprio;
    1d08:	e5831040 	str	r1, [r3, #64]	; 0x40
  chSchRescheduleS();
    1d0c:	ebffffb3 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1d10:	e321f01f 	msr	CPSR_c, #31
}
    1d14:	e1a00004 	mov	r0, r4
    1d18:	e8bd8010 	pop	{r4, pc}
    1d1c:	40000c00 	.word	0x40000c00

00001d20 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
    1d20:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  return ch.rlist.r_current;
    1d24:	e59f61d0 	ldr	r6, [pc, #464]	; 1efc <thd3_execute+0x1dc>
  return chThdGetSelfX()->p_prio;
    1d28:	e5963018 	ldr	r3, [r6, #24]
    1d2c:	e5934008 	ldr	r4, [r3, #8]
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
    1d30:	e2845001 	add	r5, r4, #1
    1d34:	e1a00005 	mov	r0, r5
    1d38:	ebffffe4 	bl	1cd0 <chThdSetPriority>
    1d3c:	e1a07000 	mov	r7, r0
  test_assert(1, p1 == prio,
    1d40:	e0472004 	sub	r2, r7, r4
    1d44:	e2721000 	rsbs	r1, r2, #0
    1d48:	e0a11002 	adc	r1, r1, r2
    1d4c:	e3a00001 	mov	r0, #1
    1d50:	ebfffb12 	bl	9a0 <_test_assert>
    1d54:	e3500000 	cmp	r0, #0
    1d58:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
    1d5c:	e5963018 	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
    1d60:	e5931008 	ldr	r1, [r3, #8]
    1d64:	e0413005 	sub	r3, r1, r5
    1d68:	e2731000 	rsbs	r1, r3, #0
    1d6c:	e0a11003 	adc	r1, r1, r3
    1d70:	e3a00002 	mov	r0, #2
    1d74:	ebfffb09 	bl	9a0 <_test_assert>
    1d78:	e3500000 	cmp	r0, #0
    1d7c:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
    1d80:	e1a00007 	mov	r0, r7
    1d84:	ebffffd1 	bl	1cd0 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
    1d88:	e045e000 	sub	lr, r5, r0
    1d8c:	e27e1000 	rsbs	r1, lr, #0
    1d90:	e0a1100e 	adc	r1, r1, lr
    1d94:	e3a00003 	mov	r0, #3
    1d98:	ebfffb00 	bl	9a0 <_test_assert>
    1d9c:	e3500000 	cmp	r0, #0
    1da0:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
    1da4:	e5963018 	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
    1da8:	e5931008 	ldr	r1, [r3, #8]
    1dac:	e041c004 	sub	ip, r1, r4
    1db0:	e27c1000 	rsbs	r1, ip, #0
    1db4:	e0a1100c 	adc	r1, r1, ip
    1db8:	e3a00004 	mov	r0, #4
    1dbc:	ebfffaf7 	bl	9a0 <_test_assert>
    1dc0:	e3500000 	cmp	r0, #0
    1dc4:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    1dc8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return ch.rlist.r_current;
    1dcc:	e5962018 	ldr	r2, [r6, #24]
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
  chThdGetSelfX()->p_prio += 2;
    1dd0:	e5923008 	ldr	r3, [r2, #8]
    1dd4:	e2833002 	add	r3, r3, #2
    1dd8:	e5823008 	str	r3, [r2, #8]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1ddc:	e321f01f 	msr	CPSR_c, #31
  return chThdGetSelfX()->p_prio;
    1de0:	e5963018 	ldr	r3, [r6, #24]
  chSysUnlock();
  test_assert(5, chThdGetPriorityX() == prio + 2,
    1de4:	e5931008 	ldr	r1, [r3, #8]
    1de8:	e2847002 	add	r7, r4, #2
    1dec:	e0412007 	sub	r2, r1, r7
    1df0:	e2721000 	rsbs	r1, r2, #0
    1df4:	e0a11002 	adc	r1, r1, r2
    1df8:	e3a00005 	mov	r0, #5
    1dfc:	ebfffae7 	bl	9a0 <_test_assert>
    1e00:	e3500000 	cmp	r0, #0
    1e04:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
    1e08:	e1a00005 	mov	r0, r5
    1e0c:	ebffffaf 	bl	1cd0 <chThdSetPriority>
  test_assert(6, p1 == prio,
    1e10:	e0403004 	sub	r3, r0, r4
    1e14:	e2731000 	rsbs	r1, r3, #0
    1e18:	e0a11003 	adc	r1, r1, r3
    1e1c:	e3a00006 	mov	r0, #6
    1e20:	ebfffade 	bl	9a0 <_test_assert>
    1e24:	e3500000 	cmp	r0, #0
    1e28:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
    1e2c:	e5963018 	ldr	r3, [r6, #24]
    1e30:	e5931008 	ldr	r1, [r3, #8]
    1e34:	e041e007 	sub	lr, r1, r7
    1e38:	e27e1000 	rsbs	r1, lr, #0
    1e3c:	e0a1100e 	adc	r1, r1, lr
    1e40:	e3a00007 	mov	r0, #7
    1e44:	ebfffad5 	bl	9a0 <_test_assert>
    1e48:	e3500000 	cmp	r0, #0
    1e4c:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
    1e50:	e5963018 	ldr	r3, [r6, #24]
    1e54:	e5931040 	ldr	r1, [r3, #64]	; 0x40
    1e58:	e041c005 	sub	ip, r1, r5
    1e5c:	e27c1000 	rsbs	r1, ip, #0
    1e60:	e0a1100c 	adc	r1, r1, ip
    1e64:	e3a00008 	mov	r0, #8
    1e68:	ebfffacc 	bl	9a0 <_test_assert>
    1e6c:	e3500000 	cmp	r0, #0
    1e70:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
    1e74:	e2847003 	add	r7, r4, #3
    1e78:	e1a00007 	mov	r0, r7
    1e7c:	ebffff93 	bl	1cd0 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
    1e80:	e0450000 	sub	r0, r5, r0
    1e84:	e2701000 	rsbs	r1, r0, #0
    1e88:	e0a11000 	adc	r1, r1, r0
    1e8c:	e3a00009 	mov	r0, #9
    1e90:	ebfffac2 	bl	9a0 <_test_assert>
    1e94:	e3500000 	cmp	r0, #0
    1e98:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
    1e9c:	e5963018 	ldr	r3, [r6, #24]
    1ea0:	e5931008 	ldr	r1, [r3, #8]
    1ea4:	e0412007 	sub	r2, r1, r7
    1ea8:	e2721000 	rsbs	r1, r2, #0
    1eac:	e0a11002 	adc	r1, r1, r2
    1eb0:	e3a0000a 	mov	r0, #10
    1eb4:	ebfffab9 	bl	9a0 <_test_assert>
    1eb8:	e3500000 	cmp	r0, #0
    1ebc:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
    1ec0:	e5963018 	ldr	r3, [r6, #24]
    1ec4:	e5931040 	ldr	r1, [r3, #64]	; 0x40
    1ec8:	e0413007 	sub	r3, r1, r7
    1ecc:	e2731000 	rsbs	r1, r3, #0
    1ed0:	e0a11003 	adc	r1, r1, r3
    1ed4:	e3a0000b 	mov	r0, #11
    1ed8:	ebfffab0 	bl	9a0 <_test_assert>
    1edc:	e3500000 	cmp	r0, #0
    1ee0:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    1ee4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return ch.rlist.r_current;
    1ee8:	e5963018 	ldr	r3, [r6, #24]
              "unexpected real priority level");

  chSysLock();
  chThdGetSelfX()->p_prio = prio;
    1eec:	e5834008 	str	r4, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
    1ef0:	e5834040 	str	r4, [r3, #64]	; 0x40
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1ef4:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();
#endif
}
    1ef8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    1efc:	40000c00 	.word	0x40000c00

00001f00 <chSysRestoreStatusX.part.2>:
  __asm volatile ("mrs     %[p0], CPSR" : [p0] "=r" (sts) :);
    1f00:	e10f3000 	mrs	r3, CPSR
  return (sts & (syssts_t)0x1F) == (syssts_t)0x12;
    1f04:	e203301f 	and	r3, r3, #31
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
    1f08:	e3530012 	cmp	r3, #18
    1f0c:	012fff1e 	bxeq	lr
void chSysRestoreStatusX(syssts_t sts) {
    1f10:	e92d4010 	push	{r4, lr}
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
    1f14:	ebffff31 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    1f18:	e321f01f 	msr	CPSR_c, #31
      chSysUnlock();
    }
  }
}
    1f1c:	e8bd8010 	pop	{r4, pc}

00001f20 <vtcb>:
static void vtcb(void *p) {
    1f20:	e92d4010 	push	{r4, lr}
  sts = chSysGetStatusAndLockX();
    1f24:	ebfffe11 	bl	1770 <chSysGetStatusAndLockX>
  if (port_irq_enabled(sts)) {
    1f28:	e3100080 	tst	r0, #128	; 0x80
    1f2c:	18bd8010 	popne	{r4, pc}
}
    1f30:	e8bd4010 	pop	{r4, lr}
    1f34:	eafffff1 	b	1f00 <chSysRestoreStatusX.part.2>
	...

00001f40 <chSchWakeupS>:
void chSchWakeupS(thread_t *ntp, msg_t msg) {
    1f40:	e1a0c000 	mov	ip, r0
  if (ntp->p_prio <= currp->p_prio) {
    1f44:	e59f3094 	ldr	r3, [pc, #148]	; 1fe0 <chSchWakeupS+0xa0>
void chSchWakeupS(thread_t *ntp, msg_t msg) {
    1f48:	e92d4010 	push	{r4, lr}
  if (ntp->p_prio <= currp->p_prio) {
    1f4c:	e5934018 	ldr	r4, [r3, #24]
    1f50:	e590e008 	ldr	lr, [r0, #8]
    1f54:	e5940008 	ldr	r0, [r4, #8]
    1f58:	e15e0000 	cmp	lr, r0
  ntp->p_u.rdymsg = msg;
    1f5c:	e58c1024 	str	r1, [ip, #36]	; 0x24
  if (ntp->p_prio <= currp->p_prio) {
    1f60:	8a00000b 	bhi	1f94 <chSchWakeupS+0x54>
  tp->p_state = CH_STATE_READY;
    1f64:	e3a02000 	mov	r2, #0
    1f68:	e5cc201c 	strb	r2, [ip, #28]
    cp = cp->p_next;
    1f6c:	e5933000 	ldr	r3, [r3]
  } while (cp->p_prio >= tp->p_prio);
    1f70:	e5932008 	ldr	r2, [r3, #8]
    1f74:	e15e0002 	cmp	lr, r2
    1f78:	9afffffb 	bls	1f6c <chSchWakeupS+0x2c>
  tp->p_prev = cp->p_prev;
    1f7c:	e5932004 	ldr	r2, [r3, #4]
  tp->p_next = cp;
    1f80:	e58c3000 	str	r3, [ip]
  tp->p_prev = cp->p_prev;
    1f84:	e58c2004 	str	r2, [ip, #4]
  tp->p_prev->p_next = tp;
    1f88:	e582c000 	str	ip, [r2]
  cp->p_prev = tp;
    1f8c:	e583c004 	str	ip, [r3, #4]
}
    1f90:	e8bd8010 	pop	{r4, pc}
  tp->p_state = CH_STATE_READY;
    1f94:	e3a01000 	mov	r1, #0
  cp = (thread_t *)&ch.rlist.r_queue;
    1f98:	e1a02003 	mov	r2, r3
  tp->p_state = CH_STATE_READY;
    1f9c:	e5c4101c 	strb	r1, [r4, #28]
    cp = cp->p_next;
    1fa0:	e5922000 	ldr	r2, [r2]
  } while (cp->p_prio >= tp->p_prio);
    1fa4:	e5921008 	ldr	r1, [r2, #8]
    1fa8:	e1500001 	cmp	r0, r1
    1fac:	9afffffb 	bls	1fa0 <chSchWakeupS+0x60>
    ntp->p_state = CH_STATE_CURRENT;
    1fb0:	e3a00001 	mov	r0, #1
  tp->p_prev = cp->p_prev;
    1fb4:	e5921004 	ldr	r1, [r2, #4]
  tp->p_next = cp;
    1fb8:	e5842000 	str	r2, [r4]
  tp->p_prev = cp->p_prev;
    1fbc:	e5841004 	str	r1, [r4, #4]
  tp->p_prev->p_next = tp;
    1fc0:	e5814000 	str	r4, [r1]
  cp->p_prev = tp;
    1fc4:	e5824004 	str	r4, [r2, #4]
    ntp->p_state = CH_STATE_CURRENT;
    1fc8:	e5cc001c 	strb	r0, [ip, #28]
    chSysSwitch(ntp, otp);
    1fcc:	e1a01004 	mov	r1, r4
    1fd0:	e1a0000c 	mov	r0, ip
}
    1fd4:	e8bd4010 	pop	{r4, lr}
    setcurrp(ntp);
    1fd8:	e583c018 	str	ip, [r3, #24]
    chSysSwitch(ntp, otp);
    1fdc:	eafff84b 	b	110 <_port_switch_arm>
    1fe0:	40000c00 	.word	0x40000c00
	...

00001ff0 <chThdCreateFromMemoryPool.constprop.48>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
    1ff0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
    1ff4:	e59f50b0 	ldr	r5, [pc, #176]	; 20ac <chThdCreateFromMemoryPool.constprop.48+0xbc>
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
    1ff8:	e1a06000 	mov	r6, r0
  wsp = chPoolAlloc(mp);
    1ffc:	e1a00005 	mov	r0, r5
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
    2000:	e1a08001 	mov	r8, r1
  wsp = chPoolAlloc(mp);
    2004:	ebfffabd 	bl	b00 <chPoolAlloc>
  if (wsp == NULL) {
    2008:	e2504000 	subs	r4, r0, #0
    200c:	0a000024 	beq	20a4 <chThdCreateFromMemoryPool.constprop.48+0xb4>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2010:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  tp->p_mtxlist = NULL;
    2014:	e3a03000 	mov	r3, #0
  tp->p_state = CH_STATE_WTSTART;
    2018:	e3a07002 	mov	r7, #2
  tp->p_refs = (trefs_t)1;
    201c:	e3a01001 	mov	r1, #1
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    2020:	e5952004 	ldr	r2, [r5, #4]
    2024:	e59fe084 	ldr	lr, [pc, #132]	; 20b0 <chThdCreateFromMemoryPool.constprop.48+0xc0>
    2028:	e2422024 	sub	r2, r2, #36	; 0x24
    202c:	e084c002 	add	ip, r4, r2
    2030:	e584c00c 	str	ip, [r4, #12]
    2034:	e784e002 	str	lr, [r4, r2]
    2038:	e59f2074 	ldr	r2, [pc, #116]	; 20b4 <chThdCreateFromMemoryPool.constprop.48+0xc4>
    203c:	e58c8004 	str	r8, [ip, #4]
    2040:	e58c2020 	str	r2, [ip, #32]
  REG_INSERT(tp);
    2044:	e59fc06c 	ldr	ip, [pc, #108]	; 20b8 <chThdCreateFromMemoryPool.constprop.48+0xc8>
    2048:	e584c010 	str	ip, [r4, #16]
    204c:	e59c8014 	ldr	r8, [ip, #20]
  queue_init(&tp->p_msgqueue);
    2050:	e284202c 	add	r2, r4, #44	; 0x2c
  list_init(&tp->p_waiting);
    2054:	e284e028 	add	lr, r4, #40	; 0x28
  tp->p_prio = prio;
    2058:	e5846008 	str	r6, [r4, #8]
  tp->p_refs = (trefs_t)1;
    205c:	e5c4101e 	strb	r1, [r4, #30]
  REG_INSERT(tp);
    2060:	e5848014 	str	r8, [r4, #20]
  tp->p_realprio = prio;
    2064:	e5846040 	str	r6, [r4, #64]	; 0x40
  tp->p_state = CH_STATE_WTSTART;
    2068:	e5c4701c 	strb	r7, [r4, #28]
  tp->p_mtxlist = NULL;
    206c:	e584303c 	str	r3, [r4, #60]	; 0x3c
  tp->p_epending = (eventmask_t)0;
    2070:	e5843038 	str	r3, [r4, #56]	; 0x38
  tp->p_time = (systime_t)0;
    2074:	e5843020 	str	r3, [r4, #32]
  tp->p_name = NULL;
    2078:	e5843018 	str	r3, [r4, #24]

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_MPOOL;
  tp->p_mpool = mp;
  chSchWakeupS(tp, MSG_OK);
    207c:	e1a01003 	mov	r1, r3
  REG_INSERT(tp);
    2080:	e5884010 	str	r4, [r8, #16]
  tlp->p_next = (thread_t *)tlp;
    2084:	e584e028 	str	lr, [r4, #40]	; 0x28
  tp->p_flags = CH_FLAG_MODE_MPOOL;
    2088:	e5c4701d 	strb	r7, [r4, #29]
  tp->p_mpool = mp;
    208c:	e5845044 	str	r5, [r4, #68]	; 0x44
  tqp->p_next = (thread_t *)tqp;
    2090:	e584202c 	str	r2, [r4, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
    2094:	e5842030 	str	r2, [r4, #48]	; 0x30
    2098:	e58c4014 	str	r4, [ip, #20]
  chSchWakeupS(tp, MSG_OK);
    209c:	ebffffa7 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    20a0:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();

  return tp;
}
    20a4:	e1a00004 	mov	r0, r4
    20a8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    20ac:	40000dd0 	.word	0x40000dd0
    20b0:	00000a50 	.word	0x00000a50
    20b4:	00000180 	.word	0x00000180
    20b8:	40000c00 	.word	0x40000c00
    20bc:	00000000 	.word	0x00000000

000020c0 <chCondSignal.constprop.40>:
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    20c0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    20c4:	e59f3030 	ldr	r3, [pc, #48]	; 20fc <chCondSignal.constprop.40+0x3c>
    20c8:	e5930000 	ldr	r0, [r3]
  if (queue_notempty(&cp->c_queue)) {
    20cc:	e1500003 	cmp	r0, r3
    20d0:	0a000007 	beq	20f4 <chCondSignal.constprop.40+0x34>
  tqp->p_next = tp->p_next;
    20d4:	e5902000 	ldr	r2, [r0]
void chCondSignal(condition_variable_t *cp) {
    20d8:	e92d4010 	push	{r4, lr}
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
    20dc:	e3a01000 	mov	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
    20e0:	e5823004 	str	r3, [r2, #4]
  tqp->p_next = tp->p_next;
    20e4:	e5832000 	str	r2, [r3]
    20e8:	ebffff94 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    20ec:	e321f01f 	msr	CPSR_c, #31
}
    20f0:	e8bd8010 	pop	{r4, pc}
    20f4:	e321f01f 	msr	CPSR_c, #31
    20f8:	e12fff1e 	bx	lr
    20fc:	40000a58 	.word	0x40000a58

00002100 <chMtxUnlock>:
  thread_t *ctp = currp;
    2100:	e59f3094 	ldr	r3, [pc, #148]	; 219c <chMtxUnlock+0x9c>
void chMtxUnlock(mutex_t *mp) {
    2104:	e92d4010 	push	{r4, lr}
  thread_t *ctp = currp;
    2108:	e593e018 	ldr	lr, [r3, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    210c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    2110:	e590c000 	ldr	ip, [r0]
    ctp->p_mtxlist = mp->m_next;
    2114:	e590300c 	ldr	r3, [r0, #12]
    if (chMtxQueueNotEmptyS(mp)) {
    2118:	e15c0000 	cmp	ip, r0
    ctp->p_mtxlist = mp->m_next;
    211c:	e58e303c 	str	r3, [lr, #60]	; 0x3c
    if (chMtxQueueNotEmptyS(mp)) {
    2120:	0a000019 	beq	218c <chMtxUnlock+0x8c>
      while (lmp != NULL) {
    2124:	e3530000 	cmp	r3, #0
      tprio_t newprio = ctp->p_realprio;
    2128:	e59e1040 	ldr	r1, [lr, #64]	; 0x40
      while (lmp != NULL) {
    212c:	0a000008 	beq	2154 <chMtxUnlock+0x54>
    2130:	e5932000 	ldr	r2, [r3]
        if (chMtxQueueNotEmptyS(lmp) &&
    2134:	e1530002 	cmp	r3, r2
    2138:	0a000002 	beq	2148 <chMtxUnlock+0x48>
    213c:	e5922008 	ldr	r2, [r2, #8]
    2140:	e1510002 	cmp	r1, r2
    2144:	31a01002 	movcc	r1, r2
        lmp = lmp->m_next;
    2148:	e593300c 	ldr	r3, [r3, #12]
      while (lmp != NULL) {
    214c:	e3530000 	cmp	r3, #0
    2150:	1afffff6 	bne	2130 <chMtxUnlock+0x30>
    2154:	e1a03000 	mov	r3, r0
      mp->m_next = tp->p_mtxlist;
    2158:	e59c403c 	ldr	r4, [ip, #60]	; 0x3c
  tqp->p_next = tp->p_next;
    215c:	e59c2000 	ldr	r2, [ip]
      chSchWakeupS(tp, MSG_OK);
    2160:	e1a0000c 	mov	r0, ip
      ctp->p_prio = newprio;
    2164:	e58e1008 	str	r1, [lr, #8]
    2168:	e5832000 	str	r2, [r3]
      chSchWakeupS(tp, MSG_OK);
    216c:	e3a01000 	mov	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
    2170:	e5823004 	str	r3, [r2, #4]
      mp->m_owner = tp;
    2174:	e583c008 	str	ip, [r3, #8]
      mp->m_next = tp->p_mtxlist;
    2178:	e583400c 	str	r4, [r3, #12]
      tp->p_mtxlist = mp;
    217c:	e58c303c 	str	r3, [ip, #60]	; 0x3c
      chSchWakeupS(tp, MSG_OK);
    2180:	ebffff6e 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2184:	e321f01f 	msr	CPSR_c, #31
}
    2188:	e8bd8010 	pop	{r4, pc}
      mp->m_owner = NULL;
    218c:	e3a03000 	mov	r3, #0
    2190:	e58c3008 	str	r3, [ip, #8]
    2194:	e321f01f 	msr	CPSR_c, #31
}
    2198:	e8bd8010 	pop	{r4, pc}
    219c:	40000c00 	.word	0x40000c00

000021a0 <chSemSignal>:
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    21a0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (++sp->s_cnt <= (cnt_t)0) {
    21a4:	e5903008 	ldr	r3, [r0, #8]
    21a8:	e2833001 	add	r3, r3, #1
    21ac:	e3530000 	cmp	r3, #0
    21b0:	e5803008 	str	r3, [r0, #8]
    21b4:	da000001 	ble	21c0 <chSemSignal+0x20>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    21b8:	e321f01f 	msr	CPSR_c, #31
    21bc:	e12fff1e 	bx	lr
    21c0:	e1a03000 	mov	r3, r0
  thread_t *tp = tqp->p_next;
    21c4:	e5900000 	ldr	r0, [r0]
  tqp->p_next = tp->p_next;
    21c8:	e5902000 	ldr	r2, [r0]
void chSemSignal(semaphore_t *sp) {
    21cc:	e92d4010 	push	{r4, lr}
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
    21d0:	e3a01000 	mov	r1, #0
    21d4:	e5832000 	str	r2, [r3]
  tqp->p_next->p_prev = (thread_t *)tqp;
    21d8:	e5823004 	str	r3, [r2, #4]
    21dc:	ebffff57 	bl	1f40 <chSchWakeupS>
    21e0:	e321f01f 	msr	CPSR_c, #31
}
    21e4:	e8bd8010 	pop	{r4, pc}
	...

000021f0 <chThdCreateStatic>:
                            tprio_t prio, tfunc_t pf, void *arg) {
    21f0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    21f4:	e59d5018 	ldr	r5, [sp, #24]
    21f8:	e1a04000 	mov	r4, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    21fc:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  tp->p_mtxlist = NULL;
    2200:	e3a0c000 	mov	ip, #0
  tp->p_state = CH_STATE_WTSTART;
    2204:	e3a07002 	mov	r7, #2
  tp->p_refs = (trefs_t)1;
    2208:	e3a06001 	mov	r6, #1
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    220c:	e2411024 	sub	r1, r1, #36	; 0x24
    2210:	e080e001 	add	lr, r0, r1
    2214:	e580e00c 	str	lr, [r0, #12]
    2218:	e7803001 	str	r3, [r0, r1]
    221c:	e59f3064 	ldr	r3, [pc, #100]	; 2288 <chThdCreateStatic+0x98>
    2220:	e58e3020 	str	r3, [lr, #32]
  REG_INSERT(tp);
    2224:	e59f3060 	ldr	r3, [pc, #96]	; 228c <chThdCreateStatic+0x9c>
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    2228:	e58e5004 	str	r5, [lr, #4]
  REG_INSERT(tp);
    222c:	e5803010 	str	r3, [r0, #16]
    2230:	e593e014 	ldr	lr, [r3, #20]
  tp->p_realprio = prio;
    2234:	e5802040 	str	r2, [r0, #64]	; 0x40
  tp->p_prio = prio;
    2238:	e5802008 	str	r2, [r0, #8]
  list_init(&tp->p_waiting);
    223c:	e2805028 	add	r5, r0, #40	; 0x28
  queue_init(&tp->p_msgqueue);
    2240:	e280202c 	add	r2, r0, #44	; 0x2c
  REG_INSERT(tp);
    2244:	e580e014 	str	lr, [r0, #20]
  tp->p_state = CH_STATE_WTSTART;
    2248:	e1c071bc 	strh	r7, [r0, #28]
  tp->p_refs = (trefs_t)1;
    224c:	e5c0601e 	strb	r6, [r0, #30]
  tp->p_mtxlist = NULL;
    2250:	e580c03c 	str	ip, [r0, #60]	; 0x3c
  tp->p_epending = (eventmask_t)0;
    2254:	e580c038 	str	ip, [r0, #56]	; 0x38
  tp->p_time = (systime_t)0;
    2258:	e580c020 	str	ip, [r0, #32]
  tp->p_name = NULL;
    225c:	e580c018 	str	ip, [r0, #24]
  chSchWakeupS(tp, MSG_OK);
    2260:	e1a0100c 	mov	r1, ip
  REG_INSERT(tp);
    2264:	e58e0010 	str	r0, [lr, #16]
  tlp->p_next = (thread_t *)tlp;
    2268:	e5805028 	str	r5, [r0, #40]	; 0x28
  tqp->p_next = (thread_t *)tqp;
    226c:	e580202c 	str	r2, [r0, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
    2270:	e5802030 	str	r2, [r0, #48]	; 0x30
    2274:	e5830014 	str	r0, [r3, #20]
  chSchWakeupS(tp, MSG_OK);
    2278:	ebffff30 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    227c:	e321f01f 	msr	CPSR_c, #31
}
    2280:	e1a00004 	mov	r0, r4
    2284:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    2288:	00000180 	.word	0x00000180
    228c:	40000c00 	.word	0x40000c00

00002290 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
    2290:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  currp->p_state = CH_STATE_CURRENT;
    2294:	e3a0e001 	mov	lr, #1
  otp = currp;
    2298:	e59f3028 	ldr	r3, [pc, #40]	; 22c8 <chSchGoSleepS+0x38>
    229c:	e5931018 	ldr	r1, [r3, #24]
  thread_t *tp = tqp->p_next;
    22a0:	e5932000 	ldr	r2, [r3]
  otp->p_state = newstate;
    22a4:	e5c1001c 	strb	r0, [r1, #28]
  tqp->p_next = tp->p_next;
    22a8:	e592c000 	ldr	ip, [r2]
  tqp->p_next->p_prev = (thread_t *)tqp;
    22ac:	e58c3004 	str	r3, [ip, #4]
  currp->p_state = CH_STATE_CURRENT;
    22b0:	e5c2e01c 	strb	lr, [r2, #28]
  chSysSwitch(currp, otp);
    22b4:	e1a00002 	mov	r0, r2
  tqp->p_next = tp->p_next;
    22b8:	e583c000 	str	ip, [r3]
}
    22bc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
    22c0:	e5832018 	str	r2, [r3, #24]
  chSysSwitch(currp, otp);
    22c4:	eafff791 	b	110 <_port_switch_arm>
    22c8:	40000c00 	.word	0x40000c00
    22cc:	00000000 	.word	0x00000000

000022d0 <chSemSignalWait.constprop.44>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
    22d0:	e92d4070 	push	{r4, r5, r6, lr}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    22d4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    22d8:	e59f4088 	ldr	r4, [pc, #136]	; 2368 <chSemSignalWait.constprop.44+0x98>
    22dc:	e5943008 	ldr	r3, [r4, #8]
    22e0:	e2833001 	add	r3, r3, #1
    22e4:	e3530000 	cmp	r3, #0
    22e8:	e5843008 	str	r3, [r4, #8]
    22ec:	da000014 	ble	2344 <chSemSignalWait.constprop.44+0x74>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    22f0:	e2433001 	sub	r3, r3, #1
    22f4:	e3530000 	cmp	r3, #0
    22f8:	e5843008 	str	r3, [r4, #8]
    22fc:	ba000003 	blt	2310 <chSemSignalWait.constprop.44+0x40>
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
    2300:	ebfffe36 	bl	1be0 <chSchRescheduleS>
    msg = MSG_OK;
    2304:	e3a00000 	mov	r0, #0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2308:	e321f01f 	msr	CPSR_c, #31
  }
  chSysUnlock();

  return msg;
}
    230c:	e8bd8070 	pop	{r4, r5, r6, pc}
    thread_t *ctp = currp;
    2310:	e59f2054 	ldr	r2, [pc, #84]	; 236c <chSemSignalWait.constprop.44+0x9c>
  tp->p_prev = tqp->p_prev;
    2314:	e5943004 	ldr	r3, [r4, #4]
    2318:	e5925018 	ldr	r5, [r2, #24]
    chSchGoSleepS(CH_STATE_WTSEM);
    231c:	e3a00005 	mov	r0, #5
  tp->p_next = (thread_t *)tqp;
    2320:	e5854000 	str	r4, [r5]
  tp->p_prev = tqp->p_prev;
    2324:	e5853004 	str	r3, [r5, #4]
  tp->p_prev->p_next = tp;
    2328:	e5835000 	str	r5, [r3]
    ctp->p_u.wtsemp = spw;
    232c:	e5854024 	str	r4, [r5, #36]	; 0x24
  tqp->p_prev = tp;
    2330:	e5845004 	str	r5, [r4, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
    2334:	ebffffd5 	bl	2290 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
    2338:	e5950024 	ldr	r0, [r5, #36]	; 0x24
    233c:	e321f01f 	msr	CPSR_c, #31
}
    2340:	e8bd8070 	pop	{r4, r5, r6, pc}
  thread_t *tp = tqp->p_next;
    2344:	e5940000 	ldr	r0, [r4]
  tqp->p_next = tp->p_next;
    2348:	e5903000 	ldr	r3, [r0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    234c:	e5834004 	str	r4, [r3, #4]
  tqp->p_next = tp->p_next;
    2350:	e5843000 	str	r3, [r4]
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
    2354:	ebfffb15 	bl	fb0 <chSchReadyI>
    2358:	e3a02000 	mov	r2, #0
    235c:	e5943008 	ldr	r3, [r4, #8]
    2360:	e5802024 	str	r2, [r0, #36]	; 0x24
    2364:	eaffffe1 	b	22f0 <chSemSignalWait.constprop.44+0x20>
    2368:	40000b04 	.word	0x40000b04
    236c:	40000c00 	.word	0x40000c00

00002370 <sem3_execute>:
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
    2370:	e3a01000 	mov	r1, #0
static void sem3_execute(void) {
    2374:	e92d4010 	push	{r4, lr}
    2378:	e59f30b4 	ldr	r3, [pc, #180]	; 2434 <sem3_execute+0xc4>
  return chThdGetSelfX()->p_prio;
    237c:	e5933018 	ldr	r3, [r3, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
    2380:	e5932008 	ldr	r2, [r3, #8]
static void sem3_execute(void) {
    2384:	e24dd008 	sub	sp, sp, #8
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
    2388:	e2822001 	add	r2, r2, #1
    238c:	e59f30a4 	ldr	r3, [pc, #164]	; 2438 <sem3_execute+0xc8>
    2390:	e58d1000 	str	r1, [sp]
    2394:	e59f00a0 	ldr	r0, [pc, #160]	; 243c <sem3_execute+0xcc>
    2398:	e3a01e13 	mov	r1, #304	; 0x130
    239c:	ebffff93 	bl	21f0 <chThdCreateStatic>
  return (bool)(tqp->p_next == (const thread_t *)tqp);
    23a0:	e59f4098 	ldr	r4, [pc, #152]	; 2440 <sem3_execute+0xd0>
    23a4:	e59f3098 	ldr	r3, [pc, #152]	; 2444 <sem3_execute+0xd4>
    23a8:	e5830000 	str	r0, [r3]
  chSemSignalWait(&sem1, &sem1);
    23ac:	ebffffc7 	bl	22d0 <chSemSignalWait.constprop.44>
    23b0:	e5941000 	ldr	r1, [r4]
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
    23b4:	e0412004 	sub	r2, r1, r4
    23b8:	e2721000 	rsbs	r1, r2, #0
    23bc:	e0a11002 	adc	r1, r1, r2
    23c0:	e3a00001 	mov	r0, #1
    23c4:	ebfff975 	bl	9a0 <_test_assert>
    23c8:	e3500000 	cmp	r0, #0
    23cc:	0a000001 	beq	23d8 <sem3_execute+0x68>
}
    23d0:	e28dd008 	add	sp, sp, #8
    23d4:	e8bd8010 	pop	{r4, pc}
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
    23d8:	e5941008 	ldr	r1, [r4, #8]
    23dc:	e2711001 	rsbs	r1, r1, #1
    23e0:	33a01000 	movcc	r1, #0
    23e4:	e3a00002 	mov	r0, #2
    23e8:	ebfff96c 	bl	9a0 <_test_assert>
    23ec:	e3500000 	cmp	r0, #0
    23f0:	1afffff6 	bne	23d0 <sem3_execute+0x60>
  chSemSignalWait(&sem1, &sem1);
    23f4:	ebffffb5 	bl	22d0 <chSemSignalWait.constprop.44>
    23f8:	e5941000 	ldr	r1, [r4]
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
    23fc:	e0413004 	sub	r3, r1, r4
    2400:	e2731000 	rsbs	r1, r3, #0
    2404:	e0a11003 	adc	r1, r1, r3
    2408:	e3a00003 	mov	r0, #3
    240c:	ebfff963 	bl	9a0 <_test_assert>
    2410:	e3500000 	cmp	r0, #0
    2414:	1affffed 	bne	23d0 <sem3_execute+0x60>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
    2418:	e5941008 	ldr	r1, [r4, #8]
    241c:	e2711001 	rsbs	r1, r1, #1
    2420:	e3a00004 	mov	r0, #4
    2424:	33a01000 	movcc	r1, #0
}
    2428:	e28dd008 	add	sp, sp, #8
    242c:	e8bd4010 	pop	{r4, lr}
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
    2430:	eafff95a 	b	9a0 <_test_assert>
    2434:	40000c00 	.word	0x40000c00
    2438:	00005050 	.word	0x00005050
    243c:	40000e00 	.word	0x40000e00
    2440:	40000b04 	.word	0x40000b04
    2444:	4000141c 	.word	0x4000141c
	...

00002450 <chEvtWaitOne.constprop.28>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
    2450:	e59f3040 	ldr	r3, [pc, #64]	; 2498 <chEvtWaitOne.constprop.28+0x48>
eventmask_t chEvtWaitOne(eventmask_t events) {
    2454:	e92d4010 	push	{r4, lr}
  thread_t *ctp = currp;
    2458:	e5934018 	ldr	r4, [r3, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    245c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
    2460:	e5943038 	ldr	r3, [r4, #56]	; 0x38
  if (m == (eventmask_t)0) {
    2464:	e3530000 	cmp	r3, #0
    2468:	1a000004 	bne	2480 <chEvtWaitOne.constprop.28+0x30>
    ctp->p_u.ewmask = events;
    246c:	e3e03000 	mvn	r3, #0
    chSchGoSleepS(CH_STATE_WTOREVT);
    2470:	e3a0000a 	mov	r0, #10
    ctp->p_u.ewmask = events;
    2474:	e5843024 	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
    2478:	ebffff84 	bl	2290 <chSchGoSleepS>
    m = ctp->p_epending & events;
    247c:	e5943038 	ldr	r3, [r4, #56]	; 0x38
  }
  m ^= m & (m - (eventmask_t)1);
    2480:	e2630000 	rsb	r0, r3, #0
    2484:	e0000003 	and	r0, r0, r3
  ctp->p_epending &= ~m;
    2488:	e1c33000 	bic	r3, r3, r0
    248c:	e5843038 	str	r3, [r4, #56]	; 0x38
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2490:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();

  return m;
}
    2494:	e8bd8010 	pop	{r4, pc}
    2498:	40000c00 	.word	0x40000c00
    249c:	00000000 	.word	0x00000000

000024a0 <chEvtWaitAny.constprop.27>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
    24a0:	e59f3038 	ldr	r3, [pc, #56]	; 24e0 <chEvtWaitAny.constprop.27+0x40>
eventmask_t chEvtWaitAny(eventmask_t events) {
    24a4:	e92d4010 	push	{r4, lr}
  thread_t *ctp = currp;
    24a8:	e5934018 	ldr	r4, [r3, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    24ac:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
    24b0:	e5940038 	ldr	r0, [r4, #56]	; 0x38
  if (m == (eventmask_t)0) {
    24b4:	e3500000 	cmp	r0, #0
    24b8:	1a000004 	bne	24d0 <chEvtWaitAny.constprop.27+0x30>
    ctp->p_u.ewmask = events;
    24bc:	e3e03000 	mvn	r3, #0
    chSchGoSleepS(CH_STATE_WTOREVT);
    24c0:	e3a0000a 	mov	r0, #10
    ctp->p_u.ewmask = events;
    24c4:	e5843024 	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
    24c8:	ebffff70 	bl	2290 <chSchGoSleepS>
    m = ctp->p_epending & events;
    24cc:	e5940038 	ldr	r0, [r4, #56]	; 0x38
  }
  ctp->p_epending &= ~m;
    24d0:	e3a03000 	mov	r3, #0
    24d4:	e5843038 	str	r3, [r4, #56]	; 0x38
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    24d8:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();

  return m;
}
    24dc:	e8bd8010 	pop	{r4, pc}
    24e0:	40000c00 	.word	0x40000c00
	...

000024f0 <thread4.lto_priv.68>:
  return ch.rlist.r_current;
    24f0:	e59f3024 	ldr	r3, [pc, #36]	; 251c <thread4.lto_priv.68+0x2c>
static THD_FUNCTION(thread4, p) {
    24f4:	e92d4010 	push	{r4, lr}
    24f8:	e5934018 	ldr	r4, [r3, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    24fc:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    chSchGoSleepS(CH_STATE_SUSPENDED);
    2500:	e3a00003 	mov	r0, #3
    2504:	ebffff61 	bl	2290 <chSchGoSleepS>
  } while (msg == MSG_OK);
    2508:	e5943024 	ldr	r3, [r4, #36]	; 0x24
    250c:	e3530000 	cmp	r3, #0
    2510:	0afffffa 	beq	2500 <thread4.lto_priv.68+0x10>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2514:	e321f01f 	msr	CPSR_c, #31
}
    2518:	e8bd8010 	pop	{r4, pc}
    251c:	40000c00 	.word	0x40000c00

00002520 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
    2520:	e92d4030 	push	{r4, r5, lr}
  if (TIME_INFINITE != time) {
    2524:	e3710001 	cmn	r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
    2528:	e24dd01c 	sub	sp, sp, #28
  if (TIME_INFINITE != time) {
    252c:	0a00000f 	beq	2570 <chSchGoSleepTimeoutS+0x50>
    2530:	e1a05000 	mov	r5, r0
    chVTDoSetI(&vt, time, wakeup, currp);
    2534:	e59f404c 	ldr	r4, [pc, #76]	; 2588 <chSchGoSleepTimeoutS+0x68>
    2538:	e28d0004 	add	r0, sp, #4
    253c:	e5943018 	ldr	r3, [r4, #24]
    2540:	e59f2044 	ldr	r2, [pc, #68]	; 258c <chSchGoSleepTimeoutS+0x6c>
    2544:	ebfffc59 	bl	16b0 <chVTDoSetI>
    chSchGoSleepS(newstate);
    2548:	e1a00005 	mov	r0, r5
    254c:	ebffff4f 	bl	2290 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
    2550:	e59d3010 	ldr	r3, [sp, #16]
    2554:	e3530000 	cmp	r3, #0
      chVTDoResetI(&vt);
    2558:	128d0004 	addne	r0, sp, #4
    255c:	1bfffc3f 	blne	1660 <chVTDoResetI>
  return currp->p_u.rdymsg;
    2560:	e5943018 	ldr	r3, [r4, #24]
}
    2564:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    2568:	e28dd01c 	add	sp, sp, #28
    256c:	e8bd8030 	pop	{r4, r5, pc}
    chSchGoSleepS(newstate);
    2570:	ebffff46 	bl	2290 <chSchGoSleepS>
    2574:	e59f400c 	ldr	r4, [pc, #12]	; 2588 <chSchGoSleepTimeoutS+0x68>
  return currp->p_u.rdymsg;
    2578:	e5943018 	ldr	r3, [r4, #24]
}
    257c:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    2580:	e28dd01c 	add	sp, sp, #28
    2584:	e8bd8030 	pop	{r4, r5, pc}
    2588:	40000c00 	.word	0x40000c00
    258c:	00000f00 	.word	0x00000f00

00002590 <chSemWaitTimeout.constprop.46>:
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2590:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (--sp->s_cnt < (cnt_t)0) {
    2594:	e59f3060 	ldr	r3, [pc, #96]	; 25fc <chSemWaitTimeout.constprop.46+0x6c>
    2598:	e5931008 	ldr	r1, [r3, #8]
    259c:	e2412001 	sub	r2, r1, #1
    25a0:	e3520000 	cmp	r2, #0
    25a4:	e5832008 	str	r2, [r3, #8]
  return MSG_OK;
    25a8:	a3a00000 	movge	r0, #0
  if (--sp->s_cnt < (cnt_t)0) {
    25ac:	ba000001 	blt	25b8 <chSemWaitTimeout.constprop.46+0x28>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    25b0:	e321f01f 	msr	CPSR_c, #31
}
    25b4:	e12fff1e 	bx	lr
    if (TIME_IMMEDIATE == time) {
    25b8:	e3500000 	cmp	r0, #0
      sp->s_cnt++;
    25bc:	05831008 	streq	r1, [r3, #8]
      return MSG_TIMEOUT;
    25c0:	03e00000 	mvneq	r0, #0
    if (TIME_IMMEDIATE == time) {
    25c4:	0afffff9 	beq	25b0 <chSemWaitTimeout.constprop.46+0x20>
    currp->p_u.wtsemp = sp;
    25c8:	e59f2030 	ldr	r2, [pc, #48]	; 2600 <chSemWaitTimeout.constprop.46+0x70>
  tp->p_prev = tqp->p_prev;
    25cc:	e593c004 	ldr	ip, [r3, #4]
    25d0:	e5922018 	ldr	r2, [r2, #24]
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
    25d4:	e92d4010 	push	{r4, lr}
    25d8:	e1a01000 	mov	r1, r0
    25dc:	e8821008 	stm	r2, {r3, ip}
    currp->p_u.wtsemp = sp;
    25e0:	e5823024 	str	r3, [r2, #36]	; 0x24
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
    25e4:	e3a00005 	mov	r0, #5
  tp->p_prev->p_next = tp;
    25e8:	e58c2000 	str	r2, [ip]
  tqp->p_prev = tp;
    25ec:	e5832004 	str	r2, [r3, #4]
    25f0:	ebffffca 	bl	2520 <chSchGoSleepTimeoutS>
    25f4:	e321f01f 	msr	CPSR_c, #31
}
    25f8:	e8bd8010 	pop	{r4, pc}
    25fc:	40000b04 	.word	0x40000b04
    2600:	40000c00 	.word	0x40000c00
	...

00002610 <evt3_execute>:
static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void evt3_execute(void) {
    2610:	e92d4070 	push	{r4, r5, r6, lr}
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
    2614:	e59f41e4 	ldr	r4, [pc, #484]	; 2800 <evt3_execute+0x1f0>
    2618:	e5942018 	ldr	r2, [r4, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    261c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
    2620:	e5923038 	ldr	r3, [r2, #56]	; 0x38
  if (m == (eventmask_t)0) {
    2624:	e3530000 	cmp	r3, #0
    2628:	1a00005d 	bne	27a4 <evt3_execute+0x194>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    262c:	e321f01f 	msr	CPSR_c, #31
    2630:	e3a01001 	mov	r1, #1

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(1, m == 0, "spurious event");
    2634:	e3a00001 	mov	r0, #1
    2638:	ebfff8d8 	bl	9a0 <_test_assert>
    263c:	e2501000 	subs	r1, r0, #0
    2640:	18bd8070 	popne	{r4, r5, r6, pc}
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
    2644:	e5943018 	ldr	r3, [r4, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2648:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
  if (m == (eventmask_t)0) {
    264c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
    2650:	e3520000 	cmp	r2, #0
    2654:	0a00005a 	beq	27c4 <evt3_execute+0x1b4>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
  }
  ctp->p_epending &= ~m;
    2658:	e5831038 	str	r1, [r3, #56]	; 0x38
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    265c:	e321f01f 	msr	CPSR_c, #31
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(2, m == 0, "spurious event");
    2660:	e3a00002 	mov	r0, #2
    2664:	ebfff8cd 	bl	9a0 <_test_assert>
    2668:	e2501000 	subs	r1, r0, #0
    266c:	18bd8070 	popne	{r4, r5, r6, pc}
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
    2670:	e5943018 	ldr	r3, [r4, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2674:	e321f09f 	msr	CPSR_c, #159	; 0x9f

  chSysLock();
  if ((ctp->p_epending & events) != events) {
    2678:	e5932038 	ldr	r2, [r3, #56]	; 0x38
    267c:	e3720001 	cmn	r2, #1
    2680:	0a000052 	beq	27d0 <evt3_execute+0x1c0>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2684:	e321f01f 	msr	CPSR_c, #31
    2688:	e3a01001 	mov	r1, #1
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(3, m == 0, "spurious event");
    268c:	e3a00003 	mov	r0, #3
    2690:	ebfff8c2 	bl	9a0 <_test_assert>
    2694:	e3500000 	cmp	r0, #0
    2698:	18bd8070 	popne	{r4, r5, r6, pc}
  thread_t *ctp = currp;
    269c:	e5945018 	ldr	r5, [r4, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    26a0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  m = ctp->p_epending & events;
    26a4:	e5953038 	ldr	r3, [r5, #56]	; 0x38
  if (m == (eventmask_t)0) {
    26a8:	e3530000 	cmp	r3, #0
    26ac:	1a000007 	bne	26d0 <evt3_execute+0xc0>
    ctp->p_u.ewmask = events;
    26b0:	e3e03000 	mvn	r3, #0
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
    26b4:	e3a0100a 	mov	r1, #10
    ctp->p_u.ewmask = events;
    26b8:	e5853024 	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
    26bc:	e1a00001 	mov	r0, r1
    26c0:	ebffff96 	bl	2520 <chSchGoSleepTimeoutS>
    26c4:	e3500000 	cmp	r0, #0
    m = ctp->p_epending & events;
    26c8:	a5953038 	ldrge	r3, [r5, #56]	; 0x38
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
    26cc:	ba000042 	blt	27dc <evt3_execute+0x1cc>
  m ^= m & (m - (eventmask_t)1);
    26d0:	e2631000 	rsb	r1, r3, #0
    26d4:	e0011003 	and	r1, r1, r3
  ctp->p_epending &= ~m;
    26d8:	e1c33001 	bic	r3, r3, r1
    26dc:	e5853038 	str	r3, [r5, #56]	; 0x38
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    26e0:	e321f01f 	msr	CPSR_c, #31
    26e4:	e2711001 	rsbs	r1, r1, #1
    26e8:	33a01000 	movcc	r1, #0
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
  test_assert(4, m == 0, "spurious event");
    26ec:	e3a00004 	mov	r0, #4
    26f0:	ebfff8aa 	bl	9a0 <_test_assert>
    26f4:	e3500000 	cmp	r0, #0
    26f8:	18bd8070 	popne	{r4, r5, r6, pc}
  thread_t *ctp = currp;
    26fc:	e5945018 	ldr	r5, [r4, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2700:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  m = ctp->p_epending & events;
    2704:	e5953038 	ldr	r3, [r5, #56]	; 0x38
  if (m == (eventmask_t)0) {
    2708:	e3530000 	cmp	r3, #0
    270c:	1a000007 	bne	2730 <evt3_execute+0x120>
    ctp->p_u.ewmask = events;
    2710:	e3e03000 	mvn	r3, #0
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
    2714:	e3a0100a 	mov	r1, #10
    ctp->p_u.ewmask = events;
    2718:	e5853024 	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
    271c:	e1a00001 	mov	r0, r1
    2720:	ebffff7e 	bl	2520 <chSchGoSleepTimeoutS>
    2724:	e3500000 	cmp	r0, #0
    m = ctp->p_epending & events;
    2728:	a5953038 	ldrge	r3, [r5, #56]	; 0x38
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
    272c:	ba00002d 	blt	27e8 <evt3_execute+0x1d8>
  ctp->p_epending &= ~m;
    2730:	e3a02000 	mov	r2, #0
    2734:	e5852038 	str	r2, [r5, #56]	; 0x38
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2738:	e321f01f 	msr	CPSR_c, #31
    273c:	e0433002 	sub	r3, r3, r2
    2740:	e2731000 	rsbs	r1, r3, #0
    2744:	e0a11003 	adc	r1, r1, r3
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
    2748:	e3a00005 	mov	r0, #5
    274c:	ebfff893 	bl	9a0 <_test_assert>
    2750:	e2505000 	subs	r5, r0, #0
    2754:	18bd8070 	popne	{r4, r5, r6, pc}
  thread_t *ctp = currp;
    2758:	e5944018 	ldr	r4, [r4, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    275c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if ((ctp->p_epending & events) != events) {
    2760:	e5943038 	ldr	r3, [r4, #56]	; 0x38
    2764:	e3730001 	cmn	r3, #1
    2768:	0a000006 	beq	2788 <evt3_execute+0x178>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
    276c:	e3e03000 	mvn	r3, #0
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
    2770:	e3a0100a 	mov	r1, #10
    ctp->p_u.ewmask = events;
    2774:	e5843024 	str	r3, [r4, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
    2778:	e3a0000b 	mov	r0, #11
    277c:	ebffff67 	bl	2520 <chSchGoSleepTimeoutS>
    2780:	e3500000 	cmp	r0, #0
    2784:	ba00001a 	blt	27f4 <evt3_execute+0x1e4>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~events;
    2788:	e3a03000 	mov	r3, #0
    278c:	e5843038 	str	r3, [r4, #56]	; 0x38
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2790:	e321f01f 	msr	CPSR_c, #31
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
    2794:	e1a01005 	mov	r1, r5
    2798:	e3a00006 	mov	r0, #6
}
    279c:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_assert(6, m == 0, "spurious event");
    27a0:	eafff87e 	b	9a0 <_test_assert>
  m ^= m & (m - (eventmask_t)1);
    27a4:	e2631000 	rsb	r1, r3, #0
    27a8:	e0011003 	and	r1, r1, r3
  ctp->p_epending &= ~m;
    27ac:	e1c33001 	bic	r3, r3, r1
    27b0:	e5823038 	str	r3, [r2, #56]	; 0x38
    27b4:	e321f01f 	msr	CPSR_c, #31
    27b8:	e2711001 	rsbs	r1, r1, #1
    27bc:	33a01000 	movcc	r1, #0
    27c0:	eaffff9b 	b	2634 <evt3_execute+0x24>
    27c4:	e321f01f 	msr	CPSR_c, #31
    27c8:	e3a01001 	mov	r1, #1
    27cc:	eaffffa3 	b	2660 <evt3_execute+0x50>
  ctp->p_epending &= ~events;
    27d0:	e5831038 	str	r1, [r3, #56]	; 0x38
    27d4:	e321f01f 	msr	CPSR_c, #31
    27d8:	eaffffab 	b	268c <evt3_execute+0x7c>
    27dc:	e321f01f 	msr	CPSR_c, #31
    27e0:	e3a01001 	mov	r1, #1
    27e4:	eaffffc0 	b	26ec <evt3_execute+0xdc>
    27e8:	e321f01f 	msr	CPSR_c, #31
    27ec:	e3a01001 	mov	r1, #1
    27f0:	eaffffd4 	b	2748 <evt3_execute+0x138>
    27f4:	e321f01f 	msr	CPSR_c, #31
    27f8:	e3a05001 	mov	r5, #1
    27fc:	eaffffe4 	b	2794 <evt3_execute+0x184>
    2800:	40000c00 	.word	0x40000c00
	...

00002810 <chSemWaitTimeoutS>:
  if (--sp->s_cnt < (cnt_t)0) {
    2810:	e5903008 	ldr	r3, [r0, #8]
    2814:	e2433001 	sub	r3, r3, #1
    2818:	e3530000 	cmp	r3, #0
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
    281c:	e1a02000 	mov	r2, r0
  if (--sp->s_cnt < (cnt_t)0) {
    2820:	e5803008 	str	r3, [r0, #8]
    2824:	ba000001 	blt	2830 <chSemWaitTimeoutS+0x20>
}
    2828:	e3a00000 	mov	r0, #0
    282c:	e12fff1e 	bx	lr
    currp->p_u.wtsemp = sp;
    2830:	e59f3020 	ldr	r3, [pc, #32]	; 2858 <chSemWaitTimeoutS+0x48>
    2834:	e5933018 	ldr	r3, [r3, #24]
    2838:	e5830024 	str	r0, [r3, #36]	; 0x24
  tp->p_next = (thread_t *)tqp;
    283c:	e5830000 	str	r0, [r3]
  tp->p_prev = tqp->p_prev;
    2840:	e590c004 	ldr	ip, [r0, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
    2844:	e3a00005 	mov	r0, #5
    2848:	e583c004 	str	ip, [r3, #4]
  tp->p_prev->p_next = tp;
    284c:	e58c3000 	str	r3, [ip]
  tqp->p_prev = tp;
    2850:	e5823004 	str	r3, [r2, #4]
    2854:	eaffff31 	b	2520 <chSchGoSleepTimeoutS>
    2858:	40000c00 	.word	0x40000c00
    285c:	00000000 	.word	0x00000000

00002860 <chMBPost.constprop.16>:
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    2860:	e92d4070 	push	{r4, r5, r6, lr}
    2864:	e1a06000 	mov	r6, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2868:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
    286c:	e59f4040 	ldr	r4, [pc, #64]	; 28b4 <chMBPost.constprop.16+0x54>
    2870:	e284001c 	add	r0, r4, #28
    2874:	ebffffe5 	bl	2810 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
    2878:	e2505000 	subs	r5, r0, #0
    287c:	1a000009 	bne	28a8 <chMBPost.constprop.16+0x48>
    if (mbp->mb_wrptr >= mbp->mb_top) {
    2880:	e994000a 	ldmib	r4, {r1, r3}
    *mbp->mb_wrptr++ = msg;
    2884:	e2832004 	add	r2, r3, #4
    if (mbp->mb_wrptr >= mbp->mb_top) {
    2888:	e1520001 	cmp	r2, r1
    *mbp->mb_wrptr++ = msg;
    288c:	e5842008 	str	r2, [r4, #8]
    2890:	e5836000 	str	r6, [r3]
      mbp->mb_wrptr = mbp->mb_buffer;
    2894:	25943000 	ldrcs	r3, [r4]
    chSemSignalI(&mbp->mb_fullsem);
    2898:	e59f0018 	ldr	r0, [pc, #24]	; 28b8 <chMBPost.constprop.16+0x58>
      mbp->mb_wrptr = mbp->mb_buffer;
    289c:	25843008 	strcs	r3, [r4, #8]
    chSemSignalI(&mbp->mb_fullsem);
    28a0:	ebfffb02 	bl	14b0 <chSemSignalI>
    chSchRescheduleS();
    28a4:	ebfffccd 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    28a8:	e321f01f 	msr	CPSR_c, #31
}
    28ac:	e1a00005 	mov	r0, r5
    28b0:	e8bd8070 	pop	{r4, r5, r6, pc}
    28b4:	40000aac 	.word	0x40000aac
    28b8:	40000abc 	.word	0x40000abc
    28bc:	00000000 	.word	0x00000000

000028c0 <chMBPostAhead.constprop.14>:
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
    28c0:	e92d4070 	push	{r4, r5, r6, lr}
    28c4:	e1a06000 	mov	r6, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    28c8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
    28cc:	e59f4048 	ldr	r4, [pc, #72]	; 291c <chMBPostAhead.constprop.14+0x5c>
    28d0:	e284001c 	add	r0, r4, #28
    28d4:	ebffffcd 	bl	2810 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
    28d8:	e2505000 	subs	r5, r0, #0
    28dc:	1a00000b 	bne	2910 <chMBPostAhead.constprop.14+0x50>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
    28e0:	e594300c 	ldr	r3, [r4, #12]
    28e4:	e5942000 	ldr	r2, [r4]
    28e8:	e2433004 	sub	r3, r3, #4
    28ec:	e1530002 	cmp	r3, r2
    28f0:	e584300c 	str	r3, [r4, #12]
      mbp->mb_rdptr = mbp->mb_top - 1;
    28f4:	35943004 	ldrcc	r3, [r4, #4]
    28f8:	32433004 	subcc	r3, r3, #4
    28fc:	3584300c 	strcc	r3, [r4, #12]
    chSemSignalI(&mbp->mb_fullsem);
    2900:	e59f0018 	ldr	r0, [pc, #24]	; 2920 <chMBPostAhead.constprop.14+0x60>
    *mbp->mb_rdptr = msg;
    2904:	e5836000 	str	r6, [r3]
    chSemSignalI(&mbp->mb_fullsem);
    2908:	ebfffae8 	bl	14b0 <chSemSignalI>
    chSchRescheduleS();
    290c:	ebfffcb3 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2910:	e321f01f 	msr	CPSR_c, #31
}
    2914:	e1a00005 	mov	r0, r5
    2918:	e8bd8070 	pop	{r4, r5, r6, pc}
    291c:	40000aac 	.word	0x40000aac
    2920:	40000abc 	.word	0x40000abc
	...

00002930 <chMBFetch.constprop.12>:
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
    2930:	e92d4070 	push	{r4, r5, r6, lr}
    2934:	e1a06000 	mov	r6, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2938:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
    293c:	e59f4048 	ldr	r4, [pc, #72]	; 298c <chMBFetch.constprop.12+0x5c>
    2940:	e2840010 	add	r0, r4, #16
    2944:	ebffffb1 	bl	2810 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
    2948:	e2505000 	subs	r5, r0, #0
    294c:	1a00000b 	bne	2980 <chMBFetch.constprop.12+0x50>
    *msgp = *mbp->mb_rdptr++;
    2950:	e594200c 	ldr	r2, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
    2954:	e5941004 	ldr	r1, [r4, #4]
    *msgp = *mbp->mb_rdptr++;
    2958:	e2823004 	add	r3, r2, #4
    if (mbp->mb_rdptr >= mbp->mb_top) {
    295c:	e1530001 	cmp	r3, r1
    *msgp = *mbp->mb_rdptr++;
    2960:	e5922000 	ldr	r2, [r2]
    2964:	e584300c 	str	r3, [r4, #12]
      mbp->mb_rdptr = mbp->mb_buffer;
    2968:	25943000 	ldrcs	r3, [r4]
    *msgp = *mbp->mb_rdptr++;
    296c:	e5862000 	str	r2, [r6]
    chSemSignalI(&mbp->mb_emptysem);
    2970:	e59f0018 	ldr	r0, [pc, #24]	; 2990 <chMBFetch.constprop.12+0x60>
      mbp->mb_rdptr = mbp->mb_buffer;
    2974:	2584300c 	strcs	r3, [r4, #12]
    chSemSignalI(&mbp->mb_emptysem);
    2978:	ebfffacc 	bl	14b0 <chSemSignalI>
    chSchRescheduleS();
    297c:	ebfffc97 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2980:	e321f01f 	msr	CPSR_c, #31
}
    2984:	e1a00005 	mov	r0, r5
    2988:	e8bd8070 	pop	{r4, r5, r6, pc}
    298c:	40000aac 	.word	0x40000aac
    2990:	40000ac8 	.word	0x40000ac8
	...

000029a0 <mbox1_execute>:

static void mbox1_execute(void) {
    29a0:	e92d4030 	push	{r4, r5, lr}
    29a4:	e24dd00c 	sub	sp, sp, #12
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    29a8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
    29ac:	e59f5760 	ldr	r5, [pc, #1888]	; 3114 <mbox1_execute+0x774>
    29b0:	e5951024 	ldr	r1, [r5, #36]	; 0x24
    29b4:	e2412005 	sub	r2, r1, #5
    29b8:	e2721000 	rsbs	r1, r2, #0
    29bc:	e0a11002 	adc	r1, r1, r2
    29c0:	e3a00001 	mov	r0, #1
    29c4:	ebfff7f5 	bl	9a0 <_test_assert>
    29c8:	e3500000 	cmp	r0, #0
    29cc:	1a000173 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    29d0:	e321f01f 	msr	CPSR_c, #31
    29d4:	e3a04042 	mov	r4, #66	; 0x42

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    29d8:	e3e01000 	mvn	r1, #0
    29dc:	e1a00004 	mov	r0, r4
    29e0:	ebffff9e 	bl	2860 <chMBPost.constprop.16>
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
    29e4:	e2701001 	rsbs	r1, r0, #1
    29e8:	33a01000 	movcc	r1, #0
    29ec:	e3a00002 	mov	r0, #2
    29f0:	ebfff7ea 	bl	9a0 <_test_assert>
    29f4:	e3500000 	cmp	r0, #0
    29f8:	e2844001 	add	r4, r4, #1
    29fc:	1a00000a 	bne	2a2c <mbox1_execute+0x8c>
  for (i = 0; i < MB_SIZE - 1; i++) {
    2a00:	e3540046 	cmp	r4, #70	; 0x46
    2a04:	1afffff3 	bne	29d8 <mbox1_execute+0x38>
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
    2a08:	e3e01000 	mvn	r1, #0
    2a0c:	e3a00041 	mov	r0, #65	; 0x41
    2a10:	ebffffaa 	bl	28c0 <chMBPostAhead.constprop.14>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
    2a14:	e2701001 	rsbs	r1, r0, #1
    2a18:	33a01000 	movcc	r1, #0
    2a1c:	e3a00003 	mov	r0, #3
    2a20:	ebfff7de 	bl	9a0 <_test_assert>
    2a24:	e3500000 	cmp	r0, #0
    2a28:	0a00015f 	beq	2fac <mbox1_execute+0x60c>
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
    2a2c:	e28dd00c 	add	sp, sp, #12
    2a30:	e8bd8030 	pop	{r4, r5, pc}
  test_assert_sequence(12, "ABCDE");
    2a34:	e59f16dc 	ldr	r1, [pc, #1756]	; 3118 <mbox1_execute+0x778>
    2a38:	e3a0000c 	mov	r0, #12
    2a3c:	ebfff7b7 	bl	920 <_test_assert_sequence>
    2a40:	e3500000 	cmp	r0, #0
    2a44:	1afffff8 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    2a48:	e3e01000 	mvn	r1, #0
    2a4c:	e3a00047 	mov	r0, #71	; 0x47
    2a50:	ebffff82 	bl	2860 <chMBPost.constprop.16>
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
    2a54:	e2701001 	rsbs	r1, r0, #1
    2a58:	33a01000 	movcc	r1, #0
    2a5c:	e3a0000d 	mov	r0, #13
    2a60:	ebfff7ce 	bl	9a0 <_test_assert>
    2a64:	e3500000 	cmp	r0, #0
    2a68:	1affffef 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    2a6c:	e3e01000 	mvn	r1, #0
    2a70:	e28d0004 	add	r0, sp, #4
    2a74:	ebffffad 	bl	2930 <chMBFetch.constprop.12>
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
    2a78:	e2701001 	rsbs	r1, r0, #1
    2a7c:	33a01000 	movcc	r1, #0
    2a80:	e3a0000e 	mov	r0, #14
    2a84:	ebfff7c5 	bl	9a0 <_test_assert>
    2a88:	e3500000 	cmp	r0, #0
    2a8c:	1affffe6 	bne	2a2c <mbox1_execute+0x8c>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
    2a90:	e5951000 	ldr	r1, [r5]
    2a94:	e5953008 	ldr	r3, [r5, #8]
    2a98:	e041e003 	sub	lr, r1, r3
    2a9c:	e27e1000 	rsbs	r1, lr, #0
    2aa0:	e0a1100e 	adc	r1, r1, lr
    2aa4:	e3a0000f 	mov	r0, #15
    2aa8:	ebfff7bc 	bl	9a0 <_test_assert>
    2aac:	e3500000 	cmp	r0, #0
    2ab0:	1affffdd 	bne	2a2c <mbox1_execute+0x8c>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
    2ab4:	e5951000 	ldr	r1, [r5]
    2ab8:	e595300c 	ldr	r3, [r5, #12]
    2abc:	e041c003 	sub	ip, r1, r3
    2ac0:	e27c1000 	rsbs	r1, ip, #0
    2ac4:	e0a1100c 	adc	r1, r1, ip
    2ac8:	e3a00010 	mov	r0, #16
    2acc:	ebfff7b3 	bl	9a0 <_test_assert>
    2ad0:	e3500000 	cmp	r0, #0
    2ad4:	1affffd4 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBFetch(&mb1, &msg2, 1);
    2ad8:	e3a01001 	mov	r1, #1
    2adc:	e28d0004 	add	r0, sp, #4
    2ae0:	ebffff92 	bl	2930 <chMBFetch.constprop.12>
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
    2ae4:	e3700001 	cmn	r0, #1
    2ae8:	13a01000 	movne	r1, #0
    2aec:	03a01001 	moveq	r1, #1
    2af0:	e3a00011 	mov	r0, #17
    2af4:	ebfff7a9 	bl	9a0 <_test_assert>
    2af8:	e3500000 	cmp	r0, #0
    2afc:	1affffca 	bne	2a2c <mbox1_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2b00:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  msg1 = chMBFetchI(&mb1, &msg2);
    2b04:	e28d0004 	add	r0, sp, #4
    2b08:	ebfffaa8 	bl	15b0 <chMBFetchI.constprop.11>
    2b0c:	e1a01000 	mov	r1, r0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2b10:	e321f01f 	msr	CPSR_c, #31
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
    2b14:	e3710001 	cmn	r1, #1
    2b18:	13a01000 	movne	r1, #0
    2b1c:	03a01001 	moveq	r1, #1
    2b20:	e3a00012 	mov	r0, #18
    2b24:	ebfff79d 	bl	9a0 <_test_assert>
    2b28:	e3500000 	cmp	r0, #0
    2b2c:	1affffbe 	bne	2a2c <mbox1_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2b30:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    2b34:	e5951024 	ldr	r1, [r5, #36]	; 0x24
    2b38:	e2412005 	sub	r2, r1, #5
    2b3c:	e2721000 	rsbs	r1, r2, #0
    2b40:	e0a11002 	adc	r1, r1, r2
    2b44:	e3a00013 	mov	r0, #19
    2b48:	ebfff794 	bl	9a0 <_test_assert>
    2b4c:	e3500000 	cmp	r0, #0
    2b50:	1a000112 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2b54:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2b58:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
    2b5c:	e5951018 	ldr	r1, [r5, #24]
    2b60:	e2711001 	rsbs	r1, r1, #1
    2b64:	33a01000 	movcc	r1, #0
    2b68:	e3a00014 	mov	r0, #20
    2b6c:	ebfff78b 	bl	9a0 <_test_assert>
    2b70:	e3500000 	cmp	r0, #0
    2b74:	1a000109 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2b78:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2b7c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    2b80:	e595100c 	ldr	r1, [r5, #12]
    2b84:	e5953008 	ldr	r3, [r5, #8]
    2b88:	e0413003 	sub	r3, r1, r3
    2b8c:	e2731000 	rsbs	r1, r3, #0
    2b90:	e0a11003 	adc	r1, r1, r3
    2b94:	e3a00015 	mov	r0, #21
    2b98:	ebfff780 	bl	9a0 <_test_assert>
    2b9c:	e3500000 	cmp	r0, #0
    2ba0:	1a0000fe 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2ba4:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2ba8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  msg1 = chMBPostI(&mb1, 'A');
    2bac:	e3a00041 	mov	r0, #65	; 0x41
    2bb0:	ebfffa4e 	bl	14f0 <chMBPostI.constprop.15>
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
    2bb4:	e2701001 	rsbs	r1, r0, #1
    2bb8:	33a01000 	movcc	r1, #0
    2bbc:	e3a00016 	mov	r0, #22
    2bc0:	ebfff776 	bl	9a0 <_test_assert>
    2bc4:	e3500000 	cmp	r0, #0
    2bc8:	1affff97 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPostI(&mb1, 'B');
    2bcc:	e3a00042 	mov	r0, #66	; 0x42
    2bd0:	ebfffa46 	bl	14f0 <chMBPostI.constprop.15>
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
    2bd4:	e2701001 	rsbs	r1, r0, #1
    2bd8:	33a01000 	movcc	r1, #0
    2bdc:	e3a00017 	mov	r0, #23
    2be0:	ebfff76e 	bl	9a0 <_test_assert>
    2be4:	e3500000 	cmp	r0, #0
    2be8:	1affff8f 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPostI(&mb1, 'C');
    2bec:	e3a00043 	mov	r0, #67	; 0x43
    2bf0:	ebfffa3e 	bl	14f0 <chMBPostI.constprop.15>
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
    2bf4:	e2701001 	rsbs	r1, r0, #1
    2bf8:	33a01000 	movcc	r1, #0
    2bfc:	e3a00018 	mov	r0, #24
    2c00:	ebfff766 	bl	9a0 <_test_assert>
    2c04:	e3500000 	cmp	r0, #0
    2c08:	1affff87 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPostI(&mb1, 'D');
    2c0c:	e3a00044 	mov	r0, #68	; 0x44
    2c10:	ebfffa36 	bl	14f0 <chMBPostI.constprop.15>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
    2c14:	e2701001 	rsbs	r1, r0, #1
    2c18:	33a01000 	movcc	r1, #0
    2c1c:	e3a00019 	mov	r0, #25
    2c20:	ebfff75e 	bl	9a0 <_test_assert>
    2c24:	e3500000 	cmp	r0, #0
    2c28:	1affff7f 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPostI(&mb1, 'E');
    2c2c:	e3a00045 	mov	r0, #69	; 0x45
    2c30:	ebfffa2e 	bl	14f0 <chMBPostI.constprop.15>
    2c34:	e1a01000 	mov	r1, r0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2c38:	e321f01f 	msr	CPSR_c, #31
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
    2c3c:	e2711001 	rsbs	r1, r1, #1
    2c40:	33a01000 	movcc	r1, #0
    2c44:	e3a0001a 	mov	r0, #26
    2c48:	ebfff754 	bl	9a0 <_test_assert>
    2c4c:	e3500000 	cmp	r0, #0
    2c50:	1affff75 	bne	2a2c <mbox1_execute+0x8c>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    2c54:	e595100c 	ldr	r1, [r5, #12]
    2c58:	e5953008 	ldr	r3, [r5, #8]
    2c5c:	e0414003 	sub	r4, r1, r3
    2c60:	e2741000 	rsbs	r1, r4, #0
    2c64:	e0a11004 	adc	r1, r1, r4
    2c68:	e3a0001b 	mov	r0, #27
    2c6c:	ebfff74b 	bl	9a0 <_test_assert>
    2c70:	e3500000 	cmp	r0, #0
    2c74:	1affff6c 	bne	2a2c <mbox1_execute+0x8c>
    2c78:	e3a04005 	mov	r4, #5
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2c7c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    msg1 = chMBFetchI(&mb1, &msg2);
    2c80:	e28d0004 	add	r0, sp, #4
    2c84:	ebfffa49 	bl	15b0 <chMBFetchI.constprop.11>
    2c88:	e1a01000 	mov	r1, r0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2c8c:	e321f01f 	msr	CPSR_c, #31
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    2c90:	e2711001 	rsbs	r1, r1, #1
    2c94:	33a01000 	movcc	r1, #0
    2c98:	e3a0001c 	mov	r0, #28
    2c9c:	ebfff73f 	bl	9a0 <_test_assert>
    2ca0:	e3500000 	cmp	r0, #0
    2ca4:	1affff60 	bne	2a2c <mbox1_execute+0x8c>
    test_emit_token(msg2);
    2ca8:	e5dd0004 	ldrb	r0, [sp, #4]
    2cac:	ebfff74b 	bl	9e0 <test_emit_token>
  for (i = 0; i < MB_SIZE; i++) {
    2cb0:	e2544001 	subs	r4, r4, #1
    2cb4:	1afffff0 	bne	2c7c <mbox1_execute+0x2dc>
  test_assert_sequence(29, "ABCDE");
    2cb8:	e59f1458 	ldr	r1, [pc, #1112]	; 3118 <mbox1_execute+0x778>
    2cbc:	e3a0001d 	mov	r0, #29
    2cc0:	ebfff716 	bl	920 <_test_assert_sequence>
    2cc4:	e3500000 	cmp	r0, #0
    2cc8:	1affff57 	bne	2a2c <mbox1_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2ccc:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    2cd0:	e5951024 	ldr	r1, [r5, #36]	; 0x24
    2cd4:	e241e005 	sub	lr, r1, #5
    2cd8:	e27e1000 	rsbs	r1, lr, #0
    2cdc:	e0a1100e 	adc	r1, r1, lr
    2ce0:	e3a0001e 	mov	r0, #30
    2ce4:	ebfff72d 	bl	9a0 <_test_assert>
    2ce8:	e3500000 	cmp	r0, #0
    2cec:	1a0000ab 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2cf0:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2cf4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
    2cf8:	e5951018 	ldr	r1, [r5, #24]
    2cfc:	e2711001 	rsbs	r1, r1, #1
    2d00:	33a01000 	movcc	r1, #0
    2d04:	e3a0001f 	mov	r0, #31
    2d08:	ebfff724 	bl	9a0 <_test_assert>
    2d0c:	e3500000 	cmp	r0, #0
    2d10:	1a0000a2 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2d14:	e321f01f 	msr	CPSR_c, #31
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    2d18:	e595100c 	ldr	r1, [r5, #12]
    2d1c:	e5953008 	ldr	r3, [r5, #8]
    2d20:	e041c003 	sub	ip, r1, r3
    2d24:	e27c1000 	rsbs	r1, ip, #0
    2d28:	e0a1100c 	adc	r1, r1, ip
    2d2c:	e3a00020 	mov	r0, #32
    2d30:	ebfff71a 	bl	9a0 <_test_assert>
    2d34:	e3500000 	cmp	r0, #0
    2d38:	1affff3b 	bne	2a2c <mbox1_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2d3c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  msg1 = chMBPostAheadI(&mb1, 'E');
    2d40:	e3a00045 	mov	r0, #69	; 0x45
    2d44:	ebfffa01 	bl	1550 <chMBPostAheadI.constprop.13>
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
    2d48:	e2701001 	rsbs	r1, r0, #1
    2d4c:	33a01000 	movcc	r1, #0
    2d50:	e3a00021 	mov	r0, #33	; 0x21
    2d54:	ebfff711 	bl	9a0 <_test_assert>
    2d58:	e3500000 	cmp	r0, #0
    2d5c:	1affff32 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPostAheadI(&mb1, 'D');
    2d60:	e3a00044 	mov	r0, #68	; 0x44
    2d64:	ebfff9f9 	bl	1550 <chMBPostAheadI.constprop.13>
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
    2d68:	e2701001 	rsbs	r1, r0, #1
    2d6c:	33a01000 	movcc	r1, #0
    2d70:	e3a00022 	mov	r0, #34	; 0x22
    2d74:	ebfff709 	bl	9a0 <_test_assert>
    2d78:	e3500000 	cmp	r0, #0
    2d7c:	1affff2a 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPostAheadI(&mb1, 'C');
    2d80:	e3a00043 	mov	r0, #67	; 0x43
    2d84:	ebfff9f1 	bl	1550 <chMBPostAheadI.constprop.13>
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
    2d88:	e2701001 	rsbs	r1, r0, #1
    2d8c:	33a01000 	movcc	r1, #0
    2d90:	e3a00023 	mov	r0, #35	; 0x23
    2d94:	ebfff701 	bl	9a0 <_test_assert>
    2d98:	e3500000 	cmp	r0, #0
    2d9c:	1affff22 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPostAheadI(&mb1, 'B');
    2da0:	e3a00042 	mov	r0, #66	; 0x42
    2da4:	ebfff9e9 	bl	1550 <chMBPostAheadI.constprop.13>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
    2da8:	e2701001 	rsbs	r1, r0, #1
    2dac:	33a01000 	movcc	r1, #0
    2db0:	e3a00024 	mov	r0, #36	; 0x24
    2db4:	ebfff6f9 	bl	9a0 <_test_assert>
    2db8:	e3500000 	cmp	r0, #0
    2dbc:	1affff1a 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPostAheadI(&mb1, 'A');
    2dc0:	e3a00041 	mov	r0, #65	; 0x41
    2dc4:	ebfff9e1 	bl	1550 <chMBPostAheadI.constprop.13>
    2dc8:	e1a01000 	mov	r1, r0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2dcc:	e321f01f 	msr	CPSR_c, #31
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
    2dd0:	e2711001 	rsbs	r1, r1, #1
    2dd4:	33a01000 	movcc	r1, #0
    2dd8:	e3a00025 	mov	r0, #37	; 0x25
    2ddc:	ebfff6ef 	bl	9a0 <_test_assert>
    2de0:	e3500000 	cmp	r0, #0
    2de4:	1affff10 	bne	2a2c <mbox1_execute+0x8c>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    2de8:	e595100c 	ldr	r1, [r5, #12]
    2dec:	e5953008 	ldr	r3, [r5, #8]
    2df0:	e0412003 	sub	r2, r1, r3
    2df4:	e2721000 	rsbs	r1, r2, #0
    2df8:	e0a11002 	adc	r1, r1, r2
    2dfc:	e3a00026 	mov	r0, #38	; 0x26
    2e00:	ebfff6e6 	bl	9a0 <_test_assert>
    2e04:	e3500000 	cmp	r0, #0
    2e08:	1affff07 	bne	2a2c <mbox1_execute+0x8c>
    2e0c:	e3a04005 	mov	r4, #5
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2e10:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    msg1 = chMBFetchI(&mb1, &msg2);
    2e14:	e28d0004 	add	r0, sp, #4
    2e18:	ebfff9e4 	bl	15b0 <chMBFetchI.constprop.11>
    2e1c:	e1a01000 	mov	r1, r0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2e20:	e321f01f 	msr	CPSR_c, #31
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    2e24:	e2711001 	rsbs	r1, r1, #1
    2e28:	33a01000 	movcc	r1, #0
    2e2c:	e3a00027 	mov	r0, #39	; 0x27
    2e30:	ebfff6da 	bl	9a0 <_test_assert>
    2e34:	e3500000 	cmp	r0, #0
    2e38:	1afffefb 	bne	2a2c <mbox1_execute+0x8c>
    test_emit_token(msg2);
    2e3c:	e5dd0004 	ldrb	r0, [sp, #4]
    2e40:	ebfff6e6 	bl	9e0 <test_emit_token>
  for (i = 0; i < MB_SIZE; i++) {
    2e44:	e2544001 	subs	r4, r4, #1
    2e48:	1afffff0 	bne	2e10 <mbox1_execute+0x470>
  test_assert_sequence(40, "ABCDE");
    2e4c:	e59f12c4 	ldr	r1, [pc, #708]	; 3118 <mbox1_execute+0x778>
    2e50:	e3a00028 	mov	r0, #40	; 0x28
    2e54:	ebfff6b1 	bl	920 <_test_assert_sequence>
    2e58:	e3500000 	cmp	r0, #0
    2e5c:	1afffef2 	bne	2a2c <mbox1_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2e60:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    2e64:	e5951024 	ldr	r1, [r5, #36]	; 0x24
    2e68:	e2413005 	sub	r3, r1, #5
    2e6c:	e2731000 	rsbs	r1, r3, #0
    2e70:	e0a11003 	adc	r1, r1, r3
    2e74:	e3a00029 	mov	r0, #41	; 0x29
    2e78:	ebfff6c8 	bl	9a0 <_test_assert>
    2e7c:	e3500000 	cmp	r0, #0
    2e80:	1a000046 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2e84:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2e88:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
    2e8c:	e5951018 	ldr	r1, [r5, #24]
    2e90:	e2711001 	rsbs	r1, r1, #1
    2e94:	33a01000 	movcc	r1, #0
    2e98:	e3a0002a 	mov	r0, #42	; 0x2a
    2e9c:	ebfff6bf 	bl	9a0 <_test_assert>
    2ea0:	e3500000 	cmp	r0, #0
    2ea4:	1a00003d 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2ea8:	e321f01f 	msr	CPSR_c, #31
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    2eac:	e595100c 	ldr	r1, [r5, #12]
    2eb0:	e5953008 	ldr	r3, [r5, #8]
    2eb4:	e041e003 	sub	lr, r1, r3
    2eb8:	e27e1000 	rsbs	r1, lr, #0
    2ebc:	e0a1100e 	adc	r1, r1, lr
    2ec0:	e3a0002b 	mov	r0, #43	; 0x2b
    2ec4:	ebfff6b5 	bl	9a0 <_test_assert>
    2ec8:	e3500000 	cmp	r0, #0
    2ecc:	1afffed6 	bne	2a2c <mbox1_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2ed0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  mbp->mb_wrptr = mbp->mb_buffer;
    2ed4:	e5953000 	ldr	r3, [r5]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
    2ed8:	e5951004 	ldr	r1, [r5, #4]
    2edc:	e0411003 	sub	r1, r1, r3
    2ee0:	e1a01141 	asr	r1, r1, #2
    2ee4:	e59f0230 	ldr	r0, [pc, #560]	; 311c <mbox1_execute+0x77c>
  mbp->mb_wrptr = mbp->mb_buffer;
    2ee8:	e5853008 	str	r3, [r5, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
    2eec:	e585300c 	str	r3, [r5, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
    2ef0:	ebfff9c6 	bl	1610 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
    2ef4:	e1a01004 	mov	r1, r4
    2ef8:	e59f0220 	ldr	r0, [pc, #544]	; 3120 <mbox1_execute+0x780>
    2efc:	ebfff9c3 	bl	1610 <chSemResetI>
  chSchRescheduleS();
    2f00:	ebfffb36 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2f04:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2f08:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    2f0c:	e5951024 	ldr	r1, [r5, #36]	; 0x24
    2f10:	e241c005 	sub	ip, r1, #5
    2f14:	e27c1000 	rsbs	r1, ip, #0
    2f18:	e0a1100c 	adc	r1, r1, ip
    2f1c:	e3a0002c 	mov	r0, #44	; 0x2c
    2f20:	ebfff69e 	bl	9a0 <_test_assert>
    2f24:	e3500000 	cmp	r0, #0
    2f28:	1a00001c 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2f2c:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2f30:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
    2f34:	e5951018 	ldr	r1, [r5, #24]
    2f38:	e2711001 	rsbs	r1, r1, #1
    2f3c:	33a01000 	movcc	r1, #0
    2f40:	e3a0002d 	mov	r0, #45	; 0x2d
    2f44:	ebfff695 	bl	9a0 <_test_assert>
    2f48:	e3500000 	cmp	r0, #0
    2f4c:	1a000013 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2f50:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2f54:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
    2f58:	e5951000 	ldr	r1, [r5]
    2f5c:	e5953008 	ldr	r3, [r5, #8]
    2f60:	e0412003 	sub	r2, r1, r3
    2f64:	e2721000 	rsbs	r1, r2, #0
    2f68:	e0a11002 	adc	r1, r1, r2
    2f6c:	e3a0002e 	mov	r0, #46	; 0x2e
    2f70:	ebfff68a 	bl	9a0 <_test_assert>
    2f74:	e3500000 	cmp	r0, #0
    2f78:	1a000008 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2f7c:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2f80:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
    2f84:	e5951000 	ldr	r1, [r5]
    2f88:	e595300c 	ldr	r3, [r5, #12]
    2f8c:	e0413003 	sub	r3, r1, r3
    2f90:	e2731000 	rsbs	r1, r3, #0
    2f94:	e3a0002f 	mov	r0, #47	; 0x2f
    2f98:	e0a11003 	adc	r1, r1, r3
    2f9c:	ebfff67f 	bl	9a0 <_test_assert>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2fa0:	e321f01f 	msr	CPSR_c, #31
}
    2fa4:	e28dd00c 	add	sp, sp, #12
    2fa8:	e8bd8030 	pop	{r4, r5, pc}
  msg1 = chMBPost(&mb1, 'X', 1);
    2fac:	e3a01001 	mov	r1, #1
    2fb0:	e3a00058 	mov	r0, #88	; 0x58
    2fb4:	ebfffe29 	bl	2860 <chMBPost.constprop.16>
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
    2fb8:	e3700001 	cmn	r0, #1
    2fbc:	13a01000 	movne	r1, #0
    2fc0:	03a01001 	moveq	r1, #1
    2fc4:	e3a00004 	mov	r0, #4
    2fc8:	ebfff674 	bl	9a0 <_test_assert>
    2fcc:	e3500000 	cmp	r0, #0
    2fd0:	1afffe95 	bne	2a2c <mbox1_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    2fd4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  msg1 = chMBPostI(&mb1, 'X');
    2fd8:	e3a00058 	mov	r0, #88	; 0x58
    2fdc:	ebfff943 	bl	14f0 <chMBPostI.constprop.15>
    2fe0:	e1a01000 	mov	r1, r0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    2fe4:	e321f01f 	msr	CPSR_c, #31
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
    2fe8:	e3710001 	cmn	r1, #1
    2fec:	13a01000 	movne	r1, #0
    2ff0:	03a01001 	moveq	r1, #1
    2ff4:	e3a00005 	mov	r0, #5
    2ff8:	ebfff668 	bl	9a0 <_test_assert>
    2ffc:	e3500000 	cmp	r0, #0
    3000:	1afffe89 	bne	2a2c <mbox1_execute+0x8c>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
    3004:	e3a01001 	mov	r1, #1
    3008:	e3a00058 	mov	r0, #88	; 0x58
    300c:	ebfffe2b 	bl	28c0 <chMBPostAhead.constprop.14>
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
    3010:	e3700001 	cmn	r0, #1
    3014:	13a01000 	movne	r1, #0
    3018:	03a01001 	moveq	r1, #1
    301c:	e3a00006 	mov	r0, #6
    3020:	ebfff65e 	bl	9a0 <_test_assert>
    3024:	e3500000 	cmp	r0, #0
    3028:	1afffe7f 	bne	2a2c <mbox1_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    302c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  msg1 = chMBPostAheadI(&mb1, 'X');
    3030:	e3a00058 	mov	r0, #88	; 0x58
    3034:	ebfff945 	bl	1550 <chMBPostAheadI.constprop.13>
    3038:	e1a01000 	mov	r1, r0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    303c:	e321f01f 	msr	CPSR_c, #31
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
    3040:	e3710001 	cmn	r1, #1
    3044:	13a01000 	movne	r1, #0
    3048:	03a01001 	moveq	r1, #1
    304c:	e3a00007 	mov	r0, #7
    3050:	ebfff652 	bl	9a0 <_test_assert>
    3054:	e3500000 	cmp	r0, #0
    3058:	1afffe73 	bne	2a2c <mbox1_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    305c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
    3060:	e5951024 	ldr	r1, [r5, #36]	; 0x24
    3064:	e2711001 	rsbs	r1, r1, #1
    3068:	33a01000 	movcc	r1, #0
    306c:	e3a00008 	mov	r0, #8
    3070:	ebfff64a 	bl	9a0 <_test_assert>
    3074:	e3500000 	cmp	r0, #0
    3078:	1affffc8 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    307c:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3080:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
    3084:	e5951018 	ldr	r1, [r5, #24]
    3088:	e2413005 	sub	r3, r1, #5
    308c:	e2731000 	rsbs	r1, r3, #0
    3090:	e0a11003 	adc	r1, r1, r3
    3094:	e3a00009 	mov	r0, #9
    3098:	ebfff640 	bl	9a0 <_test_assert>
    309c:	e3500000 	cmp	r0, #0
    30a0:	1affffbe 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    30a4:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    30a8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
    30ac:	e595100c 	ldr	r1, [r5, #12]
    30b0:	e5953008 	ldr	r3, [r5, #8]
    30b4:	e0414003 	sub	r4, r1, r3
    30b8:	e2741000 	rsbs	r1, r4, #0
    30bc:	e0a11004 	adc	r1, r1, r4
    30c0:	e3a0000a 	mov	r0, #10
    30c4:	ebfff635 	bl	9a0 <_test_assert>
    30c8:	e3500000 	cmp	r0, #0
    30cc:	1affffb3 	bne	2fa0 <mbox1_execute+0x600>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    30d0:	e321f01f 	msr	CPSR_c, #31
    30d4:	e3a04005 	mov	r4, #5
    30d8:	ea000003 	b	30ec <mbox1_execute+0x74c>
    test_emit_token(msg2);
    30dc:	e5dd0004 	ldrb	r0, [sp, #4]
    30e0:	ebfff63e 	bl	9e0 <test_emit_token>
  for (i = 0; i < MB_SIZE; i++) {
    30e4:	e2544001 	subs	r4, r4, #1
    30e8:	0afffe51 	beq	2a34 <mbox1_execute+0x94>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    30ec:	e3e01000 	mvn	r1, #0
    30f0:	e28d0004 	add	r0, sp, #4
    30f4:	ebfffe0d 	bl	2930 <chMBFetch.constprop.12>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    30f8:	e2701001 	rsbs	r1, r0, #1
    30fc:	33a01000 	movcc	r1, #0
    3100:	e3a0000b 	mov	r0, #11
    3104:	ebfff625 	bl	9a0 <_test_assert>
    3108:	e3500000 	cmp	r0, #0
    310c:	0afffff2 	beq	30dc <mbox1_execute+0x73c>
    3110:	eafffe45 	b	2a2c <mbox1_execute+0x8c>
    3114:	40000aac 	.word	0x40000aac
    3118:	000083b0 	.word	0x000083b0
    311c:	40000ac8 	.word	0x40000ac8
    3120:	40000abc 	.word	0x40000abc
	...

00003130 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
    3130:	e3510000 	cmp	r1, #0
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
    3134:	e1a02000 	mov	r2, r0
  if (TIME_IMMEDIATE == timeout) {
    3138:	0a000008 	beq	3160 <chThdEnqueueTimeoutS+0x30>
  queue_insert(currp, tqp);
    313c:	e59f3024 	ldr	r3, [pc, #36]	; 3168 <chThdEnqueueTimeoutS+0x38>
    3140:	e5933018 	ldr	r3, [r3, #24]
  tp->p_next = (thread_t *)tqp;
    3144:	e5830000 	str	r0, [r3]
  tp->p_prev = tqp->p_prev;
    3148:	e590c004 	ldr	ip, [r0, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
    314c:	e3a00004 	mov	r0, #4
    3150:	e583c004 	str	ip, [r3, #4]
  tp->p_prev->p_next = tp;
    3154:	e58c3000 	str	r3, [ip]
  tqp->p_prev = tp;
    3158:	e5823004 	str	r3, [r2, #4]
    315c:	eafffcef 	b	2520 <chSchGoSleepTimeoutS>
}
    3160:	e3e00000 	mvn	r0, #0
    3164:	e12fff1e 	bx	lr
    3168:	40000c00 	.word	0x40000c00
    316c:	00000000 	.word	0x00000000

00003170 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
    3170:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    3174:	e1a04000 	mov	r4, r0
    3178:	e1a05001 	mov	r5, r1
    317c:	e1a06002 	mov	r6, r2
    3180:	e1a09003 	mov	r9, r3
  qnotify_t nfy = oqp->q_notify;
    3184:	e590801c 	ldr	r8, [r0, #28]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3188:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  size_t w = 0;
    318c:	e3a07000 	mov	r7, #0
    3190:	e5943008 	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
    3194:	e3530000 	cmp	r3, #0
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
    3198:	e2432001 	sub	r2, r3, #1
    while (chOQIsFullI(oqp)) {
    319c:	0a000018 	beq	3204 <chOQWriteTimeout+0x94>
    *oqp->q_wrptr++ = *bp++;
    31a0:	e5943014 	ldr	r3, [r4, #20]
    31a4:	e2831001 	add	r1, r3, #1
    31a8:	e5841014 	str	r1, [r4, #20]
    oqp->q_counter--;
    31ac:	e5842008 	str	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
    31b0:	e5d52000 	ldrb	r2, [r5]
    31b4:	e5c32000 	strb	r2, [r3]
    if (oqp->q_wrptr >= oqp->q_top) {
    31b8:	e5943010 	ldr	r3, [r4, #16]
    31bc:	e5942014 	ldr	r2, [r4, #20]
    31c0:	e1520003 	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
    31c4:	2594300c 	ldrcs	r3, [r4, #12]
    31c8:	25843014 	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
    31cc:	e3580000 	cmp	r8, #0
    *oqp->q_wrptr++ = *bp++;
    31d0:	e2855001 	add	r5, r5, #1
      nfy(oqp);
    31d4:	11a00004 	movne	r0, r4
    31d8:	11a0e00f 	movne	lr, pc
    31dc:	112fff18 	bxne	r8
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    31e0:	e321f01f 	msr	CPSR_c, #31
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
    31e4:	e2566001 	subs	r6, r6, #1
    w++;
    31e8:	e2877001 	add	r7, r7, #1
    if (--n == 0U) {
    31ec:	0a00000a 	beq	321c <chOQWriteTimeout+0xac>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    31f0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    31f4:	e5943008 	ldr	r3, [r4, #8]
    while (chOQIsFullI(oqp)) {
    31f8:	e3530000 	cmp	r3, #0
    oqp->q_counter--;
    31fc:	e2432001 	sub	r2, r3, #1
    while (chOQIsFullI(oqp)) {
    3200:	1affffe6 	bne	31a0 <chOQWriteTimeout+0x30>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
    3204:	e1a01009 	mov	r1, r9
    3208:	e1a00004 	mov	r0, r4
    320c:	ebffffc7 	bl	3130 <chThdEnqueueTimeoutS>
    3210:	e3500000 	cmp	r0, #0
    3214:	0affffdd 	beq	3190 <chOQWriteTimeout+0x20>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3218:	e321f01f 	msr	CPSR_c, #31
      return w;
    }
    chSysLock();
  }
}
    321c:	e1a00007 	mov	r0, r7
    3220:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
	...

00003230 <writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    3230:	e2800030 	add	r0, r0, #48	; 0x30
    3234:	eaffffcd 	b	3170 <chOQWriteTimeout>
	...

00003240 <write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    3240:	e2800030 	add	r0, r0, #48	; 0x30
    3244:	e3e03000 	mvn	r3, #0
    3248:	eaffffc8 	b	3170 <chOQWriteTimeout>
    324c:	00000000 	andeq	r0, r0, r0

00003250 <chOQPutTimeout>:
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    3250:	e92d4070 	push	{r4, r5, r6, lr}
    3254:	e1a04000 	mov	r4, r0
    3258:	e1a06001 	mov	r6, r1
    325c:	e1a05002 	mov	r5, r2
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3260:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    3264:	ea000004 	b	327c <chOQPutTimeout+0x2c>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
    3268:	e1a01005 	mov	r1, r5
    326c:	e1a00004 	mov	r0, r4
    3270:	ebffffae 	bl	3130 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
    3274:	e3500000 	cmp	r0, #0
    3278:	ba000015 	blt	32d4 <chOQPutTimeout+0x84>
    327c:	e5943008 	ldr	r3, [r4, #8]
  while (chOQIsFullI(oqp)) {
    3280:	e3530000 	cmp	r3, #0
    3284:	0afffff7 	beq	3268 <chOQPutTimeout+0x18>
  *oqp->q_wrptr++ = b;
    3288:	e5942014 	ldr	r2, [r4, #20]
  oqp->q_counter--;
    328c:	e2433001 	sub	r3, r3, #1
  *oqp->q_wrptr++ = b;
    3290:	e2821001 	add	r1, r2, #1
    3294:	e5841014 	str	r1, [r4, #20]
  oqp->q_counter--;
    3298:	e5843008 	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
    329c:	e5c26000 	strb	r6, [r2]
  if (oqp->q_wrptr >= oqp->q_top) {
    32a0:	e5943010 	ldr	r3, [r4, #16]
    32a4:	e5942014 	ldr	r2, [r4, #20]
    32a8:	e1520003 	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
    32ac:	2594300c 	ldrcs	r3, [r4, #12]
    32b0:	25843014 	strcs	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
    32b4:	e594301c 	ldr	r3, [r4, #28]
    32b8:	e3530000 	cmp	r3, #0
    oqp->q_notify(oqp);
    32bc:	11a00004 	movne	r0, r4
    32c0:	11a0e00f 	movne	lr, pc
    32c4:	112fff13 	bxne	r3
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    32c8:	e321f01f 	msr	CPSR_c, #31
    32cc:	e3a00000 	mov	r0, #0
}
    32d0:	e8bd8070 	pop	{r4, r5, r6, pc}
    32d4:	e321f01f 	msr	CPSR_c, #31
    32d8:	e8bd8070 	pop	{r4, r5, r6, pc}
    32dc:	00000000 	andeq	r0, r0, r0

000032e0 <thread2.lto_priv.71>:

static THD_FUNCTION(thread2, p) {

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
    32e0:	e3a020c8 	mov	r2, #200	; 0xc8
    32e4:	e3a01000 	mov	r1, #0
    32e8:	e59f0000 	ldr	r0, [pc]	; 32f0 <thread2.lto_priv.71+0x10>
    32ec:	eaffffd7 	b	3250 <chOQPutTimeout>
    32f0:	40000ae0 	.word	0x40000ae0
	...

00003300 <putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    3300:	e2800030 	add	r0, r0, #48	; 0x30
    3304:	eaffffd1 	b	3250 <chOQPutTimeout>
	...

00003310 <put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    3310:	e2800030 	add	r0, r0, #48	; 0x30
    3314:	e3e02000 	mvn	r2, #0
    3318:	eaffffcc 	b	3250 <chOQPutTimeout>
    331c:	00000000 	andeq	r0, r0, r0

00003320 <chIQReadTimeout>:
                       size_t n, systime_t timeout) {
    3320:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    3324:	e1a04000 	mov	r4, r0
    3328:	e1a08001 	mov	r8, r1
    332c:	e1a09002 	mov	r9, r2
    3330:	e1a05003 	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
    3334:	e590701c 	ldr	r7, [r0, #28]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3338:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  size_t r = 0;
    333c:	e3a06000 	mov	r6, #0
    if (nfy != NULL) {
    3340:	e3570000 	cmp	r7, #0
    3344:	0a000008 	beq	336c <chIQReadTimeout+0x4c>
      nfy(iqp);
    3348:	e1a00004 	mov	r0, r4
    334c:	e1a0e00f 	mov	lr, pc
    3350:	e12fff17 	bx	r7
    3354:	ea000004 	b	336c <chIQReadTimeout+0x4c>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
    3358:	e1a01005 	mov	r1, r5
    335c:	e1a00004 	mov	r0, r4
    3360:	ebffff72 	bl	3130 <chThdEnqueueTimeoutS>
    3364:	e3500000 	cmp	r0, #0
    3368:	1a000014 	bne	33c0 <chIQReadTimeout+0xa0>
    336c:	e5943008 	ldr	r3, [r4, #8]
    while (chIQIsEmptyI(iqp)) {
    3370:	e3530000 	cmp	r3, #0
    3374:	0afffff7 	beq	3358 <chIQReadTimeout+0x38>
    *bp++ = *iqp->q_rdptr++;
    3378:	e5942018 	ldr	r2, [r4, #24]
    iqp->q_counter--;
    337c:	e2433001 	sub	r3, r3, #1
    *bp++ = *iqp->q_rdptr++;
    3380:	e2821001 	add	r1, r2, #1
    3384:	e5841018 	str	r1, [r4, #24]
    iqp->q_counter--;
    3388:	e5843008 	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
    338c:	e5d23000 	ldrb	r3, [r2]
    3390:	e4c83001 	strb	r3, [r8], #1
    if (iqp->q_rdptr >= iqp->q_top) {
    3394:	e5943010 	ldr	r3, [r4, #16]
    3398:	e5942018 	ldr	r2, [r4, #24]
    339c:	e1520003 	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
    33a0:	2594300c 	ldrcs	r3, [r4, #12]
    33a4:	25843018 	strcs	r3, [r4, #24]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    33a8:	e321f01f 	msr	CPSR_c, #31
    r++;
    33ac:	e2866001 	add	r6, r6, #1
    if (--n == 0U) {
    33b0:	e1590006 	cmp	r9, r6
    33b4:	0a000002 	beq	33c4 <chIQReadTimeout+0xa4>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    33b8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    33bc:	eaffffdf 	b	3340 <chIQReadTimeout+0x20>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    33c0:	e321f01f 	msr	CPSR_c, #31
}
    33c4:	e1a00006 	mov	r0, r6
    33c8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    33cc:	00000000 	andeq	r0, r0, r0

000033d0 <readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    33d0:	e280000c 	add	r0, r0, #12
    33d4:	eaffffd1 	b	3320 <chIQReadTimeout>
	...

000033e0 <read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    33e0:	e280000c 	add	r0, r0, #12
    33e4:	e3e03000 	mvn	r3, #0
    33e8:	eaffffcc 	b	3320 <chIQReadTimeout>
    33ec:	00000000 	andeq	r0, r0, r0

000033f0 <chIQGetTimeout>:
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
    33f0:	e92d4070 	push	{r4, r5, r6, lr}
    33f4:	e1a05001 	mov	r5, r1
    33f8:	e1a04000 	mov	r4, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    33fc:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (iqp->q_notify != NULL) {
    3400:	e590301c 	ldr	r3, [r0, #28]
    3404:	e3530000 	cmp	r3, #0
    3408:	0a000007 	beq	342c <chIQGetTimeout+0x3c>
    iqp->q_notify(iqp);
    340c:	e1a0e00f 	mov	lr, pc
    3410:	e12fff13 	bx	r3
    3414:	ea000004 	b	342c <chIQGetTimeout+0x3c>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
    3418:	e1a01005 	mov	r1, r5
    341c:	e1a00004 	mov	r0, r4
    3420:	ebffff42 	bl	3130 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
    3424:	e3500000 	cmp	r0, #0
    3428:	ba00000c 	blt	3460 <chIQGetTimeout+0x70>
    342c:	e5943008 	ldr	r3, [r4, #8]
  while (chIQIsEmptyI(iqp)) {
    3430:	e3530000 	cmp	r3, #0
    3434:	0afffff7 	beq	3418 <chIQGetTimeout+0x28>
  b = *iqp->q_rdptr++;
    3438:	e5942018 	ldr	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    343c:	e5940010 	ldr	r0, [r4, #16]
  b = *iqp->q_rdptr++;
    3440:	e2821001 	add	r1, r2, #1
  iqp->q_counter--;
    3444:	e2433001 	sub	r3, r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
    3448:	e1510000 	cmp	r1, r0
  iqp->q_counter--;
    344c:	e5843008 	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
    3450:	e5841018 	str	r1, [r4, #24]
    iqp->q_rdptr = iqp->q_buffer;
    3454:	2594300c 	ldrcs	r3, [r4, #12]
  b = *iqp->q_rdptr++;
    3458:	e5d20000 	ldrb	r0, [r2]
    iqp->q_rdptr = iqp->q_buffer;
    345c:	25843018 	strcs	r3, [r4, #24]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3460:	e321f01f 	msr	CPSR_c, #31
}
    3464:	e8bd8070 	pop	{r4, r5, r6, pc}
	...

00003470 <thread1.lto_priv.65>:
  chIQGetTimeout(&iq, MS2ST(200));
    3470:	e3a010c8 	mov	r1, #200	; 0xc8
    3474:	e59f0000 	ldr	r0, [pc]	; 347c <thread1.lto_priv.65+0xc>
    3478:	eaffffdc 	b	33f0 <chIQGetTimeout>
    347c:	40000a68 	.word	0x40000a68

00003480 <gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    3480:	e280000c 	add	r0, r0, #12
    3484:	eaffffd9 	b	33f0 <chIQGetTimeout>
	...

00003490 <get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    3490:	e280000c 	add	r0, r0, #12
    3494:	e3e01000 	mvn	r1, #0
    3498:	eaffffd4 	b	33f0 <chIQGetTimeout>
    349c:	00000000 	andeq	r0, r0, r0

000034a0 <chThdSleep>:
void chThdSleep(systime_t time) {
    34a0:	e92d4010 	push	{r4, lr}
    34a4:	e1a01000 	mov	r1, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    34a8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
    34ac:	e3a00008 	mov	r0, #8
    34b0:	ebfffc1a 	bl	2520 <chSchGoSleepTimeoutS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    34b4:	e321f01f 	msr	CPSR_c, #31
}
    34b8:	e8bd8010 	pop	{r4, pc}
    34bc:	00000000 	andeq	r0, r0, r0

000034c0 <Thread1>:
static THD_FUNCTION(Thread1, arg) {

  (void)arg;
  chRegSetThreadName("blinker1");
  while (true) {
    palClearPort(IOPORT1, PAL_PORT_BIT(PA_LED2));
    34c0:	e3a06b02 	mov	r6, #2048	; 0x800
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
    34c4:	e59f304c 	ldr	r3, [pc, #76]	; 3518 <Thread1+0x58>
    34c8:	e59f204c 	ldr	r2, [pc, #76]	; 351c <Thread1+0x5c>
    34cc:	e5933018 	ldr	r3, [r3, #24]
static THD_FUNCTION(Thread1, arg) {
    34d0:	e92d4010 	push	{r4, lr}
    palClearPort(IOPORT1, PAL_PORT_BIT(PA_LED2));
    34d4:	e59f4044 	ldr	r4, [pc, #68]	; 3520 <Thread1+0x60>
    34d8:	e5832018 	str	r2, [r3, #24]
    chThdSleepMilliseconds(200);
    palSetPort(IOPORT1, PAL_PORT_BIT(PA_LED1) | PAL_PORT_BIT(PA_LED2));
    34dc:	e3a05b03 	mov	r5, #3072	; 0xc00
    palClearPort(IOPORT1, PAL_PORT_BIT(PA_LED2));
    34e0:	e50460e3 	str	r6, [r4, #-227]	; 0xffffff1d
    chThdSleepMilliseconds(200);
    34e4:	e3a000c8 	mov	r0, #200	; 0xc8
    34e8:	ebffffec 	bl	34a0 <chThdSleep>
    palSetPort(IOPORT1, PAL_PORT_BIT(PA_LED1) | PAL_PORT_BIT(PA_LED2));
    34ec:	e50450e7 	str	r5, [r4, #-231]	; 0xffffff19
    chThdSleepMilliseconds(800);
    34f0:	e3a00e32 	mov	r0, #800	; 0x320
    34f4:	ebffffe9 	bl	34a0 <chThdSleep>
    palClearPort(IOPORT1, PAL_PORT_BIT(PA_LED1));
    34f8:	e3a03b01 	mov	r3, #1024	; 0x400
    chThdSleepMilliseconds(200);
    34fc:	e3a000c8 	mov	r0, #200	; 0xc8
    palClearPort(IOPORT1, PAL_PORT_BIT(PA_LED1));
    3500:	e50430e3 	str	r3, [r4, #-227]	; 0xffffff1d
    chThdSleepMilliseconds(200);
    3504:	ebffffe5 	bl	34a0 <chThdSleep>
    palSetPort(IOPORT1, PAL_PORT_BIT(PA_LED1) | PAL_PORT_BIT(PA_LED2));
    3508:	e50450e7 	str	r5, [r4, #-231]	; 0xffffff19
    chThdSleepMilliseconds(800);
    350c:	e3a00e32 	mov	r0, #800	; 0x320
    3510:	ebffffe2 	bl	34a0 <chThdSleep>
    3514:	eafffff0 	b	34dc <Thread1+0x1c>
    3518:	40000c00 	.word	0x40000c00
    351c:	00007ff0 	.word	0x00007ff0
    3520:	3fffc0ff 	.word	0x3fffc0ff
	...

00003530 <Thread2>:
static THD_FUNCTION(Thread2, arg) {

  (void)arg;
  chRegSetThreadName("blinker2");
  while (true) {
    palClearPad(IOPORT1, PA_LEDUSB);
    3530:	e3a05102 	mov	r5, #-2147483648	; 0x80000000
    3534:	e1a06005 	mov	r6, r5
    3538:	e59f302c 	ldr	r3, [pc, #44]	; 356c <Thread2+0x3c>
    353c:	e59f202c 	ldr	r2, [pc, #44]	; 3570 <Thread2+0x40>
    3540:	e5933018 	ldr	r3, [r3, #24]
static THD_FUNCTION(Thread2, arg) {
    3544:	e92d4010 	push	{r4, lr}
    palClearPad(IOPORT1, PA_LEDUSB);
    3548:	e59f4024 	ldr	r4, [pc, #36]	; 3574 <Thread2+0x44>
    354c:	e5832018 	str	r2, [r3, #24]
    3550:	e50460e3 	str	r6, [r4, #-227]	; 0xffffff1d
    chThdSleepMilliseconds(200);
    3554:	e3a000c8 	mov	r0, #200	; 0xc8
    3558:	ebffffd0 	bl	34a0 <chThdSleep>
    palSetPad(IOPORT1, PA_LEDUSB);
    355c:	e50450e7 	str	r5, [r4, #-231]	; 0xffffff19
    chThdSleepMilliseconds(300);
    3560:	e3a00f4b 	mov	r0, #300	; 0x12c
    3564:	ebffffcd 	bl	34a0 <chThdSleep>
    3568:	eafffff8 	b	3550 <Thread2+0x20>
    356c:	40000c00 	.word	0x40000c00
    3570:	00008000 	.word	0x00008000
    3574:	3fffc0ff 	.word	0x3fffc0ff
	...

00003580 <sys1_execute>:
static void sys1_execute(void) {
    3580:	e92d4010 	push	{r4, lr}
    3584:	e24dd018 	sub	sp, sp, #24
  sts = chSysGetStatusAndLockX();
    3588:	ebfff878 	bl	1770 <chSysGetStatusAndLockX>
    358c:	e3100080 	tst	r0, #128	; 0x80
    3590:	0bfffa5a 	bleq	1f00 <chSysRestoreStatusX.part.2>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3594:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  sts = chSysGetStatusAndLockX();
    3598:	ebfff874 	bl	1770 <chSysGetStatusAndLockX>
    359c:	e3100080 	tst	r0, #128	; 0x80
    35a0:	0bfffa56 	bleq	1f00 <chSysRestoreStatusX.part.2>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    35a4:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("mrs     %[p0], CPSR" : [p0] "=r" (sts) :);
    35a8:	e10f3000 	mrs	r3, CPSR
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
    35ac:	e3130080 	tst	r3, #128	; 0x80
    35b0:	1a000000 	bne	35b8 <sys1_execute+0x38>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    35b4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  __asm volatile ("mrs     %[p0], CPSR" : [p0] "=r" (sts) :);
    35b8:	e10f3000 	mrs	r3, CPSR
    35bc:	e3130080 	tst	r3, #128	; 0x80
    35c0:	1a000000 	bne	35c8 <sys1_execute+0x48>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    35c4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    35c8:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    35cc:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  __asm volatile ("mrs     %[p0], CPSR" : [p0] "=r" (sts) :);
    35d0:	e10f3000 	mrs	r3, CPSR
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
    35d4:	e3130080 	tst	r3, #128	; 0x80
    35d8:	0a000000 	beq	35e0 <sys1_execute+0x60>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    35dc:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("mrs     %[p0], CPSR" : [p0] "=r" (sts) :);
    35e0:	e10f3000 	mrs	r3, CPSR
    35e4:	e3130080 	tst	r3, #128	; 0x80
    35e8:	0a000000 	beq	35f0 <sys1_execute+0x70>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    35ec:	e321f01f 	msr	CPSR_c, #31
  vtp->vt_func = NULL;
    35f0:	e3a03000 	mov	r3, #0
    35f4:	e58d3010 	str	r3, [sp, #16]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    35f8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (chVTIsArmedI(vtp)) {
    35fc:	e59d3010 	ldr	r3, [sp, #16]
    3600:	e3530000 	cmp	r3, #0
    chVTDoResetI(vtp);
    3604:	e28d4004 	add	r4, sp, #4
    3608:	11a00004 	movne	r0, r4
    360c:	1bfff813 	blne	1660 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
    3610:	e1a00004 	mov	r0, r4
    3614:	e3a03000 	mov	r3, #0
    3618:	e59f2034 	ldr	r2, [pc, #52]	; 3654 <sys1_execute+0xd4>
    361c:	e3a01001 	mov	r1, #1
    3620:	ebfff822 	bl	16b0 <chVTDoSetI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3624:	e321f01f 	msr	CPSR_c, #31
  chThdSleep(10);
    3628:	e3a0000a 	mov	r0, #10
    362c:	ebffff9b 	bl	34a0 <chThdSleep>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3630:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    3634:	e59d1010 	ldr	r1, [sp, #16]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3638:	e321f01f 	msr	CPSR_c, #31
  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
    363c:	e2711001 	rsbs	r1, r1, #1
    3640:	33a01000 	movcc	r1, #0
    3644:	e3a00001 	mov	r0, #1
    3648:	ebfff4d4 	bl	9a0 <_test_assert>
}
    364c:	e28dd018 	add	sp, sp, #24
    3650:	e8bd8010 	pop	{r4, pc}
    3654:	00001f20 	.word	0x00001f20
	...

00003660 <thread1.lto_priv.64>:
static THD_FUNCTION(thread1, p) {
    3660:	e92d4010 	push	{r4, lr}
    3664:	e1a04000 	mov	r4, r0
  chThdSleepMilliseconds(50);
    3668:	e3a00032 	mov	r0, #50	; 0x32
    366c:	ebffff8b 	bl	34a0 <chThdSleep>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3670:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chEvtSignalI(tp, events);
    3674:	e3a01001 	mov	r1, #1
    3678:	e1a00004 	mov	r0, r4
    367c:	ebfff6b7 	bl	1160 <chEvtSignalI>
  chSchRescheduleS();
    3680:	ebfff956 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3684:	e321f01f 	msr	CPSR_c, #31
}
    3688:	e8bd8010 	pop	{r4, pc}
    368c:	00000000 	andeq	r0, r0, r0

00003690 <thread2.lto_priv.70>:
static THD_FUNCTION(thread2, p) {
    3690:	e92d4010 	push	{r4, lr}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3694:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chEvtBroadcastFlagsI(esp, flags);
    3698:	e3a01000 	mov	r1, #0
    369c:	e59f002c 	ldr	r0, [pc, #44]	; 36d0 <thread2.lto_priv.70+0x40>
    36a0:	ebfff6c6 	bl	11c0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
    36a4:	ebfff94d 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    36a8:	e321f01f 	msr	CPSR_c, #31
  chThdSleepMilliseconds(50);
    36ac:	e3a00032 	mov	r0, #50	; 0x32
    36b0:	ebffff7a 	bl	34a0 <chThdSleep>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    36b4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chEvtBroadcastFlagsI(esp, flags);
    36b8:	e3a01000 	mov	r1, #0
    36bc:	e59f0010 	ldr	r0, [pc, #16]	; 36d4 <thread2.lto_priv.70+0x44>
    36c0:	ebfff6be 	bl	11c0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
    36c4:	ebfff945 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    36c8:	e321f01f 	msr	CPSR_c, #31
}
    36cc:	e8bd8010 	pop	{r4, pc}
    36d0:	40000a60 	.word	0x40000a60
    36d4:	40000a64 	.word	0x40000a64
	...

000036e0 <thread3H>:
static THD_FUNCTION(thread3H, p) {
    36e0:	e92d4010 	push	{r4, lr}
  chThdSleepMilliseconds(40);
    36e4:	e3a00028 	mov	r0, #40	; 0x28
    36e8:	ebffff6c 	bl	34a0 <chThdSleep>
  test_cpu_pulse(20);
    36ec:	e3a00014 	mov	r0, #20
    36f0:	ebfff442 	bl	800 <test_cpu_pulse>
  test_emit_token('B');
    36f4:	e3a00042 	mov	r0, #66	; 0x42
}
    36f8:	e8bd4010 	pop	{r4, lr}
  test_emit_token('B');
    36fc:	eafff4b7 	b	9e0 <test_emit_token>

00003700 <thread2M>:
static THD_FUNCTION(thread2M, p) {
    3700:	e92d4010 	push	{r4, lr}
  chThdSleepMilliseconds(20);
    3704:	e3a00014 	mov	r0, #20
    3708:	ebffff64 	bl	34a0 <chThdSleep>
  test_cpu_pulse(40);
    370c:	e3a00028 	mov	r0, #40	; 0x28
    3710:	ebfff43a 	bl	800 <test_cpu_pulse>
  test_emit_token('B');
    3714:	e3a00042 	mov	r0, #66	; 0x42
}
    3718:	e8bd4010 	pop	{r4, lr}
  test_emit_token('B');
    371c:	eafff4af 	b	9e0 <test_emit_token>

00003720 <thread2.lto_priv.69>:
static THD_FUNCTION(thread2, p) {
    3720:	e92d4010 	push	{r4, lr}
  chThdSleepMilliseconds(50);
    3724:	e3a00032 	mov	r0, #50	; 0x32
    3728:	ebffff5c 	bl	34a0 <chThdSleep>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    372c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chSemSignalI(&sem1); /* For coverage reasons */
    3730:	e59f000c 	ldr	r0, [pc, #12]	; 3744 <thread2.lto_priv.69+0x24>
    3734:	ebfff75d 	bl	14b0 <chSemSignalI>
  chSchRescheduleS();
    3738:	ebfff928 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    373c:	e321f01f 	msr	CPSR_c, #31
}
    3740:	e8bd8010 	pop	{r4, pc}
    3744:	40000b04 	.word	0x40000b04
	...

00003750 <test_wait_tick>:
systime_t test_wait_tick(void) {
    3750:	e92d4010 	push	{r4, lr}
  chThdSleep(1);
    3754:	e3a00001 	mov	r0, #1
    3758:	ebffff50 	bl	34a0 <chThdSleep>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    375c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return ch.vtlist.vt_systime;
    3760:	e59f3008 	ldr	r3, [pc, #8]	; 3770 <test_wait_tick+0x20>
    3764:	e5930028 	ldr	r0, [r3, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3768:	e321f01f 	msr	CPSR_c, #31
}
    376c:	e8bd8010 	pop	{r4, pc}
    3770:	40000c00 	.word	0x40000c00
	...

00003780 <bmk10_execute>:
static void bmk10_execute(void) {
    3780:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  test_wait_tick();
    3784:	ebfffff1 	bl	3750 <test_wait_tick>
  uint32_t n = 0;
    3788:	e3a04000 	mov	r4, #0
  test_start_timer(1000);
    378c:	ebfff7e3 	bl	1720 <test_start_timer.constprop.1>
    3790:	e59f8074 	ldr	r8, [pc, #116]	; 380c <bmk10_execute+0x8c>
    chVTDoSetI(&vt1, 1, tmo, NULL);
    3794:	e59f7074 	ldr	r7, [pc, #116]	; 3810 <bmk10_execute+0x90>
    3798:	e59f6074 	ldr	r6, [pc, #116]	; 3814 <bmk10_execute+0x94>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
    379c:	e59f5074 	ldr	r5, [pc, #116]	; 3818 <bmk10_execute+0x98>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    37a0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    chVTDoSetI(&vt1, 1, tmo, NULL);
    37a4:	e3a03000 	mov	r3, #0
    37a8:	e1a02007 	mov	r2, r7
    37ac:	e1a00006 	mov	r0, r6
    37b0:	e3a01001 	mov	r1, #1
    37b4:	ebfff7bd 	bl	16b0 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
    37b8:	e1a02007 	mov	r2, r7
    37bc:	e3a03000 	mov	r3, #0
    37c0:	e59f1054 	ldr	r1, [pc, #84]	; 381c <bmk10_execute+0x9c>
    37c4:	e1a00005 	mov	r0, r5
    37c8:	ebfff7b8 	bl	16b0 <chVTDoSetI>
    chVTDoResetI(&vt1);
    37cc:	e1a00006 	mov	r0, r6
    37d0:	ebfff7a2 	bl	1660 <chVTDoResetI>
    chVTDoResetI(&vt2);
    37d4:	e1a00005 	mov	r0, r5
    37d8:	ebfff7a0 	bl	1660 <chVTDoResetI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    37dc:	e321f01f 	msr	CPSR_c, #31
  } while (!test_timer_done);
    37e0:	e5d83000 	ldrb	r3, [r8]
    37e4:	e3530000 	cmp	r3, #0
    n++;
    37e8:	e2844001 	add	r4, r4, #1
  } while (!test_timer_done);
    37ec:	0affffeb 	beq	37a0 <bmk10_execute+0x20>
  test_print("--- Score : ");
    37f0:	e59f0028 	ldr	r0, [pc, #40]	; 3820 <bmk10_execute+0xa0>
    37f4:	ebfff4b1 	bl	ac0 <test_print>
  test_printn(n * 2);
    37f8:	e1a00084 	lsl	r0, r4, #1
    37fc:	ebfff3df 	bl	780 <test_printn>
  test_println(" timers/S");
    3800:	e59f001c 	ldr	r0, [pc, #28]	; 3824 <bmk10_execute+0xa4>
}
    3804:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  test_println(" timers/S");
    3808:	eafff494 	b	a60 <test_println>
    380c:	40001418 	.word	0x40001418
    3810:	00000340 	.word	0x00000340
    3814:	40001458 	.word	0x40001458
    3818:	4000146c 	.word	0x4000146c
    381c:	00002710 	.word	0x00002710
    3820:	00008010 	.word	0x00008010
    3824:	00008020 	.word	0x00008020
	...

00003830 <bmk9_execute>:
static void bmk9_execute(void) {
    3830:	e92d4070 	push	{r4, r5, r6, lr}
  iqp->q_counter = 0;
    3834:	e3a05000 	mov	r5, #0
  iqp->q_buffer  = bp;
    3838:	e59f30c8 	ldr	r3, [pc, #200]	; 3908 <bmk9_execute+0xd8>
  tqp->p_next = (thread_t *)tqp;
    383c:	e59f40c8 	ldr	r4, [pc, #200]	; 390c <bmk9_execute+0xdc>
  iqp->q_top     = bp + size;
    3840:	e2832010 	add	r2, r3, #16
    3844:	e5842010 	str	r2, [r4, #16]
  iqp->q_buffer  = bp;
    3848:	e584300c 	str	r3, [r4, #12]
  iqp->q_rdptr   = bp;
    384c:	e5843018 	str	r3, [r4, #24]
  iqp->q_wrptr   = bp;
    3850:	e5843014 	str	r3, [r4, #20]
    3854:	e5844000 	str	r4, [r4]
  tqp->p_prev = (thread_t *)tqp;
    3858:	e5844004 	str	r4, [r4, #4]
  iqp->q_counter = 0;
    385c:	e5845008 	str	r5, [r4, #8]
  iqp->q_notify  = infy;
    3860:	e584501c 	str	r5, [r4, #28]
  iqp->q_link    = link;
    3864:	e5845020 	str	r5, [r4, #32]
  test_wait_tick();
    3868:	ebffffb8 	bl	3750 <test_wait_tick>
  test_start_timer(1000);
    386c:	ebfff7ab 	bl	1720 <test_start_timer.constprop.1>
    3870:	e59f6098 	ldr	r6, [pc, #152]	; 3910 <bmk9_execute+0xe0>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3874:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    chIQPutI(&iq, 0);
    3878:	e3a01000 	mov	r1, #0
    387c:	e1a00004 	mov	r0, r4
    3880:	ebfff5ea 	bl	1030 <chIQPutI>
    chIQPutI(&iq, 1);
    3884:	e1a00004 	mov	r0, r4
    3888:	e3a01001 	mov	r1, #1
    388c:	ebfff5e7 	bl	1030 <chIQPutI>
    chIQPutI(&iq, 2);
    3890:	e1a00004 	mov	r0, r4
    3894:	e3a01002 	mov	r1, #2
    3898:	ebfff5e4 	bl	1030 <chIQPutI>
    chIQPutI(&iq, 3);
    389c:	e1a00004 	mov	r0, r4
    38a0:	e3a01003 	mov	r1, #3
    38a4:	ebfff5e1 	bl	1030 <chIQPutI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    38a8:	e321f01f 	msr	CPSR_c, #31
  return chIQGetTimeout(iqp, TIME_INFINITE);
    38ac:	e3e01000 	mvn	r1, #0
    38b0:	e1a00004 	mov	r0, r4
    38b4:	ebfffecd 	bl	33f0 <chIQGetTimeout>
    38b8:	e3e01000 	mvn	r1, #0
    38bc:	e1a00004 	mov	r0, r4
    38c0:	ebfffeca 	bl	33f0 <chIQGetTimeout>
    38c4:	e3e01000 	mvn	r1, #0
    38c8:	e1a00004 	mov	r0, r4
    38cc:	ebfffec7 	bl	33f0 <chIQGetTimeout>
    38d0:	e1a00004 	mov	r0, r4
    38d4:	e3e01000 	mvn	r1, #0
    38d8:	ebfffec4 	bl	33f0 <chIQGetTimeout>
  } while (!test_timer_done);
    38dc:	e5d63000 	ldrb	r3, [r6]
    38e0:	e3530000 	cmp	r3, #0
    n++;
    38e4:	e2855001 	add	r5, r5, #1
  } while (!test_timer_done);
    38e8:	0affffe1 	beq	3874 <bmk9_execute+0x44>
  test_print("--- Score : ");
    38ec:	e59f0020 	ldr	r0, [pc, #32]	; 3914 <bmk9_execute+0xe4>
    38f0:	ebfff472 	bl	ac0 <test_print>
  test_printn(n * 4);
    38f4:	e1a00105 	lsl	r0, r5, #2
    38f8:	ebfff3a0 	bl	780 <test_printn>
  test_println(" bytes/S");
    38fc:	e59f0014 	ldr	r0, [pc, #20]	; 3918 <bmk9_execute+0xe8>
}
    3900:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_println(" bytes/S");
    3904:	eafff455 	b	a60 <test_println>
    3908:	40000d98 	.word	0x40000d98
    390c:	40000da8 	.word	0x40000da8
    3910:	40001418 	.word	0x40001418
    3914:	00008010 	.word	0x00008010
    3918:	00008150 	.word	0x00008150
    391c:	00000000 	.word	0x00000000

00003920 <bmk6_execute>:
static void bmk6_execute(void) {
    3920:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  uint32_t n = 0;
    3924:	e3a04000 	mov	r4, #0
  return ch.rlist.r_current;
    3928:	e59f306c 	ldr	r3, [pc, #108]	; 399c <bmk6_execute+0x7c>
  return chThdGetSelfX()->p_prio;
    392c:	e5933018 	ldr	r3, [r3, #24]
static void bmk6_execute(void) {
    3930:	e24dd00c 	sub	sp, sp, #12
  tprio_t prio = chThdGetPriorityX() + 1;
    3934:	e5935008 	ldr	r5, [r3, #8]
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    3938:	e1a09004 	mov	r9, r4
  test_wait_tick();
    393c:	ebffff83 	bl	3750 <test_wait_tick>
  test_start_timer(1000);
    3940:	ebfff776 	bl	1720 <test_start_timer.constprop.1>
    3944:	e59f8054 	ldr	r8, [pc, #84]	; 39a0 <bmk6_execute+0x80>
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    3948:	e59f7054 	ldr	r7, [pc, #84]	; 39a4 <bmk6_execute+0x84>
    394c:	e59f6054 	ldr	r6, [pc, #84]	; 39a8 <bmk6_execute+0x88>
  tprio_t prio = chThdGetPriorityX() + 1;
    3950:	e2855001 	add	r5, r5, #1
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    3954:	e1a03007 	mov	r3, r7
    3958:	e58d9000 	str	r9, [sp]
    395c:	e1a02005 	mov	r2, r5
    3960:	e3a01e13 	mov	r1, #304	; 0x130
    3964:	e1a00006 	mov	r0, r6
    3968:	ebfffa20 	bl	21f0 <chThdCreateStatic>
  } while (!test_timer_done);
    396c:	e5d83000 	ldrb	r3, [r8]
    3970:	e3530000 	cmp	r3, #0
    n++;
    3974:	e2844001 	add	r4, r4, #1
  } while (!test_timer_done);
    3978:	0afffff5 	beq	3954 <bmk6_execute+0x34>
  test_print("--- Score : ");
    397c:	e59f0028 	ldr	r0, [pc, #40]	; 39ac <bmk6_execute+0x8c>
    3980:	ebfff44e 	bl	ac0 <test_print>
  test_printn(n);
    3984:	e1a00004 	mov	r0, r4
    3988:	ebfff37c 	bl	780 <test_printn>
  test_println(" threads/S");
    398c:	e59f001c 	ldr	r0, [pc, #28]	; 39b0 <bmk6_execute+0x90>
}
    3990:	e28dd00c 	add	sp, sp, #12
    3994:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, lr}
  test_println(" threads/S");
    3998:	eafff430 	b	a60 <test_println>
    399c:	40000c00 	.word	0x40000c00
    39a0:	40001418 	.word	0x40001418
    39a4:	00007fb0 	.word	0x00007fb0
    39a8:	40000e00 	.word	0x40000e00
    39ac:	00008010 	.word	0x00008010
    39b0:	00008110 	.word	0x00008110
	...

000039c0 <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
    39c0:	e92d4070 	push	{r4, r5, r6, lr}
  systime_t time;

  test_wait_tick();
    39c4:	ebffff61 	bl	3750 <test_wait_tick>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    39c8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    39cc:	e59f50b8 	ldr	r5, [pc, #184]	; 3a8c <thd4_execute+0xcc>
    39d0:	e5954028 	ldr	r4, [r5, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    39d4:	e321f01f 	msr	CPSR_c, #31

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMicroseconds(100000);
    39d8:	e3a00064 	mov	r0, #100	; 0x64
    39dc:	ebfffeaf 	bl	34a0 <chThdSleep>
  test_assert_time_window(1,
    39e0:	e2842065 	add	r2, r4, #101	; 0x65
    39e4:	e2841064 	add	r1, r4, #100	; 0x64
    39e8:	e3a00001 	mov	r0, #1
    39ec:	ebfff3b3 	bl	8c0 <_test_assert_time_window>
    39f0:	e3500000 	cmp	r0, #0
    39f4:	18bd8070 	popne	{r4, r5, r6, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    39f8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    39fc:	e5954028 	ldr	r4, [r5, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3a00:	e321f01f 	msr	CPSR_c, #31
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMilliseconds(100);
    3a04:	e3a00064 	mov	r0, #100	; 0x64
    3a08:	ebfffea4 	bl	34a0 <chThdSleep>
  test_assert_time_window(2,
    3a0c:	e2842065 	add	r2, r4, #101	; 0x65
    3a10:	e2841064 	add	r1, r4, #100	; 0x64
    3a14:	e3a00002 	mov	r0, #2
    3a18:	ebfff3a8 	bl	8c0 <_test_assert_time_window>
    3a1c:	e3500000 	cmp	r0, #0
    3a20:	18bd8070 	popne	{r4, r5, r6, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3a24:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    3a28:	e5954028 	ldr	r4, [r5, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3a2c:	e321f01f 	msr	CPSR_c, #31
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
  chThdSleepSeconds(1);
    3a30:	e3a00ffa 	mov	r0, #1000	; 0x3e8
    3a34:	ebfffe99 	bl	34a0 <chThdSleep>
  test_assert_time_window(3,
    3a38:	e2841ffa 	add	r1, r4, #1000	; 0x3e8
    3a3c:	e2812001 	add	r2, r1, #1
    3a40:	e3a00003 	mov	r0, #3
    3a44:	ebfff39d 	bl	8c0 <_test_assert_time_window>
    3a48:	e3500000 	cmp	r0, #0
    3a4c:	18bd8070 	popne	{r4, r5, r6, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3a50:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    3a54:	e5956028 	ldr	r6, [r5, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3a58:	e321f01f 	msr	CPSR_c, #31
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
    3a5c:	e2864064 	add	r4, r6, #100	; 0x64
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3a60:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    3a64:	e5951028 	ldr	r1, [r5, #40]	; 0x28
  if (time > (systime_t)0) {
    3a68:	e0541001 	subs	r1, r4, r1
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
    3a6c:	13a00008 	movne	r0, #8
    3a70:	1bfffaaa 	blne	2520 <chSchGoSleepTimeoutS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3a74:	e321f01f 	msr	CPSR_c, #31
  chThdSleepUntil(time);
  test_assert_time_window(4,
    3a78:	e3a00004 	mov	r0, #4
    3a7c:	e2862065 	add	r2, r6, #101	; 0x65
    3a80:	e1a01004 	mov	r1, r4
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
    3a84:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_assert_time_window(4,
    3a88:	eafff38c 	b	8c0 <_test_assert_time_window>
    3a8c:	40000c00 	.word	0x40000c00

00003a90 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
    3a90:	e92d4010 	push	{r4, lr}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3a94:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    3a98:	e59f4044 	ldr	r4, [pc, #68]	; 3ae4 <chMsgWait+0x54>
    3a9c:	e5942018 	ldr	r2, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
    3aa0:	e1a03002 	mov	r3, r2
    3aa4:	e5b3002c 	ldr	r0, [r3, #44]!	; 0x2c
    3aa8:	e1500003 	cmp	r0, r3
    3aac:	0a000006 	beq	3acc <chMsgWait+0x3c>
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
  tp->p_state = CH_STATE_SNDMSG;
    3ab0:	e3a0c00d 	mov	ip, #13
  tqp->p_next = tp->p_next;
    3ab4:	e5901000 	ldr	r1, [r0]
    3ab8:	e582102c 	str	r1, [r2, #44]	; 0x2c
  tqp->p_next->p_prev = (thread_t *)tqp;
    3abc:	e5813004 	str	r3, [r1, #4]
    3ac0:	e5c0c01c 	strb	ip, [r0, #28]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3ac4:	e321f01f 	msr	CPSR_c, #31
  chSysUnlock();

  return tp;
}
    3ac8:	e8bd8010 	pop	{r4, pc}
    chSchGoSleepS(CH_STATE_WTMSG);
    3acc:	e3a0000e 	mov	r0, #14
    3ad0:	ebfff9ee 	bl	2290 <chSchGoSleepS>
    3ad4:	e5942018 	ldr	r2, [r4, #24]
    3ad8:	e592002c 	ldr	r0, [r2, #44]	; 0x2c
    3adc:	e282302c 	add	r3, r2, #44	; 0x2c
    3ae0:	eafffff2 	b	3ab0 <chMsgWait+0x20>
    3ae4:	40000c00 	.word	0x40000c00
	...

00003af0 <thread2.lto_priv.72>:
static THD_FUNCTION(thread2, p) {
    3af0:	e92d4010 	push	{r4, lr}
    tp = chMsgWait();
    3af4:	ebffffe5 	bl	3a90 <chMsgWait>
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {

  return tp->p_msg;
    3af8:	e5904034 	ldr	r4, [r0, #52]	; 0x34
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3afc:	e321f09f 	msr	CPSR_c, #159	; 0x9f
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
    3b00:	e1a01004 	mov	r1, r4
    3b04:	ebfff90d 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3b08:	e321f01f 	msr	CPSR_c, #31
  } while (msg);
    3b0c:	e3540000 	cmp	r4, #0
    3b10:	1afffff7 	bne	3af4 <thread2.lto_priv.72+0x4>
    3b14:	e8bd8010 	pop	{r4, pc}
	...

00003b20 <msg1_execute>:
  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
    3b20:	e92d4010 	push	{r4, lr}
  return ch.rlist.r_current;
    3b24:	e59f309c 	ldr	r3, [pc, #156]	; 3bc8 <msg1_execute+0xa8>
    3b28:	e5931018 	ldr	r1, [r3, #24]
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
    3b2c:	e5912008 	ldr	r2, [r1, #8]
static void msg1_execute(void) {
    3b30:	e24dd008 	sub	sp, sp, #8
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
    3b34:	e2822001 	add	r2, r2, #1
    3b38:	e58d1000 	str	r1, [sp]
    3b3c:	e59f3088 	ldr	r3, [pc, #136]	; 3bcc <msg1_execute+0xac>
    3b40:	e3a01e13 	mov	r1, #304	; 0x130
    3b44:	e59f0084 	ldr	r0, [pc, #132]	; 3bd0 <msg1_execute+0xb0>
    3b48:	ebfff9a8 	bl	21f0 <chThdCreateStatic>
    3b4c:	e59f3080 	ldr	r3, [pc, #128]	; 3bd4 <msg1_execute+0xb4>
    3b50:	e5830000 	str	r0, [r3]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
    3b54:	ebffffcd 	bl	3a90 <chMsgWait>
  return tp->p_msg;
    3b58:	e5904034 	ldr	r4, [r0, #52]	; 0x34
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3b5c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chSchWakeupS(tp, msg);
    3b60:	e1a01004 	mov	r1, r4
    3b64:	ebfff8f5 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3b68:	e321f01f 	msr	CPSR_c, #31
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
    3b6c:	e20400ff 	and	r0, r4, #255	; 0xff
    3b70:	ebfff39a 	bl	9e0 <test_emit_token>
  tp = chMsgWait();
    3b74:	ebffffc5 	bl	3a90 <chMsgWait>
  return tp->p_msg;
    3b78:	e5904034 	ldr	r4, [r0, #52]	; 0x34
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3b7c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chSchWakeupS(tp, msg);
    3b80:	e1a01004 	mov	r1, r4
    3b84:	ebfff8ed 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3b88:	e321f01f 	msr	CPSR_c, #31
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
    3b8c:	e20400ff 	and	r0, r4, #255	; 0xff
    3b90:	ebfff392 	bl	9e0 <test_emit_token>
  tp = chMsgWait();
    3b94:	ebffffbd 	bl	3a90 <chMsgWait>
  return tp->p_msg;
    3b98:	e5904034 	ldr	r4, [r0, #52]	; 0x34
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3b9c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chSchWakeupS(tp, msg);
    3ba0:	e1a01004 	mov	r1, r4
    3ba4:	ebfff8e5 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3ba8:	e321f01f 	msr	CPSR_c, #31
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
    3bac:	e20400ff 	and	r0, r4, #255	; 0xff
    3bb0:	ebfff38a 	bl	9e0 <test_emit_token>
  test_assert_sequence(1, "ABC");
    3bb4:	e3a00001 	mov	r0, #1
    3bb8:	e59f1018 	ldr	r1, [pc, #24]	; 3bd8 <msg1_execute+0xb8>
}
    3bbc:	e28dd008 	add	sp, sp, #8
    3bc0:	e8bd4010 	pop	{r4, lr}
  test_assert_sequence(1, "ABC");
    3bc4:	eafff355 	b	920 <_test_assert_sequence>
    3bc8:	40000c00 	.word	0x40000c00
    3bcc:	00003c90 	.word	0x00003c90
    3bd0:	40000e00 	.word	0x40000e00
    3bd4:	4000141c 	.word	0x4000141c
    3bd8:	000081c0 	.word	0x000081c0
    3bdc:	00000000 	.word	0x00000000

00003be0 <chMsgSend>:
  thread_t *ctp = currp;
    3be0:	e59f3050 	ldr	r3, [pc, #80]	; 3c38 <chMsgSend+0x58>
msg_t chMsgSend(thread_t *tp, msg_t msg) {
    3be4:	e92d4010 	push	{r4, lr}
  thread_t *ctp = currp;
    3be8:	e5934018 	ldr	r4, [r3, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3bec:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  ctp->p_u.wtobjp = &tp->p_msgqueue;
    3bf0:	e280202c 	add	r2, r0, #44	; 0x2c
    3bf4:	e5842024 	str	r2, [r4, #36]	; 0x24
  tp->p_next = (thread_t *)tqp;
    3bf8:	e5842000 	str	r2, [r4]
  tp->p_prev = tqp->p_prev;
    3bfc:	e5902030 	ldr	r2, [r0, #48]	; 0x30
  ctp->p_msg = msg;
    3c00:	e5841034 	str	r1, [r4, #52]	; 0x34
    3c04:	e5842004 	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
    3c08:	e5824000 	str	r4, [r2]
  if (tp->p_state == CH_STATE_WTMSG) {
    3c0c:	e5d0201c 	ldrb	r2, [r0, #28]
    3c10:	e352000e 	cmp	r2, #14
  tqp->p_prev = tp;
    3c14:	e5804030 	str	r4, [r0, #48]	; 0x30
    3c18:	0a000004 	beq	3c30 <chMsgSend+0x50>
  chSchGoSleepS(CH_STATE_SNDMSGQ);
    3c1c:	e3a0000c 	mov	r0, #12
    3c20:	ebfff99a 	bl	2290 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
    3c24:	e5940024 	ldr	r0, [r4, #36]	; 0x24
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3c28:	e321f01f 	msr	CPSR_c, #31
}
    3c2c:	e8bd8010 	pop	{r4, pc}
    (void) chSchReadyI(tp);
    3c30:	ebfff4de 	bl	fb0 <chSchReadyI>
    3c34:	eafffff8 	b	3c1c <chMsgSend+0x3c>
    3c38:	40000c00 	.word	0x40000c00
    3c3c:	00000000 	.word	0x00000000

00003c40 <msg_loop_test>:
static unsigned int msg_loop_test(thread_t *tp) {
    3c40:	e92d4070 	push	{r4, r5, r6, lr}
    3c44:	e1a05000 	mov	r5, r0
  uint32_t n = 0;
    3c48:	e3a04000 	mov	r4, #0
  test_wait_tick();
    3c4c:	ebfffebf 	bl	3750 <test_wait_tick>
  test_start_timer(1000);
    3c50:	ebfff6b2 	bl	1720 <test_start_timer.constprop.1>
    3c54:	e59f602c 	ldr	r6, [pc, #44]	; 3c88 <msg_loop_test+0x48>
    (void)chMsgSend(tp, 1);
    3c58:	e3a01001 	mov	r1, #1
    3c5c:	e1a00005 	mov	r0, r5
    3c60:	ebffffde 	bl	3be0 <chMsgSend>
  } while (!test_timer_done);
    3c64:	e5d63000 	ldrb	r3, [r6]
    3c68:	e3530000 	cmp	r3, #0
    n++;
    3c6c:	e2844001 	add	r4, r4, #1
  } while (!test_timer_done);
    3c70:	0afffff8 	beq	3c58 <msg_loop_test+0x18>
  (void)chMsgSend(tp, 0);
    3c74:	e1a00005 	mov	r0, r5
    3c78:	e3a01000 	mov	r1, #0
    3c7c:	ebffffd7 	bl	3be0 <chMsgSend>
}
    3c80:	e1a00004 	mov	r0, r4
    3c84:	e8bd8070 	pop	{r4, r5, r6, pc}
    3c88:	40001418 	.word	0x40001418
    3c8c:	00000000 	.word	0x00000000

00003c90 <thread.lto_priv.54>:
static THD_FUNCTION(thread, p) {
    3c90:	e92d4010 	push	{r4, lr}
    3c94:	e1a04000 	mov	r4, r0
  chMsgSend(p, 'A');
    3c98:	e3a01041 	mov	r1, #65	; 0x41
    3c9c:	ebffffcf 	bl	3be0 <chMsgSend>
  chMsgSend(p, 'B');
    3ca0:	e1a00004 	mov	r0, r4
    3ca4:	e3a01042 	mov	r1, #66	; 0x42
    3ca8:	ebffffcc 	bl	3be0 <chMsgSend>
  chMsgSend(p, 'C');
    3cac:	e1a00004 	mov	r0, r4
    3cb0:	e3a01043 	mov	r1, #67	; 0x43
}
    3cb4:	e8bd4010 	pop	{r4, lr}
  chMsgSend(p, 'C');
    3cb8:	eaffffc8 	b	3be0 <chMsgSend>
    3cbc:	00000000 	andeq	r0, r0, r0

00003cc0 <chMtxLockS>:
  if (mp->m_owner != NULL) {
    3cc0:	e5903008 	ldr	r3, [r0, #8]
  thread_t *ctp = currp;
    3cc4:	e59f218c 	ldr	r2, [pc, #396]	; 3e58 <chMtxLockS+0x198>
  if (mp->m_owner != NULL) {
    3cc8:	e3530000 	cmp	r3, #0
void chMtxLockS(mutex_t *mp) {
    3ccc:	e92d4070 	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
    3cd0:	e5925018 	ldr	r5, [r2, #24]
  if (mp->m_owner != NULL) {
    3cd4:	0a00003c 	beq	3dcc <chMtxLockS+0x10c>
      while (tp->p_prio < ctp->p_prio) {
    3cd8:	e5951008 	ldr	r1, [r5, #8]
    3cdc:	e5932008 	ldr	r2, [r3, #8]
    3ce0:	e1510002 	cmp	r1, r2
    3ce4:	e1a04000 	mov	r4, r0
    3ce8:	9a000007 	bls	3d0c <chMtxLockS+0x4c>
        switch (tp->p_state) {
    3cec:	e5d3201c 	ldrb	r2, [r3, #28]
    3cf0:	e3520006 	cmp	r2, #6
        tp->p_prio = ctp->p_prio;
    3cf4:	e5831008 	str	r1, [r3, #8]
        switch (tp->p_state) {
    3cf8:	0a000038 	beq	3de0 <chMtxLockS+0x120>
    3cfc:	e3520007 	cmp	r2, #7
    3d00:	0a000014 	beq	3d58 <chMtxLockS+0x98>
    3d04:	e3520000 	cmp	r2, #0
    3d08:	0a000026 	beq	3da8 <chMtxLockS+0xe8>
      queue_prio_insert(ctp, &mp->m_queue);
    3d0c:	e1a0c004 	mov	ip, r4
    3d10:	e1a03004 	mov	r3, r4
    3d14:	ea000003 	b	3d28 <chMtxLockS+0x68>
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    3d18:	e5931008 	ldr	r1, [r3, #8]
    3d1c:	e5952008 	ldr	r2, [r5, #8]
    3d20:	e1510002 	cmp	r1, r2
    3d24:	3a000026 	bcc	3dc4 <chMtxLockS+0x104>
    cp = cp->p_next;
    3d28:	e5933000 	ldr	r3, [r3]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    3d2c:	e1540003 	cmp	r4, r3
    3d30:	1afffff8 	bne	3d18 <chMtxLockS+0x58>
  tp->p_prev = cp->p_prev;
    3d34:	e59c3004 	ldr	r3, [ip, #4]
      chSchGoSleepS(CH_STATE_WTMTX);
    3d38:	e3a00006 	mov	r0, #6
  tp->p_next = cp;
    3d3c:	e585c000 	str	ip, [r5]
  tp->p_prev = cp->p_prev;
    3d40:	e5853004 	str	r3, [r5, #4]
  tp->p_prev->p_next = tp;
    3d44:	e5835000 	str	r5, [r3]
  cp->p_prev = tp;
    3d48:	e58c5004 	str	r5, [ip, #4]
      ctp->p_u.wtmtxp = mp;
    3d4c:	e5854024 	str	r4, [r5, #36]	; 0x24
}
    3d50:	e8bd4070 	pop	{r4, r5, r6, lr}
      chSchGoSleepS(CH_STATE_WTMTX);
    3d54:	eafff94d 	b	2290 <chSchGoSleepS>
  tp->p_prev->p_next = tp->p_next;
    3d58:	e593e000 	ldr	lr, [r3]
    3d5c:	e5930004 	ldr	r0, [r3, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
    3d60:	e593c024 	ldr	ip, [r3, #36]	; 0x24
    3d64:	e580e000 	str	lr, [r0]
  tp->p_next->p_prev = tp->p_prev;
    3d68:	e593e000 	ldr	lr, [r3]
    3d6c:	e1a0200c 	mov	r2, ip
    3d70:	e58e0004 	str	r0, [lr, #4]
    3d74:	ea000002 	b	3d84 <chMtxLockS+0xc4>
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    3d78:	e5920008 	ldr	r0, [r2, #8]
    3d7c:	e1500001 	cmp	r0, r1
    3d80:	3a000030 	bcc	3e48 <chMtxLockS+0x188>
    cp = cp->p_next;
    3d84:	e5922000 	ldr	r2, [r2]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    3d88:	e15c0002 	cmp	ip, r2
    3d8c:	1afffff9 	bne	3d78 <chMtxLockS+0xb8>
  tp->p_prev = cp->p_prev;
    3d90:	e59c2004 	ldr	r2, [ip, #4]
  tp->p_next = cp;
    3d94:	e583c000 	str	ip, [r3]
  tp->p_prev = cp->p_prev;
    3d98:	e5832004 	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    3d9c:	e5823000 	str	r3, [r2]
  cp->p_prev = tp;
    3da0:	e58c3004 	str	r3, [ip, #4]
    3da4:	eaffffd8 	b	3d0c <chMtxLockS+0x4c>
  tp->p_prev->p_next = tp->p_next;
    3da8:	e8930006 	ldm	r3, {r1, r2}
    3dac:	e5821000 	str	r1, [r2]
  tp->p_next->p_prev = tp->p_prev;
    3db0:	e5931000 	ldr	r1, [r3]
          (void) chSchReadyI(queue_dequeue(tp));
    3db4:	e1a00003 	mov	r0, r3
    3db8:	e5812004 	str	r2, [r1, #4]
    3dbc:	ebfff47b 	bl	fb0 <chSchReadyI>
    3dc0:	eaffffd1 	b	3d0c <chMtxLockS+0x4c>
    cp = cp->p_next;
    3dc4:	e1a0c003 	mov	ip, r3
    3dc8:	eaffffd9 	b	3d34 <chMtxLockS+0x74>
    mp->m_next = ctp->p_mtxlist;
    3dcc:	e595303c 	ldr	r3, [r5, #60]	; 0x3c
    mp->m_owner = ctp;
    3dd0:	e5805008 	str	r5, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
    3dd4:	e580300c 	str	r3, [r0, #12]
    ctp->p_mtxlist = mp;
    3dd8:	e585003c 	str	r0, [r5, #60]	; 0x3c
}
    3ddc:	e8bd8070 	pop	{r4, r5, r6, pc}
  tp->p_prev->p_next = tp->p_next;
    3de0:	e5936000 	ldr	r6, [r3]
    3de4:	e5930004 	ldr	r0, [r3, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
    3de8:	e593c024 	ldr	ip, [r3, #36]	; 0x24
    3dec:	e5806000 	str	r6, [r0]
  tp->p_next->p_prev = tp->p_prev;
    3df0:	e5936000 	ldr	r6, [r3]
    3df4:	e1a0e00c 	mov	lr, ip
    3df8:	e1a0200c 	mov	r2, ip
    3dfc:	e5860004 	str	r0, [r6, #4]
    3e00:	ea000002 	b	3e10 <chMtxLockS+0x150>
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    3e04:	e5920008 	ldr	r0, [r2, #8]
    3e08:	e1500001 	cmp	r0, r1
    3e0c:	3a00000f 	bcc	3e50 <chMtxLockS+0x190>
    cp = cp->p_next;
    3e10:	e5922000 	ldr	r2, [r2]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    3e14:	e15c0002 	cmp	ip, r2
    3e18:	1afffff9 	bne	3e04 <chMtxLockS+0x144>
  tp->p_prev = cp->p_prev;
    3e1c:	e59e2004 	ldr	r2, [lr, #4]
  tp->p_next = cp;
    3e20:	e583e000 	str	lr, [r3]
  tp->p_prev = cp->p_prev;
    3e24:	e5832004 	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
    3e28:	e5823000 	str	r3, [r2]
  cp->p_prev = tp;
    3e2c:	e58e3004 	str	r3, [lr, #4]
          tp = tp->p_u.wtmtxp->m_owner;
    3e30:	e59c3008 	ldr	r3, [ip, #8]
      while (tp->p_prio < ctp->p_prio) {
    3e34:	e5951008 	ldr	r1, [r5, #8]
    3e38:	e5932008 	ldr	r2, [r3, #8]
    3e3c:	e1520001 	cmp	r2, r1
    3e40:	3affffa9 	bcc	3cec <chMtxLockS+0x2c>
    3e44:	eaffffb0 	b	3d0c <chMtxLockS+0x4c>
    cp = cp->p_next;
    3e48:	e1a0c002 	mov	ip, r2
    3e4c:	eaffffcf 	b	3d90 <chMtxLockS+0xd0>
    3e50:	e1a0e002 	mov	lr, r2
    3e54:	eafffff0 	b	3e1c <chMtxLockS+0x15c>
    3e58:	40000c00 	.word	0x40000c00
    3e5c:	00000000 	.word	0x00000000

00003e60 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
    3e60:	e92d4010 	push	{r4, lr}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3e64:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chMtxLockS(mp);
    3e68:	ebffff94 	bl	3cc0 <chMtxLockS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3e6c:	e321f01f 	msr	CPSR_c, #31
}
    3e70:	e8bd8010 	pop	{r4, pc}
	...

00003e80 <bmk12_execute>:
static void bmk12_execute(void) {
    3e80:	e92d4070 	push	{r4, r5, r6, lr}
  test_wait_tick();
    3e84:	ebfffe31 	bl	3750 <test_wait_tick>
  uint32_t n = 0;
    3e88:	e3a05000 	mov	r5, #0
  test_start_timer(1000);
    3e8c:	ebfff623 	bl	1720 <test_start_timer.constprop.1>
    3e90:	e59f606c 	ldr	r6, [pc, #108]	; 3f04 <bmk12_execute+0x84>
    chMtxLock(&mtx1);
    3e94:	e59f406c 	ldr	r4, [pc, #108]	; 3f08 <bmk12_execute+0x88>
    3e98:	e1a00004 	mov	r0, r4
    3e9c:	ebffffef 	bl	3e60 <chMtxLock>
    chMtxUnlock(&mtx1);
    3ea0:	e1a00004 	mov	r0, r4
    3ea4:	ebfff895 	bl	2100 <chMtxUnlock>
    chMtxLock(&mtx1);
    3ea8:	e1a00004 	mov	r0, r4
    3eac:	ebffffeb 	bl	3e60 <chMtxLock>
    chMtxUnlock(&mtx1);
    3eb0:	e1a00004 	mov	r0, r4
    3eb4:	ebfff891 	bl	2100 <chMtxUnlock>
    chMtxLock(&mtx1);
    3eb8:	e1a00004 	mov	r0, r4
    3ebc:	ebffffe7 	bl	3e60 <chMtxLock>
    chMtxUnlock(&mtx1);
    3ec0:	e1a00004 	mov	r0, r4
    3ec4:	ebfff88d 	bl	2100 <chMtxUnlock>
    chMtxLock(&mtx1);
    3ec8:	e1a00004 	mov	r0, r4
    3ecc:	ebffffe3 	bl	3e60 <chMtxLock>
    chMtxUnlock(&mtx1);
    3ed0:	e1a00004 	mov	r0, r4
    3ed4:	ebfff889 	bl	2100 <chMtxUnlock>
  } while (!test_timer_done);
    3ed8:	e5d63000 	ldrb	r3, [r6]
    3edc:	e3530000 	cmp	r3, #0
    n++;
    3ee0:	e2855001 	add	r5, r5, #1
  } while (!test_timer_done);
    3ee4:	0affffeb 	beq	3e98 <bmk12_execute+0x18>
  test_print("--- Score : ");
    3ee8:	e59f001c 	ldr	r0, [pc, #28]	; 3f0c <bmk12_execute+0x8c>
    3eec:	ebfff2f3 	bl	ac0 <test_print>
  test_printn(n * 4);
    3ef0:	e1a00105 	lsl	r0, r5, #2
    3ef4:	ebfff221 	bl	780 <test_printn>
  test_println(" lock+unlock/S");
    3ef8:	e59f0010 	ldr	r0, [pc, #16]	; 3f10 <bmk12_execute+0x90>
}
    3efc:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_println(" lock+unlock/S");
    3f00:	eafff2d6 	b	a60 <test_println>
    3f04:	40001418 	.word	0x40001418
    3f08:	40000ddc 	.word	0x40000ddc
    3f0c:	00008010 	.word	0x00008010
    3f10:	00008040 	.word	0x00008040
	...

00003f20 <thread11>:

static THD_FUNCTION(thread11, p) {
    3f20:	e92d4070 	push	{r4, r5, r6, lr}
    3f24:	e1a06000 	mov	r6, r0

  chMtxLock(&m2);
    3f28:	e59f00a4 	ldr	r0, [pc, #164]	; 3fd4 <thread11+0xb4>
    3f2c:	ebffffcb 	bl	3e60 <chMtxLock>
  chMtxLock(&m1);
    3f30:	e59f00a0 	ldr	r0, [pc, #160]	; 3fd8 <thread11+0xb8>
    3f34:	ebffffc9 	bl	3e60 <chMtxLock>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    3f38:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    3f3c:	e59f4098 	ldr	r4, [pc, #152]	; 3fdc <thread11+0xbc>
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->p_mtxlist;
    3f40:	e5943018 	ldr	r3, [r4, #24]
    3f44:	e593503c 	ldr	r5, [r3, #60]	; 0x3c
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
    3f48:	e1a00005 	mov	r0, r5
    3f4c:	ebfff533 	bl	1420 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
    3f50:	e59f2088 	ldr	r2, [pc, #136]	; 3fe0 <thread11+0xc0>
    3f54:	e594c018 	ldr	ip, [r4, #24]
  thread_t *cp = (thread_t *)tqp;
    3f58:	e1a00002 	mov	r0, r2
    3f5c:	e1a03002 	mov	r3, r2
    3f60:	e58c2024 	str	r2, [ip, #36]	; 0x24
    3f64:	ea000003 	b	3f78 <thread11+0x58>
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    3f68:	e5931008 	ldr	r1, [r3, #8]
    3f6c:	e59c2008 	ldr	r2, [ip, #8]
    3f70:	e1510002 	cmp	r1, r2
    3f74:	3a000002 	bcc	3f84 <thread11+0x64>
    cp = cp->p_next;
    3f78:	e5933000 	ldr	r3, [r3]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    3f7c:	e1530000 	cmp	r3, r0
    3f80:	1afffff8 	bne	3f68 <thread11+0x48>
  tp->p_prev = cp->p_prev;
    3f84:	e5932004 	ldr	r2, [r3, #4]
    chSchGoSleepS(newstate);
    3f88:	e3a00007 	mov	r0, #7
  tp->p_next = cp;
    3f8c:	e58c3000 	str	r3, [ip]
  tp->p_prev = cp->p_prev;
    3f90:	e58c2004 	str	r2, [ip, #4]
  tp->p_prev->p_next = tp;
    3f94:	e582c000 	str	ip, [r2]
  cp->p_prev = tp;
    3f98:	e583c004 	str	ip, [r3, #4]
    3f9c:	ebfff8bb 	bl	2290 <chSchGoSleepS>
  return currp->p_u.rdymsg;
    3fa0:	e5943018 	ldr	r3, [r4, #24]
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
  if (msg != MSG_TIMEOUT) {
    3fa4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
    3fa8:	e3730001 	cmn	r3, #1
    chMtxLockS(mp);
    3fac:	11a00005 	movne	r0, r5
    3fb0:	1bffff42 	blne	3cc0 <chMtxLockS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    3fb4:	e321f01f 	msr	CPSR_c, #31
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
    3fb8:	e5d60000 	ldrb	r0, [r6]
    3fbc:	ebfff287 	bl	9e0 <test_emit_token>
  chMtxUnlock(&m1);
    3fc0:	e59f0010 	ldr	r0, [pc, #16]	; 3fd8 <thread11+0xb8>
    3fc4:	ebfff84d 	bl	2100 <chMtxUnlock>
  chMtxUnlock(&m2);
    3fc8:	e59f0004 	ldr	r0, [pc, #4]	; 3fd4 <thread11+0xb4>
}
    3fcc:	e8bd4070 	pop	{r4, r5, r6, lr}
  chMtxUnlock(&m2);
    3fd0:	eafff84a 	b	2100 <chMtxUnlock>
    3fd4:	40000a9c 	.word	0x40000a9c
    3fd8:	40000a8c 	.word	0x40000a8c
    3fdc:	40000c00 	.word	0x40000c00
    3fe0:	40000a58 	.word	0x40000a58
	...

00003ff0 <thread10>:
static THD_FUNCTION(thread10, p) {
    3ff0:	e92d4070 	push	{r4, r5, r6, lr}
    3ff4:	e1a06000 	mov	r6, r0
  chMtxLock(&m1);
    3ff8:	e59f0084 	ldr	r0, [pc, #132]	; 4084 <thread10+0x94>
    3ffc:	ebffff97 	bl	3e60 <chMtxLock>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4000:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  thread_t *ctp = currp;
    4004:	e59f307c 	ldr	r3, [pc, #124]	; 4088 <thread10+0x98>
    4008:	e5934018 	ldr	r4, [r3, #24]
    400c:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
  chMtxUnlockS(mp);
    4010:	e1a00005 	mov	r0, r5
    4014:	ebfff501 	bl	1420 <chMtxUnlockS>
  ctp->p_u.wtobjp = cp;
    4018:	e59f206c 	ldr	r2, [pc, #108]	; 408c <thread10+0x9c>
  thread_t *cp = (thread_t *)tqp;
    401c:	e1a00002 	mov	r0, r2
    4020:	e1a03002 	mov	r3, r2
    4024:	e5842024 	str	r2, [r4, #36]	; 0x24
    4028:	ea000003 	b	403c <thread10+0x4c>
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    402c:	e5931008 	ldr	r1, [r3, #8]
    4030:	e5942008 	ldr	r2, [r4, #8]
    4034:	e1510002 	cmp	r1, r2
    4038:	3a000002 	bcc	4048 <thread10+0x58>
    cp = cp->p_next;
    403c:	e5933000 	ldr	r3, [r3]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
    4040:	e1530000 	cmp	r3, r0
    4044:	1afffff8 	bne	402c <thread10+0x3c>
  tp->p_prev = cp->p_prev;
    4048:	e5932004 	ldr	r2, [r3, #4]
  chSchGoSleepS(CH_STATE_WTCOND);
    404c:	e3a00007 	mov	r0, #7
  tp->p_next = cp;
    4050:	e5843000 	str	r3, [r4]
  tp->p_prev = cp->p_prev;
    4054:	e5842004 	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
    4058:	e5824000 	str	r4, [r2]
  cp->p_prev = tp;
    405c:	e5834004 	str	r4, [r3, #4]
    4060:	ebfff88a 	bl	2290 <chSchGoSleepS>
  chMtxLockS(mp);
    4064:	e1a00005 	mov	r0, r5
    4068:	ebffff14 	bl	3cc0 <chMtxLockS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    406c:	e321f01f 	msr	CPSR_c, #31
  test_emit_token(*(char *)p);
    4070:	e5d60000 	ldrb	r0, [r6]
    4074:	ebfff259 	bl	9e0 <test_emit_token>
  chMtxUnlock(&m1);
    4078:	e59f0004 	ldr	r0, [pc, #4]	; 4084 <thread10+0x94>
}
    407c:	e8bd4070 	pop	{r4, r5, r6, lr}
  chMtxUnlock(&m1);
    4080:	eafff81e 	b	2100 <chMtxUnlock>
    4084:	40000a8c 	.word	0x40000a8c
    4088:	40000c00 	.word	0x40000c00
    408c:	40000a58 	.word	0x40000a58

00004090 <thread12>:

static THD_FUNCTION(thread12, p) {
    4090:	e92d4070 	push	{r4, r5, r6, lr}
    4094:	e1a05000 	mov	r5, r0

  chMtxLock(&m2);
    4098:	e59f4018 	ldr	r4, [pc, #24]	; 40b8 <thread12+0x28>
    409c:	e1a00004 	mov	r0, r4
    40a0:	ebffff6e 	bl	3e60 <chMtxLock>
  test_emit_token(*(char *)p);
    40a4:	e5d50000 	ldrb	r0, [r5]
    40a8:	ebfff24c 	bl	9e0 <test_emit_token>
  chMtxUnlock(&m2);
    40ac:	e1a00004 	mov	r0, r4
}
    40b0:	e8bd4070 	pop	{r4, r5, r6, lr}
  chMtxUnlock(&m2);
    40b4:	eafff811 	b	2100 <chMtxUnlock>
    40b8:	40000a9c 	.word	0x40000a9c
    40bc:	00000000 	.word	0x00000000

000040c0 <mtx5_execute>:
static void mtx5_execute(void) {
    40c0:	e92d4070 	push	{r4, r5, r6, lr}
    40c4:	e59f5130 	ldr	r5, [pc, #304]	; 41fc <mtx5_execute+0x13c>
  return chThdGetSelfX()->p_prio;
    40c8:	e5953018 	ldr	r3, [r5, #24]
    40cc:	e5936008 	ldr	r6, [r3, #8]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    40d0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (mp->m_owner != NULL) {
    40d4:	e59f4124 	ldr	r4, [pc, #292]	; 4200 <mtx5_execute+0x140>
    40d8:	e5943008 	ldr	r3, [r4, #8]
    40dc:	e3530000 	cmp	r3, #0
  mp->m_owner = currp;
    40e0:	05953018 	ldreq	r3, [r5, #24]
  mp->m_next = currp->p_mtxlist;
    40e4:	0593203c 	ldreq	r2, [r3, #60]	; 0x3c
  mp->m_owner = currp;
    40e8:	05843008 	streq	r3, [r4, #8]
  mp->m_next = currp->p_mtxlist;
    40ec:	0584200c 	streq	r2, [r4, #12]
  currp->p_mtxlist = mp;
    40f0:	0583403c 	streq	r4, [r3, #60]	; 0x3c
    40f4:	03a01001 	moveq	r1, #1
    return false;
    40f8:	13a01000 	movne	r1, #0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    40fc:	e321f01f 	msr	CPSR_c, #31
  test_assert(1, b, "already locked");
    4100:	e3a00001 	mov	r0, #1
    4104:	ebfff225 	bl	9a0 <_test_assert>
    4108:	e2501000 	subs	r1, r0, #0
    410c:	18bd8070 	popne	{r4, r5, r6, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4110:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (mp->m_owner != NULL) {
    4114:	e5943008 	ldr	r3, [r4, #8]
    4118:	e3530000 	cmp	r3, #0
  mp->m_owner = currp;
    411c:	05953018 	ldreq	r3, [r5, #24]
  mp->m_next = currp->p_mtxlist;
    4120:	0593203c 	ldreq	r2, [r3, #60]	; 0x3c
  mp->m_owner = currp;
    4124:	05843008 	streq	r3, [r4, #8]
  mp->m_next = currp->p_mtxlist;
    4128:	0584200c 	streq	r2, [r4, #12]
  currp->p_mtxlist = mp;
    412c:	0583403c 	streq	r4, [r3, #60]	; 0x3c
  if (mp->m_owner != NULL) {
    4130:	13a01001 	movne	r1, #1
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4134:	e321f01f 	msr	CPSR_c, #31
  test_assert(2, !b, "not locked");
    4138:	e3a00002 	mov	r0, #2
    413c:	ebfff217 	bl	9a0 <_test_assert>
    4140:	e3500000 	cmp	r0, #0
    4144:	18bd8070 	popne	{r4, r5, r6, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4148:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chMtxUnlockS(&m1);
    414c:	e59f00ac 	ldr	r0, [pc, #172]	; 4200 <mtx5_execute+0x140>
    4150:	ebfff4b2 	bl	1420 <chMtxUnlockS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4154:	e321f01f 	msr	CPSR_c, #31
  return (bool)(tqp->p_next == (const thread_t *)tqp);
    4158:	e5941000 	ldr	r1, [r4]
  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
    415c:	e041c004 	sub	ip, r1, r4
    4160:	e27c1000 	rsbs	r1, ip, #0
    4164:	e0a1100c 	adc	r1, r1, ip
    4168:	e3a00003 	mov	r0, #3
    416c:	ebfff20b 	bl	9a0 <_test_assert>
    4170:	e3500000 	cmp	r0, #0
    4174:	18bd8070 	popne	{r4, r5, r6, pc}
  test_assert(4, m1.m_owner == NULL, "still owned");
    4178:	e5941008 	ldr	r1, [r4, #8]
    417c:	e2711001 	rsbs	r1, r1, #1
    4180:	33a01000 	movcc	r1, #0
    4184:	e3a00004 	mov	r0, #4
    4188:	ebfff204 	bl	9a0 <_test_assert>
    418c:	e3500000 	cmp	r0, #0
    4190:	18bd8070 	popne	{r4, r5, r6, pc}
    4194:	e5953018 	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
    4198:	e5931008 	ldr	r1, [r3, #8]
    419c:	e0412006 	sub	r2, r1, r6
    41a0:	e2721000 	rsbs	r1, r2, #0
    41a4:	e0a11002 	adc	r1, r1, r2
    41a8:	e3a00005 	mov	r0, #5
    41ac:	ebfff1fb 	bl	9a0 <_test_assert>
    41b0:	e3500000 	cmp	r0, #0
    41b4:	18bd8070 	popne	{r4, r5, r6, pc}
  chMtxLock(&m1);
    41b8:	e59f0040 	ldr	r0, [pc, #64]	; 4200 <mtx5_execute+0x140>
    41bc:	ebffff27 	bl	3e60 <chMtxLock>
  chMtxUnlockAll();
    41c0:	ebfff69e 	bl	1c40 <chMtxUnlockAll>
    41c4:	e5941000 	ldr	r1, [r4]
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
    41c8:	e0413004 	sub	r3, r1, r4
    41cc:	e2731000 	rsbs	r1, r3, #0
    41d0:	e0a11003 	adc	r1, r1, r3
    41d4:	e3a00006 	mov	r0, #6
    41d8:	ebfff1f0 	bl	9a0 <_test_assert>
    41dc:	e3500000 	cmp	r0, #0
    41e0:	18bd8070 	popne	{r4, r5, r6, pc}
  test_assert(7, m1.m_owner == NULL, "still owned");
    41e4:	e5941008 	ldr	r1, [r4, #8]
    41e8:	e2711001 	rsbs	r1, r1, #1
    41ec:	e3a00007 	mov	r0, #7
    41f0:	33a01000 	movcc	r1, #0
}
    41f4:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_assert(7, m1.m_owner == NULL, "still owned");
    41f8:	eafff1e8 	b	9a0 <_test_assert>
    41fc:	40000c00 	.word	0x40000c00
    4200:	40000a8c 	.word	0x40000a8c
	...

00004210 <thread4a>:
static THD_FUNCTION(thread4a, p) {
    4210:	e92d4010 	push	{r4, lr}
  chMtxLock(&m2);
    4214:	e59f4018 	ldr	r4, [pc, #24]	; 4234 <thread4a+0x24>
  chThdSleepMilliseconds(50);
    4218:	e3a00032 	mov	r0, #50	; 0x32
    421c:	ebfffc9f 	bl	34a0 <chThdSleep>
  chMtxLock(&m2);
    4220:	e1a00004 	mov	r0, r4
    4224:	ebffff0d 	bl	3e60 <chMtxLock>
  chMtxUnlock(&m2);
    4228:	e1a00004 	mov	r0, r4
}
    422c:	e8bd4010 	pop	{r4, lr}
  chMtxUnlock(&m2);
    4230:	eafff7b2 	b	2100 <chMtxUnlock>
    4234:	40000a9c 	.word	0x40000a9c
	...

00004240 <thread4b>:
static THD_FUNCTION(thread4b, p) {
    4240:	e92d4010 	push	{r4, lr}
  chMtxLock(&m1);
    4244:	e59f4018 	ldr	r4, [pc, #24]	; 4264 <thread4b+0x24>
  chThdSleepMilliseconds(150);
    4248:	e3a00096 	mov	r0, #150	; 0x96
    424c:	ebfffc93 	bl	34a0 <chThdSleep>
  chMtxLock(&m1);
    4250:	e1a00004 	mov	r0, r4
    4254:	ebffff01 	bl	3e60 <chMtxLock>
  chMtxUnlock(&m1);
    4258:	e1a00004 	mov	r0, r4
}
    425c:	e8bd4010 	pop	{r4, lr}
  chMtxUnlock(&m1);
    4260:	eafff7a6 	b	2100 <chMtxUnlock>
    4264:	40000a8c 	.word	0x40000a8c
	...

00004270 <thread3LL>:
static THD_FUNCTION(thread3LL, p) {
    4270:	e92d4010 	push	{r4, lr}
  chMtxLock(&m1);
    4274:	e59f4020 	ldr	r4, [pc, #32]	; 429c <thread3LL+0x2c>
    4278:	e1a00004 	mov	r0, r4
    427c:	ebfffef7 	bl	3e60 <chMtxLock>
  test_cpu_pulse(30);
    4280:	e3a0001e 	mov	r0, #30
    4284:	ebfff15d 	bl	800 <test_cpu_pulse>
  chMtxUnlock(&m1);
    4288:	e1a00004 	mov	r0, r4
    428c:	ebfff79b 	bl	2100 <chMtxUnlock>
  test_emit_token('E');
    4290:	e3a00045 	mov	r0, #69	; 0x45
}
    4294:	e8bd4010 	pop	{r4, lr}
  test_emit_token('E');
    4298:	eafff1d0 	b	9e0 <test_emit_token>
    429c:	40000a8c 	.word	0x40000a8c

000042a0 <thread3L>:
static THD_FUNCTION(thread3L, p) {
    42a0:	e92d4070 	push	{r4, r5, r6, lr}
  chMtxLock(&m2);
    42a4:	e59f404c 	ldr	r4, [pc, #76]	; 42f8 <thread3L+0x58>
  chThdSleepMilliseconds(10);
    42a8:	e3a0000a 	mov	r0, #10
    42ac:	ebfffc7b 	bl	34a0 <chThdSleep>
  chMtxLock(&m1);
    42b0:	e59f5044 	ldr	r5, [pc, #68]	; 42fc <thread3L+0x5c>
  chMtxLock(&m2);
    42b4:	e1a00004 	mov	r0, r4
    42b8:	ebfffee8 	bl	3e60 <chMtxLock>
  test_cpu_pulse(20);
    42bc:	e3a00014 	mov	r0, #20
    42c0:	ebfff14e 	bl	800 <test_cpu_pulse>
  chMtxLock(&m1);
    42c4:	e1a00005 	mov	r0, r5
    42c8:	ebfffee4 	bl	3e60 <chMtxLock>
  test_cpu_pulse(10);
    42cc:	e3a0000a 	mov	r0, #10
    42d0:	ebfff14a 	bl	800 <test_cpu_pulse>
  chMtxUnlock(&m1);
    42d4:	e1a00005 	mov	r0, r5
    42d8:	ebfff788 	bl	2100 <chMtxUnlock>
  test_cpu_pulse(10);
    42dc:	e3a0000a 	mov	r0, #10
    42e0:	ebfff146 	bl	800 <test_cpu_pulse>
  chMtxUnlock(&m2);
    42e4:	e1a00004 	mov	r0, r4
    42e8:	ebfff784 	bl	2100 <chMtxUnlock>
  test_emit_token('D');
    42ec:	e3a00044 	mov	r0, #68	; 0x44
}
    42f0:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_emit_token('D');
    42f4:	eafff1b9 	b	9e0 <test_emit_token>
    42f8:	40000a9c 	.word	0x40000a9c
    42fc:	40000a8c 	.word	0x40000a8c

00004300 <thread3M>:
static THD_FUNCTION(thread3M, p) {
    4300:	e92d4010 	push	{r4, lr}
  chMtxLock(&m2);
    4304:	e59f4028 	ldr	r4, [pc, #40]	; 4334 <thread3M+0x34>
  chThdSleepMilliseconds(20);
    4308:	e3a00014 	mov	r0, #20
    430c:	ebfffc63 	bl	34a0 <chThdSleep>
  chMtxLock(&m2);
    4310:	e1a00004 	mov	r0, r4
    4314:	ebfffed1 	bl	3e60 <chMtxLock>
  test_cpu_pulse(10);
    4318:	e3a0000a 	mov	r0, #10
    431c:	ebfff137 	bl	800 <test_cpu_pulse>
  chMtxUnlock(&m2);
    4320:	e1a00004 	mov	r0, r4
    4324:	ebfff775 	bl	2100 <chMtxUnlock>
  test_emit_token('C');
    4328:	e3a00043 	mov	r0, #67	; 0x43
}
    432c:	e8bd4010 	pop	{r4, lr}
  test_emit_token('C');
    4330:	eafff1aa 	b	9e0 <test_emit_token>
    4334:	40000a9c 	.word	0x40000a9c
	...

00004340 <thread3HH>:
static THD_FUNCTION(thread3HH, p) {
    4340:	e92d4010 	push	{r4, lr}
  chMtxLock(&m2);
    4344:	e59f4028 	ldr	r4, [pc, #40]	; 4374 <thread3HH+0x34>
  chThdSleepMilliseconds(50);
    4348:	e3a00032 	mov	r0, #50	; 0x32
    434c:	ebfffc53 	bl	34a0 <chThdSleep>
  chMtxLock(&m2);
    4350:	e1a00004 	mov	r0, r4
    4354:	ebfffec1 	bl	3e60 <chMtxLock>
  test_cpu_pulse(10);
    4358:	e3a0000a 	mov	r0, #10
    435c:	ebfff127 	bl	800 <test_cpu_pulse>
  chMtxUnlock(&m2);
    4360:	e1a00004 	mov	r0, r4
    4364:	ebfff765 	bl	2100 <chMtxUnlock>
  test_emit_token('A');
    4368:	e3a00041 	mov	r0, #65	; 0x41
}
    436c:	e8bd4010 	pop	{r4, lr}
  test_emit_token('A');
    4370:	eafff19a 	b	9e0 <test_emit_token>
    4374:	40000a9c 	.word	0x40000a9c
	...

00004380 <thread2H>:
static THD_FUNCTION(thread2H, p) {
    4380:	e92d4010 	push	{r4, lr}
  chMtxLock(&m1);
    4384:	e59f4028 	ldr	r4, [pc, #40]	; 43b4 <thread2H+0x34>
  chThdSleepMilliseconds(40);
    4388:	e3a00028 	mov	r0, #40	; 0x28
    438c:	ebfffc43 	bl	34a0 <chThdSleep>
  chMtxLock(&m1);
    4390:	e1a00004 	mov	r0, r4
    4394:	ebfffeb1 	bl	3e60 <chMtxLock>
  test_cpu_pulse(10);
    4398:	e3a0000a 	mov	r0, #10
    439c:	ebfff117 	bl	800 <test_cpu_pulse>
  chMtxUnlock(&m1);
    43a0:	e1a00004 	mov	r0, r4
    43a4:	ebfff755 	bl	2100 <chMtxUnlock>
  test_emit_token('A');
    43a8:	e3a00041 	mov	r0, #65	; 0x41
}
    43ac:	e8bd4010 	pop	{r4, lr}
  test_emit_token('A');
    43b0:	eafff18a 	b	9e0 <test_emit_token>
    43b4:	40000a8c 	.word	0x40000a8c
	...

000043c0 <thread2L>:
static THD_FUNCTION(thread2L, p) {
    43c0:	e92d4010 	push	{r4, lr}
  chMtxLock(&m1);
    43c4:	e59f4028 	ldr	r4, [pc, #40]	; 43f4 <thread2L+0x34>
    43c8:	e1a00004 	mov	r0, r4
    43cc:	ebfffea3 	bl	3e60 <chMtxLock>
  test_cpu_pulse(40);
    43d0:	e3a00028 	mov	r0, #40	; 0x28
    43d4:	ebfff109 	bl	800 <test_cpu_pulse>
  chMtxUnlock(&m1);
    43d8:	e1a00004 	mov	r0, r4
    43dc:	ebfff747 	bl	2100 <chMtxUnlock>
  test_cpu_pulse(10);
    43e0:	e3a0000a 	mov	r0, #10
    43e4:	ebfff105 	bl	800 <test_cpu_pulse>
  test_emit_token('C');
    43e8:	e3a00043 	mov	r0, #67	; 0x43
}
    43ec:	e8bd4010 	pop	{r4, lr}
  test_emit_token('C');
    43f0:	eafff17a 	b	9e0 <test_emit_token>
    43f4:	40000a8c 	.word	0x40000a8c
	...

00004400 <thread1.lto_priv.63>:
static THD_FUNCTION(thread1, p) {
    4400:	e92d4070 	push	{r4, r5, r6, lr}
    4404:	e1a05000 	mov	r5, r0
  chMtxLock(&m1);
    4408:	e59f4018 	ldr	r4, [pc, #24]	; 4428 <thread1.lto_priv.63+0x28>
    440c:	e1a00004 	mov	r0, r4
    4410:	ebfffe92 	bl	3e60 <chMtxLock>
  test_emit_token(*(char *)p);
    4414:	e5d50000 	ldrb	r0, [r5]
    4418:	ebfff170 	bl	9e0 <test_emit_token>
  chMtxUnlock(&m1);
    441c:	e1a00004 	mov	r0, r4
}
    4420:	e8bd4070 	pop	{r4, r5, r6, lr}
  chMtxUnlock(&m1);
    4424:	eafff735 	b	2100 <chMtxUnlock>
    4428:	40000a8c 	.word	0x40000a8c
    442c:	00000000 	.word	0x00000000

00004430 <chHeapStatus>:
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
    heapp = &default_heap;
    4430:	e3500000 	cmp	r0, #0
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
    4434:	e92d4070 	push	{r4, r5, r6, lr}
    heapp = &default_heap;
    4438:	e59f405c 	ldr	r4, [pc, #92]	; 449c <chHeapStatus+0x6c>
    443c:	11a04000 	movne	r4, r0
  }

  H_LOCK(heapp);
    4440:	e2845010 	add	r5, r4, #16
    4444:	e1a00005 	mov	r0, r5
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
    4448:	e1a06001 	mov	r6, r1
  H_LOCK(heapp);
    444c:	ebfffe83 	bl	3e60 <chMtxLock>
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
    4450:	e5943008 	ldr	r3, [r4, #8]
    4454:	e3530000 	cmp	r3, #0
    4458:	0a00000c 	beq	4490 <chHeapStatus+0x60>
  sz = 0;
    445c:	e3a02000 	mov	r2, #0
  n = 0;
    4460:	e1a04002 	mov	r4, r2
    sz += qp->h.u.next->h.size;
    4464:	e5930004 	ldr	r0, [r3, #4]
  while (qp->h.u.next != NULL) {
    4468:	e5933000 	ldr	r3, [r3]
    446c:	e3530000 	cmp	r3, #0
    n++;
    4470:	e2844001 	add	r4, r4, #1
    sz += qp->h.u.next->h.size;
    4474:	e0822000 	add	r2, r2, r0
  while (qp->h.u.next != NULL) {
    4478:	1afffff9 	bne	4464 <chHeapStatus+0x34>
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
    *sizep = sz;
  }
  H_UNLOCK(heapp);
    447c:	e1a00005 	mov	r0, r5
    *sizep = sz;
    4480:	e5862000 	str	r2, [r6]
  H_UNLOCK(heapp);
    4484:	ebfff71d 	bl	2100 <chMtxUnlock>

  return n;
}
    4488:	e1a00004 	mov	r0, r4
    448c:	e8bd8070 	pop	{r4, r5, r6, pc}
  sz = 0;
    4490:	e1a02003 	mov	r2, r3
  n = 0;
    4494:	e1a04003 	mov	r4, r3
    4498:	eafffff7 	b	447c <chHeapStatus+0x4c>
    449c:	40000d50 	.word	0x40000d50

000044a0 <chHeapFree>:
void chHeapFree(void *p) {
    44a0:	e92d4070 	push	{r4, r5, r6, lr}
    44a4:	e1a05000 	mov	r5, r0
  heapp = hp->h.u.heap;
    44a8:	e5104008 	ldr	r4, [r0, #-8]
  H_LOCK(heapp);
    44ac:	e2846010 	add	r6, r4, #16
    44b0:	e1a00006 	mov	r0, r6
  qp = &heapp->h_free;
    44b4:	e2844008 	add	r4, r4, #8
  H_LOCK(heapp);
    44b8:	ebfffe68 	bl	3e60 <chMtxLock>
  hp = (union heap_header *)p - 1;
    44bc:	e2451008 	sub	r1, r5, #8
  qp = &heapp->h_free;
    44c0:	e1a03004 	mov	r3, r4
    44c4:	ea000002 	b	44d4 <chHeapFree+0x34>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
    44c8:	e1510002 	cmp	r1, r2
    44cc:	3a00000a 	bcc	44fc <chHeapFree+0x5c>
void chHeapFree(void *p) {
    44d0:	e1a03002 	mov	r3, r2
    if (((qp == &heapp->h_free) || (hp > qp)) &&
    44d4:	e0430004 	sub	r0, r3, r4
    44d8:	e2702000 	rsbs	r2, r0, #0
    44dc:	e0a22000 	adc	r2, r2, r0
    44e0:	e1530001 	cmp	r3, r1
    44e4:	33822001 	orrcc	r2, r2, #1
    44e8:	e3520000 	cmp	r2, #0
    44ec:	e5932000 	ldr	r2, [r3]
    44f0:	0afffff6 	beq	44d0 <chHeapFree+0x30>
    44f4:	e3520000 	cmp	r2, #0
    44f8:	1afffff2 	bne	44c8 <chHeapFree+0x28>
      hp->h.u.next = qp->h.u.next;
    44fc:	e5052008 	str	r2, [r5, #-8]
      qp->h.u.next = hp;
    4500:	e5831000 	str	r1, [r3]
      if (LIMIT(hp) == hp->h.u.next) {
    4504:	e5152004 	ldr	r2, [r5, #-4]
    4508:	e515c008 	ldr	ip, [r5, #-8]
    450c:	e0850002 	add	r0, r5, r2
    4510:	e150000c 	cmp	r0, ip
    4514:	0a00000b 	beq	4548 <chHeapFree+0xa8>
      if ((LIMIT(qp) == hp)) {
    4518:	e5930004 	ldr	r0, [r3, #4]
    451c:	e2802008 	add	r2, r0, #8
    4520:	e0832002 	add	r2, r3, r2
    4524:	e1510002 	cmp	r1, r2
        qp->h.u.next = hp->h.u.next;
    4528:	09150006 	ldmdbeq	r5, {r1, r2}
        qp->h.size += hp->h.size + sizeof(union heap_header);
    452c:	02822008 	addeq	r2, r2, #8
    4530:	00820000 	addeq	r0, r2, r0
    4534:	05830004 	streq	r0, [r3, #4]
        qp->h.u.next = hp->h.u.next;
    4538:	05831000 	streq	r1, [r3]
  H_UNLOCK(heapp);
    453c:	e1a00006 	mov	r0, r6
}
    4540:	e8bd4070 	pop	{r4, r5, r6, lr}
  H_UNLOCK(heapp);
    4544:	eafff6ed 	b	2100 <chMtxUnlock>
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
    4548:	e5900004 	ldr	r0, [r0, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
    454c:	e795c002 	ldr	ip, [r5, r2]
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
    4550:	e282e008 	add	lr, r2, #8
    4554:	e080200e 	add	r2, r0, lr
    4558:	e5052004 	str	r2, [r5, #-4]
        hp->h.u.next = hp->h.u.next->h.u.next;
    455c:	e505c008 	str	ip, [r5, #-8]
    4560:	eaffffec 	b	4518 <chHeapFree+0x78>
	...

00004570 <chThdRelease>:
void chThdRelease(thread_t *tp) {
    4570:	e1a02000 	mov	r2, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4574:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  tp->p_refs--;
    4578:	e5d0301e 	ldrb	r3, [r0, #30]
    457c:	e2433001 	sub	r3, r3, #1
    4580:	e20330ff 	and	r3, r3, #255	; 0xff
    4584:	e5c0301e 	strb	r3, [r0, #30]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4588:	e321f01f 	msr	CPSR_c, #31
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    458c:	e3530000 	cmp	r3, #0
    4590:	112fff1e 	bxne	lr
    4594:	e5d0301c 	ldrb	r3, [r0, #28]
    4598:	e353000f 	cmp	r3, #15
    459c:	112fff1e 	bxne	lr
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
    45a0:	e5d0301d 	ldrb	r3, [r0, #29]
    45a4:	e2033003 	and	r3, r3, #3
    45a8:	e3530001 	cmp	r3, #1
    45ac:	0a00000d 	beq	45e8 <chThdRelease+0x78>
    45b0:	e3530002 	cmp	r3, #2
    45b4:	112fff1e 	bxne	lr
      REG_REMOVE(tp);
    45b8:	e5901014 	ldr	r1, [r0, #20]
    45bc:	e5903010 	ldr	r3, [r0, #16]
    45c0:	e5813010 	str	r3, [r1, #16]
    45c4:	e5900010 	ldr	r0, [r0, #16]
      chPoolFree(tp->p_mpool, tp);
    45c8:	e5923044 	ldr	r3, [r2, #68]	; 0x44
      REG_REMOVE(tp);
    45cc:	e5801014 	str	r1, [r0, #20]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    45d0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  php->ph_next = mp->mp_next;
    45d4:	e5931000 	ldr	r1, [r3]
    45d8:	e5821000 	str	r1, [r2]
  mp->mp_next = php;
    45dc:	e5832000 	str	r2, [r3]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    45e0:	e321f01f 	msr	CPSR_c, #31
}
    45e4:	e12fff1e 	bx	lr
      REG_REMOVE(tp);
    45e8:	e2801010 	add	r1, r0, #16
    45ec:	e891000a 	ldm	r1, {r1, r3}
    45f0:	e5831010 	str	r1, [r3, #16]
    45f4:	e5902010 	ldr	r2, [r0, #16]
    45f8:	e5823014 	str	r3, [r2, #20]
      chHeapFree(tp);
    45fc:	eaffffa7 	b	44a0 <chHeapFree>

00004600 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
    4600:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    4604:	e1a07000 	mov	r7, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4608:	e321f09f 	msr	CPSR_c, #159	; 0x9f
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
    460c:	e59f607c 	ldr	r6, [pc, #124]	; 4690 <regfind+0x90>
    4610:	e5960010 	ldr	r0, [r6, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
    4614:	e5d0301e 	ldrb	r3, [r0, #30]
    4618:	e2833001 	add	r3, r3, #1
    461c:	e5c0301e 	strb	r3, [r0, #30]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4620:	e321f01f 	msr	CPSR_c, #31
  thread_t *ftp;
  bool found = false;

  ftp = chRegFirstThread();
  do {
    found |= ftp == tp;
    4624:	e0473000 	sub	r3, r7, r0
    4628:	e2735000 	rsbs	r5, r3, #0
    462c:	e0a55003 	adc	r5, r5, r3
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4630:	e321f09f 	msr	CPSR_c, #159	; 0x9f
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
    4634:	e5904010 	ldr	r4, [r0, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
    4638:	e1540006 	cmp	r4, r6
    463c:	01a04000 	moveq	r4, r0
    4640:	1a000001 	bne	464c <regfind+0x4c>
    4644:	ea00000c 	b	467c <regfind+0x7c>
    4648:	e1a04003 	mov	r4, r3
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
    464c:	e5d4301e 	ldrb	r3, [r4, #30]
    4650:	e2833001 	add	r3, r3, #1
    4654:	e5c4301e 	strb	r3, [r4, #30]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4658:	e321f01f 	msr	CPSR_c, #31
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
    465c:	ebffffc3 	bl	4570 <chThdRelease>
    4660:	e1570004 	cmp	r7, r4
    4664:	03855001 	orreq	r5, r5, #1
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4668:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  ntp = tp->p_newer;
    466c:	e5943010 	ldr	r3, [r4, #16]
  if (ntp == (thread_t *)&ch.rlist) {
    4670:	e1530006 	cmp	r3, r6
    4674:	e1a00004 	mov	r0, r4
    4678:	1afffff2 	bne	4648 <regfind+0x48>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    467c:	e321f01f 	msr	CPSR_c, #31
  chThdRelease(tp);
    4680:	e1a00004 	mov	r0, r4
    4684:	ebffffb9 	bl	4570 <chThdRelease>
    ftp = chRegNextThread(ftp);
  } while (ftp != NULL);
  return found;
}
    4688:	e1a00005 	mov	r0, r5
    468c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    4690:	40000c00 	.word	0x40000c00
	...

000046a0 <chHeapAlloc>:
    heapp = &default_heap;
    46a0:	e3500000 	cmp	r0, #0
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
    46a4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    heapp = &default_heap;
    46a8:	e59f60c0 	ldr	r6, [pc, #192]	; 4770 <chHeapAlloc+0xd0>
    46ac:	11a06000 	movne	r6, r0
  H_LOCK(heapp);
    46b0:	e2867010 	add	r7, r6, #16
  size = MEM_ALIGN_NEXT(size);
    46b4:	e2811007 	add	r1, r1, #7
  H_LOCK(heapp);
    46b8:	e1a00007 	mov	r0, r7
  size = MEM_ALIGN_NEXT(size);
    46bc:	e3c15007 	bic	r5, r1, #7
  qp = &heapp->h_free;
    46c0:	e2864008 	add	r4, r6, #8
  H_LOCK(heapp);
    46c4:	ebfffde5 	bl	3e60 <chMtxLock>
    46c8:	ea000003 	b	46dc <chHeapAlloc+0x3c>
    if (hp->h.size >= size) {
    46cc:	e5903004 	ldr	r3, [r0, #4]
    46d0:	e1530005 	cmp	r3, r5
    46d4:	2a000012 	bcs	4724 <chHeapAlloc+0x84>
    46d8:	e1a04000 	mov	r4, r0
  while (qp->h.u.next != NULL) {
    46dc:	e5940000 	ldr	r0, [r4]
    46e0:	e3500000 	cmp	r0, #0
    46e4:	1afffff8 	bne	46cc <chHeapAlloc+0x2c>
  H_UNLOCK(heapp);
    46e8:	e1a00007 	mov	r0, r7
    46ec:	ebfff683 	bl	2100 <chMtxUnlock>
  if (heapp->h_provider != NULL) {
    46f0:	e5963000 	ldr	r3, [r6]
    46f4:	e3530000 	cmp	r3, #0
    46f8:	0a00001a 	beq	4768 <chHeapAlloc+0xc8>
    hp = heapp->h_provider(size + sizeof(union heap_header));
    46fc:	e2850008 	add	r0, r5, #8
    4700:	e1a0e00f 	mov	lr, pc
    4704:	e12fff13 	bx	r3
    if (hp != NULL) {
    4708:	e3500000 	cmp	r0, #0
    470c:	0a000015 	beq	4768 <chHeapAlloc+0xc8>
      hp->h.u.heap = heapp;
    4710:	e5806000 	str	r6, [r0]
      hp->h.size = size;
    4714:	e5805004 	str	r5, [r0, #4]
      hp++;
    4718:	e2804008 	add	r4, r0, #8
}
    471c:	e1a00004 	mov	r0, r4
    4720:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
      if (hp->h.size < (size + sizeof(union heap_header))) {
    4724:	e2852008 	add	r2, r5, #8
    4728:	e1530002 	cmp	r3, r2
    472c:	e5901000 	ldr	r1, [r0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
    4730:	20433005 	subcs	r3, r3, r5
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
    4734:	2080c002 	addcs	ip, r0, r2
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
    4738:	22433008 	subcs	r3, r3, #8
        fp->h.u.next = hp->h.u.next;
    473c:	27801002 	strcs	r1, [r0, r2]
        qp->h.u.next = hp->h.u.next;
    4740:	35841000 	strcc	r1, [r4]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
    4744:	258c3004 	strcs	r3, [ip, #4]
        qp->h.u.next = fp;
    4748:	2584c000 	strcs	ip, [r4]
      hp->h.u.heap = heapp;
    474c:	e1a04000 	mov	r4, r0
        hp->h.size = size;
    4750:	25805004 	strcs	r5, [r0, #4]
      hp->h.u.heap = heapp;
    4754:	e4846008 	str	r6, [r4], #8
      H_UNLOCK(heapp);
    4758:	e1a00007 	mov	r0, r7
    475c:	ebfff667 	bl	2100 <chMtxUnlock>
}
    4760:	e1a00004 	mov	r0, r4
    4764:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  return NULL;
    4768:	e3a04000 	mov	r4, #0
    476c:	eaffffea 	b	471c <chHeapAlloc+0x7c>
    4770:	40000d50 	.word	0x40000d50
	...

00004780 <chThdCreateFromHeap.constprop.49>:
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
    4780:	e92d4070 	push	{r4, r5, r6, lr}
    4784:	e1a05000 	mov	r5, r0
    4788:	e1a06001 	mov	r6, r1
  wsp = chHeapAlloc(heapp, size);
    478c:	e59f0098 	ldr	r0, [pc, #152]	; 482c <chThdCreateFromHeap.constprop.49+0xac>
    4790:	e3a01e13 	mov	r1, #304	; 0x130
    4794:	ebffffc1 	bl	46a0 <chHeapAlloc>
  if (wsp == NULL) {
    4798:	e2504000 	subs	r4, r0, #0
    479c:	0a000020 	beq	4824 <chThdCreateFromHeap.constprop.49+0xa4>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    47a0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  tp->p_state = CH_STATE_WTSTART;
    47a4:	e3a03002 	mov	r3, #2
  tp->p_mtxlist = NULL;
    47a8:	e3a01000 	mov	r1, #0
  tp->p_refs = (trefs_t)1;
    47ac:	e3a0e001 	mov	lr, #1
  REG_INSERT(tp);
    47b0:	e59f2078 	ldr	r2, [pc, #120]	; 4830 <chThdCreateFromHeap.constprop.49+0xb0>
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    47b4:	e284cf43 	add	ip, r4, #268	; 0x10c
  REG_INSERT(tp);
    47b8:	e5842010 	str	r2, [r4, #16]
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    47bc:	e584c00c 	str	ip, [r4, #12]
    47c0:	e59fc06c 	ldr	ip, [pc, #108]	; 4834 <chThdCreateFromHeap.constprop.49+0xb4>
  tp->p_prio = prio;
    47c4:	e5845008 	str	r5, [r4, #8]
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    47c8:	e5846110 	str	r6, [r4, #272]	; 0x110
  tp->p_realprio = prio;
    47cc:	e5845040 	str	r5, [r4, #64]	; 0x40
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    47d0:	e59f6060 	ldr	r6, [pc, #96]	; 4838 <chThdCreateFromHeap.constprop.49+0xb8>
  REG_INSERT(tp);
    47d4:	e5925014 	ldr	r5, [r2, #20]
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    47d8:	e584c12c 	str	ip, [r4, #300]	; 0x12c
  tp->p_state = CH_STATE_WTSTART;
    47dc:	e5c4301c 	strb	r3, [r4, #28]
  list_init(&tp->p_waiting);
    47e0:	e284c028 	add	ip, r4, #40	; 0x28
  queue_init(&tp->p_msgqueue);
    47e4:	e284302c 	add	r3, r4, #44	; 0x2c
  REG_INSERT(tp);
    47e8:	e5845014 	str	r5, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    47ec:	e584610c 	str	r6, [r4, #268]	; 0x10c
  tp->p_mtxlist = NULL;
    47f0:	e584103c 	str	r1, [r4, #60]	; 0x3c
  tp->p_epending = (eventmask_t)0;
    47f4:	e5841038 	str	r1, [r4, #56]	; 0x38
  tp->p_time = (systime_t)0;
    47f8:	e5841020 	str	r1, [r4, #32]
  tp->p_name = NULL;
    47fc:	e5841018 	str	r1, [r4, #24]
  tp->p_refs = (trefs_t)1;
    4800:	e5c4e01e 	strb	lr, [r4, #30]
  REG_INSERT(tp);
    4804:	e5854010 	str	r4, [r5, #16]
  tlp->p_next = (thread_t *)tlp;
    4808:	e584c028 	str	ip, [r4, #40]	; 0x28
  tp->p_flags = CH_FLAG_MODE_HEAP;
    480c:	e5c4e01d 	strb	lr, [r4, #29]
  tqp->p_next = (thread_t *)tqp;
    4810:	e584302c 	str	r3, [r4, #44]	; 0x2c
  tqp->p_prev = (thread_t *)tqp;
    4814:	e5843030 	str	r3, [r4, #48]	; 0x30
    4818:	e5824014 	str	r4, [r2, #20]
  chSchWakeupS(tp, MSG_OK);
    481c:	ebfff5c7 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4820:	e321f01f 	msr	CPSR_c, #31
}
    4824:	e1a00004 	mov	r0, r4
    4828:	e8bd8070 	pop	{r4, r5, r6, pc}
    482c:	40000d78 	.word	0x40000d78
    4830:	40000c00 	.word	0x40000c00
    4834:	00000180 	.word	0x00000180
    4838:	00000a50 	.word	0x00000a50
    483c:	00000000 	.word	0x00000000

00004840 <dyn3_execute>:
  return ch.rlist.r_current;
    4840:	e59f31a4 	ldr	r3, [pc, #420]	; 49ec <dyn3_execute+0x1ac>
  return chThdGetSelfX()->p_prio;
    4844:	e5933018 	ldr	r3, [r3, #24]
static void dyn3_execute(void) {
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
    4848:	e5930008 	ldr	r0, [r3, #8]
static void dyn3_execute(void) {
    484c:	e92d4010 	push	{r4, lr}
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
    4850:	e59f1198 	ldr	r1, [pc, #408]	; 49f0 <dyn3_execute+0x1b0>
    4854:	e2400001 	sub	r0, r0, #1
    4858:	ebffffc8 	bl	4780 <chThdCreateFromHeap.constprop.49>
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
    485c:	e5d0101e 	ldrb	r1, [r0, #30]
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
    4860:	e1a04000 	mov	r4, r0
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
    4864:	e3a00001 	mov	r0, #1
    4868:	e041e000 	sub	lr, r1, r0
    486c:	e27e1000 	rsbs	r1, lr, #0
    4870:	e0a1100e 	adc	r1, r1, lr
    4874:	ebfff049 	bl	9a0 <_test_assert>
    4878:	e3500000 	cmp	r0, #0
    487c:	18bd8010 	popne	{r4, pc}
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4880:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  tp->p_refs++;
    4884:	e5d4301e 	ldrb	r3, [r4, #30]
    4888:	e2833001 	add	r3, r3, #1
    488c:	e5c4301e 	strb	r3, [r4, #30]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4890:	e321f01f 	msr	CPSR_c, #31
  chThdAddRef(tp);
  test_assert(2, tp->p_refs == 2, "references increase failure");
    4894:	e3a00002 	mov	r0, #2
    4898:	e5d4101e 	ldrb	r1, [r4, #30]
    489c:	e041c000 	sub	ip, r1, r0
    48a0:	e27c1000 	rsbs	r1, ip, #0
    48a4:	e0a1100c 	adc	r1, r1, ip
    48a8:	ebfff03c 	bl	9a0 <_test_assert>
    48ac:	e3500000 	cmp	r0, #0
    48b0:	18bd8010 	popne	{r4, pc}
  chThdRelease(tp);
    48b4:	e1a00004 	mov	r0, r4
    48b8:	ebffff2c 	bl	4570 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
    48bc:	e5d4101e 	ldrb	r1, [r4, #30]
    48c0:	e2412001 	sub	r2, r1, #1
    48c4:	e2721000 	rsbs	r1, r2, #0
    48c8:	e0a11002 	adc	r1, r1, r2
    48cc:	e3a00003 	mov	r0, #3
    48d0:	ebfff032 	bl	9a0 <_test_assert>
    48d4:	e3500000 	cmp	r0, #0
    48d8:	18bd8010 	popne	{r4, pc}

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
    48dc:	e1a00004 	mov	r0, r4
    48e0:	ebffff46 	bl	4600 <regfind>
    48e4:	e1a01000 	mov	r1, r0
    48e8:	e3a00004 	mov	r0, #4
    48ec:	ebfff02b 	bl	9a0 <_test_assert>
    48f0:	e3500000 	cmp	r0, #0
    48f4:	18bd8010 	popne	{r4, pc}
  test_assert(5, regfind(tp), "thread disappeared");
    48f8:	e1a00004 	mov	r0, r4
    48fc:	ebffff3f 	bl	4600 <regfind>
    4900:	e1a01000 	mov	r1, r0
    4904:	e3a00005 	mov	r0, #5
    4908:	ebfff024 	bl	9a0 <_test_assert>
    490c:	e3500000 	cmp	r0, #0
    4910:	18bd8010 	popne	{r4, pc}

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
    4914:	e1a00004 	mov	r0, r4
    4918:	ebffff14 	bl	4570 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
    491c:	e5d4101e 	ldrb	r1, [r4, #30]
    4920:	e2711001 	rsbs	r1, r1, #1
    4924:	33a01000 	movcc	r1, #0
    4928:	e3a00006 	mov	r0, #6
    492c:	ebfff01b 	bl	9a0 <_test_assert>
    4930:	e3500000 	cmp	r0, #0
    4934:	18bd8010 	popne	{r4, pc}
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
    4938:	e5d4101c 	ldrb	r1, [r4, #28]
    493c:	e2711001 	rsbs	r1, r1, #1
    4940:	33a01000 	movcc	r1, #0
    4944:	e3a00007 	mov	r0, #7
    4948:	ebfff014 	bl	9a0 <_test_assert>
    494c:	e3500000 	cmp	r0, #0
    4950:	18bd8010 	popne	{r4, pc}
  test_assert(8, regfind(tp), "thread disappeared");
    4954:	e1a00004 	mov	r0, r4
    4958:	ebffff28 	bl	4600 <regfind>
    495c:	e1a01000 	mov	r1, r0
    4960:	e3a00008 	mov	r0, #8
    4964:	ebfff00d 	bl	9a0 <_test_assert>
    4968:	e3500000 	cmp	r0, #0
    496c:	18bd8010 	popne	{r4, pc}
  test_assert(9, regfind(tp), "thread disappeared");
    4970:	e1a00004 	mov	r0, r4
    4974:	ebffff21 	bl	4600 <regfind>
    4978:	e1a01000 	mov	r1, r0
    497c:	e3a00009 	mov	r0, #9
    4980:	ebfff006 	bl	9a0 <_test_assert>
    4984:	e3500000 	cmp	r0, #0
    4988:	18bd8010 	popne	{r4, pc}
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
    498c:	e3a00032 	mov	r0, #50	; 0x32
    4990:	ebfffac2 	bl	34a0 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
    4994:	e5d4101c 	ldrb	r1, [r4, #28]
    4998:	e241300f 	sub	r3, r1, #15
    499c:	e2731000 	rsbs	r1, r3, #0
    49a0:	e0a11003 	adc	r1, r1, r3
    49a4:	e3a0000a 	mov	r0, #10
    49a8:	ebffeffc 	bl	9a0 <_test_assert>
    49ac:	e3500000 	cmp	r0, #0
    49b0:	18bd8010 	popne	{r4, pc}

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
    49b4:	e1a00004 	mov	r0, r4
    49b8:	ebffff10 	bl	4600 <regfind>
    49bc:	e1a01000 	mov	r1, r0
    49c0:	e3a0000b 	mov	r0, #11
    49c4:	ebffeff5 	bl	9a0 <_test_assert>
    49c8:	e3500000 	cmp	r0, #0
    49cc:	18bd8010 	popne	{r4, pc}
  test_assert(12, !regfind(tp), "thread still in registry");
    49d0:	e1a00004 	mov	r0, r4
    49d4:	ebffff09 	bl	4600 <regfind>
    49d8:	e2201001 	eor	r1, r0, #1
    49dc:	e20110ff 	and	r1, r1, #255	; 0xff
    49e0:	e3a0000c 	mov	r0, #12
}
    49e4:	e8bd4010 	pop	{r4, lr}
  test_assert(12, !regfind(tp), "thread still in registry");
    49e8:	eaffefec 	b	9a0 <_test_assert>
    49ec:	40000c00 	.word	0x40000c00
    49f0:	000081a0 	.word	0x000081a0
	...

00004a00 <heap1_execute>:

static void heap1_execute(void) {
    4a00:	e92d4070 	push	{r4, r5, r6, lr}
    4a04:	e24dd008 	sub	sp, sp, #8

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
    4a08:	e1a0100d 	mov	r1, sp
    4a0c:	e3a00000 	mov	r0, #0
    4a10:	ebfffe86 	bl	4430 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
    4a14:	e3a01010 	mov	r1, #16
    4a18:	e3a00000 	mov	r0, #0
    4a1c:	ebffff1f 	bl	46a0 <chHeapAlloc>
  test_assert(1, p1 != NULL, "allocation failed");
    4a20:	e2901000 	adds	r1, r0, #0
    4a24:	13a01001 	movne	r1, #1
    4a28:	e1a04000 	mov	r4, r0
    4a2c:	e3a00001 	mov	r0, #1
    4a30:	ebffefda 	bl	9a0 <_test_assert>
    4a34:	e2505000 	subs	r5, r0, #0
    4a38:	0a000001 	beq	4a44 <heap1_execute+0x44>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
  chHeapFree(p1);

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
  test_assert(12, n == sz, "size changed");
}
    4a3c:	e28dd008 	add	sp, sp, #8
    4a40:	e8bd8070 	pop	{r4, r5, r6, pc}
  chHeapFree(p1);
    4a44:	e1a00004 	mov	r0, r4
    4a48:	ebfffe94 	bl	44a0 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
    4a4c:	e3e010ff 	mvn	r1, #255	; 0xff
    4a50:	e1a00005 	mov	r0, r5
    4a54:	ebffff11 	bl	46a0 <chHeapAlloc>
  test_assert(2, p1 == NULL, "allocation not failed");
    4a58:	e2701001 	rsbs	r1, r0, #1
    4a5c:	33a01000 	movcc	r1, #0
    4a60:	e3a00002 	mov	r0, #2
    4a64:	ebffefcd 	bl	9a0 <_test_assert>
    4a68:	e3500000 	cmp	r0, #0
    4a6c:	1afffff2 	bne	4a3c <heap1_execute+0x3c>
  (void)chHeapStatus(&test_heap, &sz);
    4a70:	e1a0100d 	mov	r1, sp
    4a74:	e59f02d0 	ldr	r0, [pc, #720]	; 4d4c <heap1_execute+0x34c>
    4a78:	ebfffe6c 	bl	4430 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, SIZE);
    4a7c:	e3a01010 	mov	r1, #16
    4a80:	e59f02c4 	ldr	r0, [pc, #708]	; 4d4c <heap1_execute+0x34c>
    4a84:	ebffff05 	bl	46a0 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
    4a88:	e3a01010 	mov	r1, #16
  p1 = chHeapAlloc(&test_heap, SIZE);
    4a8c:	e1a06000 	mov	r6, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
    4a90:	e59f02b4 	ldr	r0, [pc, #692]	; 4d4c <heap1_execute+0x34c>
    4a94:	ebffff01 	bl	46a0 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
    4a98:	e3a01010 	mov	r1, #16
  p2 = chHeapAlloc(&test_heap, SIZE);
    4a9c:	e1a05000 	mov	r5, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
    4aa0:	e59f02a4 	ldr	r0, [pc, #676]	; 4d4c <heap1_execute+0x34c>
    4aa4:	ebfffefd 	bl	46a0 <chHeapAlloc>
    4aa8:	e1a04000 	mov	r4, r0
  chHeapFree(p1);                               /* Does not merge.*/
    4aac:	e1a00006 	mov	r0, r6
    4ab0:	ebfffe7a 	bl	44a0 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
    4ab4:	e1a00005 	mov	r0, r5
    4ab8:	ebfffe78 	bl	44a0 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
    4abc:	e1a00004 	mov	r0, r4
    4ac0:	ebfffe76 	bl	44a0 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
    4ac4:	e28d1004 	add	r1, sp, #4
    4ac8:	e59f027c 	ldr	r0, [pc, #636]	; 4d4c <heap1_execute+0x34c>
    4acc:	ebfffe57 	bl	4430 <chHeapStatus>
    4ad0:	e2400001 	sub	r0, r0, #1
    4ad4:	e2701000 	rsbs	r1, r0, #0
    4ad8:	e0a11000 	adc	r1, r1, r0
    4adc:	e3a00003 	mov	r0, #3
    4ae0:	ebffefae 	bl	9a0 <_test_assert>
    4ae4:	e3500000 	cmp	r0, #0
    4ae8:	1affffd3 	bne	4a3c <heap1_execute+0x3c>
  p1 = chHeapAlloc(&test_heap, SIZE);
    4aec:	e3a01010 	mov	r1, #16
    4af0:	e59f0254 	ldr	r0, [pc, #596]	; 4d4c <heap1_execute+0x34c>
    4af4:	ebfffee9 	bl	46a0 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
    4af8:	e3a01010 	mov	r1, #16
  p1 = chHeapAlloc(&test_heap, SIZE);
    4afc:	e1a04000 	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
    4b00:	e59f0244 	ldr	r0, [pc, #580]	; 4d4c <heap1_execute+0x34c>
    4b04:	ebfffee5 	bl	46a0 <chHeapAlloc>
    4b08:	e1a05000 	mov	r5, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
    4b0c:	e3a01010 	mov	r1, #16
    4b10:	e59f0234 	ldr	r0, [pc, #564]	; 4d4c <heap1_execute+0x34c>
    4b14:	ebfffee1 	bl	46a0 <chHeapAlloc>
  chHeapFree(p3);                               /* Merges forward.*/
    4b18:	ebfffe60 	bl	44a0 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
    4b1c:	e1a00005 	mov	r0, r5
    4b20:	ebfffe5e 	bl	44a0 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
    4b24:	e1a00004 	mov	r0, r4
    4b28:	ebfffe5c 	bl	44a0 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
    4b2c:	e28d1004 	add	r1, sp, #4
    4b30:	e59f0214 	ldr	r0, [pc, #532]	; 4d4c <heap1_execute+0x34c>
    4b34:	ebfffe3d 	bl	4430 <chHeapStatus>
    4b38:	e2402001 	sub	r2, r0, #1
    4b3c:	e2721000 	rsbs	r1, r2, #0
    4b40:	e0a11002 	adc	r1, r1, r2
    4b44:	e3a00004 	mov	r0, #4
    4b48:	ebffef94 	bl	9a0 <_test_assert>
    4b4c:	e3500000 	cmp	r0, #0
    4b50:	1affffb9 	bne	4a3c <heap1_execute+0x3c>
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
    4b54:	e3a01011 	mov	r1, #17
    4b58:	e59f01ec 	ldr	r0, [pc, #492]	; 4d4c <heap1_execute+0x34c>
    4b5c:	ebfffecf 	bl	46a0 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
    4b60:	e3a01010 	mov	r1, #16
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
    4b64:	e1a04000 	mov	r4, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
    4b68:	e59f01dc 	ldr	r0, [pc, #476]	; 4d4c <heap1_execute+0x34c>
    4b6c:	ebfffecb 	bl	46a0 <chHeapAlloc>
    4b70:	e1a05000 	mov	r5, r0
  chHeapFree(p1);
    4b74:	e1a00004 	mov	r0, r4
    4b78:	ebfffe48 	bl	44a0 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
    4b7c:	e28d1004 	add	r1, sp, #4
    4b80:	e59f01c4 	ldr	r0, [pc, #452]	; 4d4c <heap1_execute+0x34c>
    4b84:	ebfffe29 	bl	4430 <chHeapStatus>
    4b88:	e2403002 	sub	r3, r0, #2
    4b8c:	e2731000 	rsbs	r1, r3, #0
    4b90:	e0a11003 	adc	r1, r1, r3
    4b94:	e3a00005 	mov	r0, #5
    4b98:	ebffef80 	bl	9a0 <_test_assert>
    4b9c:	e3500000 	cmp	r0, #0
    4ba0:	1affffa5 	bne	4a3c <heap1_execute+0x3c>
  p1 = chHeapAlloc(&test_heap, SIZE);
    4ba4:	e3a01010 	mov	r1, #16
    4ba8:	e59f019c 	ldr	r0, [pc, #412]	; 4d4c <heap1_execute+0x34c>
    4bac:	ebfffebb 	bl	46a0 <chHeapAlloc>
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
    4bb0:	e28d1004 	add	r1, sp, #4
  p1 = chHeapAlloc(&test_heap, SIZE);
    4bb4:	e1a04000 	mov	r4, r0
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
    4bb8:	e59f018c 	ldr	r0, [pc, #396]	; 4d4c <heap1_execute+0x34c>
    4bbc:	ebfffe1b 	bl	4430 <chHeapStatus>
    4bc0:	e3500001 	cmp	r0, #1
    4bc4:	01a01000 	moveq	r1, r0
    4bc8:	0a000005 	beq	4be4 <heap1_execute+0x1e4>
    4bcc:	e28d1004 	add	r1, sp, #4
    4bd0:	e59f0174 	ldr	r0, [pc, #372]	; 4d4c <heap1_execute+0x34c>
    4bd4:	ebfffe15 	bl	4430 <chHeapStatus>
    4bd8:	e2406002 	sub	r6, r0, #2
    4bdc:	e2761000 	rsbs	r1, r6, #0
    4be0:	e0a11006 	adc	r1, r1, r6
    4be4:	e3a00006 	mov	r0, #6
    4be8:	ebffef6c 	bl	9a0 <_test_assert>
    4bec:	e3500000 	cmp	r0, #0
    4bf0:	1affff91 	bne	4a3c <heap1_execute+0x3c>
  chHeapFree(p2);
    4bf4:	e1a00005 	mov	r0, r5
    4bf8:	ebfffe28 	bl	44a0 <chHeapFree>
  chHeapFree(p1);
    4bfc:	e1a00004 	mov	r0, r4
    4c00:	ebfffe26 	bl	44a0 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
    4c04:	e28d1004 	add	r1, sp, #4
    4c08:	e59f013c 	ldr	r0, [pc, #316]	; 4d4c <heap1_execute+0x34c>
    4c0c:	ebfffe07 	bl	4430 <chHeapStatus>
    4c10:	e240e001 	sub	lr, r0, #1
    4c14:	e27e1000 	rsbs	r1, lr, #0
    4c18:	e0a1100e 	adc	r1, r1, lr
    4c1c:	e3a00007 	mov	r0, #7
    4c20:	ebffef5e 	bl	9a0 <_test_assert>
    4c24:	e3500000 	cmp	r0, #0
    4c28:	1affff83 	bne	4a3c <heap1_execute+0x3c>
  p1 = chHeapAlloc(&test_heap, SIZE);
    4c2c:	e3a01010 	mov	r1, #16
    4c30:	e59f0114 	ldr	r0, [pc, #276]	; 4d4c <heap1_execute+0x34c>
    4c34:	ebfffe99 	bl	46a0 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
    4c38:	e3a01010 	mov	r1, #16
  p1 = chHeapAlloc(&test_heap, SIZE);
    4c3c:	e1a05000 	mov	r5, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
    4c40:	e59f0104 	ldr	r0, [pc, #260]	; 4d4c <heap1_execute+0x34c>
    4c44:	ebfffe95 	bl	46a0 <chHeapAlloc>
    4c48:	e1a04000 	mov	r4, r0
  chHeapFree(p1);
    4c4c:	e1a00005 	mov	r0, r5
    4c50:	ebfffe12 	bl	44a0 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
    4c54:	e28d1004 	add	r1, sp, #4
    4c58:	e59f00ec 	ldr	r0, [pc, #236]	; 4d4c <heap1_execute+0x34c>
    4c5c:	ebfffdf3 	bl	4430 <chHeapStatus>
    4c60:	e240c002 	sub	ip, r0, #2
    4c64:	e27c1000 	rsbs	r1, ip, #0
    4c68:	e0a1100c 	adc	r1, r1, ip
    4c6c:	e3a00008 	mov	r0, #8
    4c70:	ebffef4a 	bl	9a0 <_test_assert>
    4c74:	e3500000 	cmp	r0, #0
    4c78:	1affff6f 	bne	4a3c <heap1_execute+0x3c>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
    4c7c:	e3a01020 	mov	r1, #32
    4c80:	e59f00c4 	ldr	r0, [pc, #196]	; 4d4c <heap1_execute+0x34c>
    4c84:	ebfffe85 	bl	46a0 <chHeapAlloc>
  chHeapFree(p1);
    4c88:	ebfffe04 	bl	44a0 <chHeapFree>
  chHeapFree(p2);
    4c8c:	e1a00004 	mov	r0, r4
    4c90:	ebfffe02 	bl	44a0 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
    4c94:	e28d1004 	add	r1, sp, #4
    4c98:	e59f00ac 	ldr	r0, [pc, #172]	; 4d4c <heap1_execute+0x34c>
    4c9c:	ebfffde3 	bl	4430 <chHeapStatus>
    4ca0:	e2400001 	sub	r0, r0, #1
    4ca4:	e2701000 	rsbs	r1, r0, #0
    4ca8:	e0a11000 	adc	r1, r1, r0
    4cac:	e3a00009 	mov	r0, #9
    4cb0:	ebffef3a 	bl	9a0 <_test_assert>
    4cb4:	e3500000 	cmp	r0, #0
    4cb8:	1affff5f 	bne	4a3c <heap1_execute+0x3c>
  (void)chHeapStatus(&test_heap, &n);
    4cbc:	e28d1004 	add	r1, sp, #4
    4cc0:	e59f0084 	ldr	r0, [pc, #132]	; 4d4c <heap1_execute+0x34c>
    4cc4:	ebfffdd9 	bl	4430 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
    4cc8:	e59d1004 	ldr	r1, [sp, #4]
    4ccc:	e59f0078 	ldr	r0, [pc, #120]	; 4d4c <heap1_execute+0x34c>
    4cd0:	ebfffe72 	bl	46a0 <chHeapAlloc>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
    4cd4:	e28d1004 	add	r1, sp, #4
  p1 = chHeapAlloc(&test_heap, n);
    4cd8:	e1a04000 	mov	r4, r0
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
    4cdc:	e59f0068 	ldr	r0, [pc, #104]	; 4d4c <heap1_execute+0x34c>
    4ce0:	ebfffdd2 	bl	4430 <chHeapStatus>
    4ce4:	e2701001 	rsbs	r1, r0, #1
    4ce8:	33a01000 	movcc	r1, #0
    4cec:	e3a0000a 	mov	r0, #10
    4cf0:	ebffef2a 	bl	9a0 <_test_assert>
    4cf4:	e3500000 	cmp	r0, #0
    4cf8:	1affff4f 	bne	4a3c <heap1_execute+0x3c>
  chHeapFree(p1);
    4cfc:	e1a00004 	mov	r0, r4
    4d00:	ebfffde6 	bl	44a0 <chHeapFree>
  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
    4d04:	e28d1004 	add	r1, sp, #4
    4d08:	e59f003c 	ldr	r0, [pc, #60]	; 4d4c <heap1_execute+0x34c>
    4d0c:	ebfffdc7 	bl	4430 <chHeapStatus>
    4d10:	e2402001 	sub	r2, r0, #1
    4d14:	e2721000 	rsbs	r1, r2, #0
    4d18:	e0a11002 	adc	r1, r1, r2
    4d1c:	e3a0000b 	mov	r0, #11
    4d20:	ebffef1e 	bl	9a0 <_test_assert>
    4d24:	e3500000 	cmp	r0, #0
    4d28:	1affff43 	bne	4a3c <heap1_execute+0x3c>
  test_assert(12, n == sz, "size changed");
    4d2c:	e59d1004 	ldr	r1, [sp, #4]
    4d30:	e59d3000 	ldr	r3, [sp]
    4d34:	e0413003 	sub	r3, r1, r3
    4d38:	e2731000 	rsbs	r1, r3, #0
    4d3c:	e0a11003 	adc	r1, r1, r3
    4d40:	e3a0000c 	mov	r0, #12
    4d44:	ebffef15 	bl	9a0 <_test_assert>
    4d48:	eaffff3b 	b	4a3c <heap1_execute+0x3c>
    4d4c:	400013f8 	.word	0x400013f8

00004d50 <chSemWait>:
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4d50:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (--sp->s_cnt < (cnt_t)0) {
    4d54:	e5903008 	ldr	r3, [r0, #8]
    4d58:	e2433001 	sub	r3, r3, #1
    4d5c:	e3530000 	cmp	r3, #0
    4d60:	e5803008 	str	r3, [r0, #8]
    4d64:	ba000002 	blt	4d74 <chSemWait+0x24>
  return MSG_OK;
    4d68:	e3a00000 	mov	r0, #0
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4d6c:	e321f01f 	msr	CPSR_c, #31
}
    4d70:	e12fff1e 	bx	lr
    4d74:	e1a03000 	mov	r3, r0
msg_t chSemWait(semaphore_t *sp) {
    4d78:	e92d4010 	push	{r4, lr}
    currp->p_u.wtsemp = sp;
    4d7c:	e59f4030 	ldr	r4, [pc, #48]	; 4db4 <chSemWait+0x64>
    4d80:	e5942018 	ldr	r2, [r4, #24]
    4d84:	e5820024 	str	r0, [r2, #36]	; 0x24
  tp->p_next = (thread_t *)tqp;
    4d88:	e5820000 	str	r0, [r2]
  tp->p_prev = tqp->p_prev;
    4d8c:	e5901004 	ldr	r1, [r0, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
    4d90:	e3a00005 	mov	r0, #5
    4d94:	e5821004 	str	r1, [r2, #4]
  tp->p_prev->p_next = tp;
    4d98:	e5812000 	str	r2, [r1]
  tqp->p_prev = tp;
    4d9c:	e5832004 	str	r2, [r3, #4]
    4da0:	ebfff53a 	bl	2290 <chSchGoSleepS>
    return currp->p_u.rdymsg;
    4da4:	e5943018 	ldr	r3, [r4, #24]
    4da8:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    4dac:	e321f01f 	msr	CPSR_c, #31
}
    4db0:	e8bd8010 	pop	{r4, pc}
    4db4:	40000c00 	.word	0x40000c00
	...

00004dc0 <bmk11_execute>:
static void bmk11_execute(void) {
    4dc0:	e92d4070 	push	{r4, r5, r6, lr}
  test_wait_tick();
    4dc4:	ebfffa61 	bl	3750 <test_wait_tick>
  uint32_t n = 0;
    4dc8:	e3a05000 	mov	r5, #0
  test_start_timer(1000);
    4dcc:	ebfff253 	bl	1720 <test_start_timer.constprop.1>
    4dd0:	e59f606c 	ldr	r6, [pc, #108]	; 4e44 <bmk11_execute+0x84>
    chSemWait(&sem1);
    4dd4:	e59f406c 	ldr	r4, [pc, #108]	; 4e48 <bmk11_execute+0x88>
    4dd8:	e1a00004 	mov	r0, r4
    4ddc:	ebffffdb 	bl	4d50 <chSemWait>
    chSemSignal(&sem1);
    4de0:	e1a00004 	mov	r0, r4
    4de4:	ebfff4ed 	bl	21a0 <chSemSignal>
    chSemWait(&sem1);
    4de8:	e1a00004 	mov	r0, r4
    4dec:	ebffffd7 	bl	4d50 <chSemWait>
    chSemSignal(&sem1);
    4df0:	e1a00004 	mov	r0, r4
    4df4:	ebfff4e9 	bl	21a0 <chSemSignal>
    chSemWait(&sem1);
    4df8:	e1a00004 	mov	r0, r4
    4dfc:	ebffffd3 	bl	4d50 <chSemWait>
    chSemSignal(&sem1);
    4e00:	e1a00004 	mov	r0, r4
    4e04:	ebfff4e5 	bl	21a0 <chSemSignal>
    chSemWait(&sem1);
    4e08:	e1a00004 	mov	r0, r4
    4e0c:	ebffffcf 	bl	4d50 <chSemWait>
    chSemSignal(&sem1);
    4e10:	e1a00004 	mov	r0, r4
    4e14:	ebfff4e1 	bl	21a0 <chSemSignal>
  } while (!test_timer_done);
    4e18:	e5d63000 	ldrb	r3, [r6]
    4e1c:	e3530000 	cmp	r3, #0
    n++;
    4e20:	e2855001 	add	r5, r5, #1
  } while (!test_timer_done);
    4e24:	0affffeb 	beq	4dd8 <bmk11_execute+0x18>
  test_print("--- Score : ");
    4e28:	e59f001c 	ldr	r0, [pc, #28]	; 4e4c <bmk11_execute+0x8c>
    4e2c:	ebffef23 	bl	ac0 <test_print>
  test_printn(n * 4);
    4e30:	e1a00105 	lsl	r0, r5, #2
    4e34:	ebffee51 	bl	780 <test_printn>
  test_println(" wait+signal/S");
    4e38:	e59f0010 	ldr	r0, [pc, #16]	; 4e50 <bmk11_execute+0x90>
}
    4e3c:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_println(" wait+signal/S");
    4e40:	eaffef06 	b	a60 <test_println>
    4e44:	40001418 	.word	0x40001418
    4e48:	40000df0 	.word	0x40000df0
    4e4c:	00008010 	.word	0x00008010
    4e50:	00008030 	.word	0x00008030
	...

00004e60 <thread3.lto_priv.61>:
static THD_FUNCTION(thread3, p) {
    4e60:	e92d4070 	push	{r4, r5, r6, lr}
  return ch.rlist.r_current;
    4e64:	e59f402c 	ldr	r4, [pc, #44]	; 4e98 <thread3.lto_priv.61+0x38>
  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
    4e68:	e5943018 	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
    4e6c:	e5d3301d 	ldrb	r3, [r3, #29]
    4e70:	e3130004 	tst	r3, #4
    4e74:	18bd8070 	popne	{r4, r5, r6, pc}
    chSemWait(&sem1);
    4e78:	e59f501c 	ldr	r5, [pc, #28]	; 4e9c <thread3.lto_priv.61+0x3c>
    4e7c:	e1a00005 	mov	r0, r5
    4e80:	ebffffb2 	bl	4d50 <chSemWait>
    4e84:	e5943018 	ldr	r3, [r4, #24]
  while (!chThdShouldTerminateX())
    4e88:	e5d3301d 	ldrb	r3, [r3, #29]
    4e8c:	e3130004 	tst	r3, #4
    4e90:	0afffff9 	beq	4e7c <thread3.lto_priv.61+0x1c>
    4e94:	e8bd8070 	pop	{r4, r5, r6, pc}
    4e98:	40000c00 	.word	0x40000c00
    4e9c:	40000df0 	.word	0x40000df0

00004ea0 <sem4_execute>:
  sp->s_cnt = n;
    4ea0:	e3a01000 	mov	r1, #0

static void sem4_execute(void) {
    4ea4:	e92d4010 	push	{r4, lr}
    4ea8:	e24dd018 	sub	sp, sp, #24
  tqp->p_next = (thread_t *)tqp;
    4eac:	e28d400c 	add	r4, sp, #12
    4eb0:	e58d1014 	str	r1, [sp, #20]
    4eb4:	e58d400c 	str	r4, [sp, #12]
  tqp->p_prev = (thread_t *)tqp;
    4eb8:	e58d4010 	str	r4, [sp, #16]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4ebc:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chSemResetI(sp, n);
    4ec0:	e1a00004 	mov	r0, r4
    4ec4:	ebfff1d1 	bl	1610 <chSemResetI>
  chSchRescheduleS();
    4ec8:	ebfff344 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4ecc:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4ed0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
    4ed4:	e59d1014 	ldr	r1, [sp, #20]
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
    4ed8:	e3510000 	cmp	r1, #0
    4edc:	c3a01000 	movgt	r1, #0
    4ee0:	d3a01001 	movle	r1, #1
    4ee4:	e3a00001 	mov	r0, #1
    4ee8:	ebffeeac 	bl	9a0 <_test_assert>
    4eec:	e3500000 	cmp	r0, #0
    4ef0:	0a000002 	beq	4f00 <sem4_execute+0x60>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4ef4:	e321f01f 	msr	CPSR_c, #31

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
    4ef8:	e28dd018 	add	sp, sp, #24
    4efc:	e8bd8010 	pop	{r4, pc}
    4f00:	e321f01f 	msr	CPSR_c, #31
  return ch.rlist.r_current;
    4f04:	e59f3134 	ldr	r3, [pc, #308]	; 5040 <sem4_execute+0x1a0>
  return chThdGetSelfX()->p_prio;
    4f08:	e5933018 	ldr	r3, [r3, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
    4f0c:	e5932008 	ldr	r2, [r3, #8]
    4f10:	e3a01e13 	mov	r1, #304	; 0x130
    4f14:	e2422001 	sub	r2, r2, #1
    4f18:	e59f3124 	ldr	r3, [pc, #292]	; 5044 <sem4_execute+0x1a4>
    4f1c:	e58d4000 	str	r4, [sp]
    4f20:	e59f0120 	ldr	r0, [pc, #288]	; 5048 <sem4_execute+0x1a8>
    4f24:	ebfff4b1 	bl	21f0 <chThdCreateStatic>
    4f28:	e59f311c 	ldr	r3, [pc, #284]	; 504c <sem4_execute+0x1ac>
    4f2c:	e5830000 	str	r0, [r3]
  return chSemWait(&bsp->bs_sem);
    4f30:	e1a00004 	mov	r0, r4
    4f34:	ebffff85 	bl	4d50 <chSemWait>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4f38:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
    4f3c:	e59d1014 	ldr	r1, [sp, #20]
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
    4f40:	e3510000 	cmp	r1, #0
    4f44:	c3a01000 	movgt	r1, #0
    4f48:	d3a01001 	movle	r1, #1
    4f4c:	e3a00002 	mov	r0, #2
    4f50:	ebffee92 	bl	9a0 <_test_assert>
    4f54:	e3500000 	cmp	r0, #0
    4f58:	1affffe5 	bne	4ef4 <sem4_execute+0x54>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4f5c:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4f60:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    4f64:	e59d3014 	ldr	r3, [sp, #20]
    4f68:	e3530000 	cmp	r3, #0
    4f6c:	da00002d 	ble	5028 <sem4_execute+0x188>
  chSchRescheduleS();
    4f70:	ebfff31a 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4f74:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4f78:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
    4f7c:	e59d1014 	ldr	r1, [sp, #20]
    4f80:	e3510000 	cmp	r1, #0
    4f84:	d3a01000 	movle	r1, #0
    4f88:	c3a01001 	movgt	r1, #1
    4f8c:	e3a00003 	mov	r0, #3
    4f90:	ebffee82 	bl	9a0 <_test_assert>
    4f94:	e3500000 	cmp	r0, #0
    4f98:	1affffd5 	bne	4ef4 <sem4_execute+0x54>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4f9c:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4fa0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
    4fa4:	e59d1014 	ldr	r1, [sp, #20]
    4fa8:	e2412001 	sub	r2, r1, #1
    4fac:	e2721000 	rsbs	r1, r2, #0
    4fb0:	e0a11002 	adc	r1, r1, r2
    4fb4:	e3a00004 	mov	r0, #4
    4fb8:	ebffee78 	bl	9a0 <_test_assert>
    4fbc:	e3500000 	cmp	r0, #0
    4fc0:	1affffcb 	bne	4ef4 <sem4_execute+0x54>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4fc4:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4fc8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    4fcc:	e59d3014 	ldr	r3, [sp, #20]
    4fd0:	e3530000 	cmp	r3, #0
    4fd4:	da000016 	ble	5034 <sem4_execute+0x194>
  chSchRescheduleS();
    4fd8:	ebfff300 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    4fdc:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    4fe0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
    4fe4:	e59d1014 	ldr	r1, [sp, #20]
    4fe8:	e3510000 	cmp	r1, #0
    4fec:	d3a01000 	movle	r1, #0
    4ff0:	c3a01001 	movgt	r1, #1
    4ff4:	e3a00003 	mov	r0, #3
    4ff8:	ebffee68 	bl	9a0 <_test_assert>
    4ffc:	e3500000 	cmp	r0, #0
    5000:	1affffbb 	bne	4ef4 <sem4_execute+0x54>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5004:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5008:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
    500c:	e59d1014 	ldr	r1, [sp, #20]
    5010:	e2413001 	sub	r3, r1, #1
    5014:	e2731000 	rsbs	r1, r3, #0
    5018:	e0a11003 	adc	r1, r1, r3
    501c:	e3a00005 	mov	r0, #5
    5020:	ebffee5e 	bl	9a0 <_test_assert>
    5024:	eaffffb2 	b	4ef4 <sem4_execute+0x54>
    chSemSignalI(&bsp->bs_sem);
    5028:	e1a00004 	mov	r0, r4
    502c:	ebfff11f 	bl	14b0 <chSemSignalI>
    5030:	eaffffce 	b	4f70 <sem4_execute+0xd0>
    5034:	e1a00004 	mov	r0, r4
    5038:	ebfff11c 	bl	14b0 <chSemSignalI>
    503c:	eaffffe5 	b	4fd8 <sem4_execute+0x138>
    5040:	40000c00 	.word	0x40000c00
    5044:	00001c10 	.word	0x00001c10
    5048:	40000e00 	.word	0x40000e00
    504c:	4000141c 	.word	0x4000141c

00005050 <thread3.lto_priv.60>:
static THD_FUNCTION(thread3, p) {
    5050:	e92d4010 	push	{r4, lr}
  chSemWait(&sem1);
    5054:	e59f4010 	ldr	r4, [pc, #16]	; 506c <thread3.lto_priv.60+0x1c>
    5058:	e1a00004 	mov	r0, r4
    505c:	ebffff3b 	bl	4d50 <chSemWait>
  chSemSignal(&sem1);
    5060:	e1a00004 	mov	r0, r4
}
    5064:	e8bd4010 	pop	{r4, lr}
  chSemSignal(&sem1);
    5068:	eafff44c 	b	21a0 <chSemSignal>
    506c:	40000b04 	.word	0x40000b04

00005070 <thread1.lto_priv.62>:
static THD_FUNCTION(thread1, p) {
    5070:	e92d4010 	push	{r4, lr}
    5074:	e1a04000 	mov	r4, r0
  chSemWait(&sem1);
    5078:	e59f000c 	ldr	r0, [pc, #12]	; 508c <thread1.lto_priv.62+0x1c>
    507c:	ebffff33 	bl	4d50 <chSemWait>
  test_emit_token(*(char *)p);
    5080:	e5d40000 	ldrb	r0, [r4]
}
    5084:	e8bd4010 	pop	{r4, lr}
  test_emit_token(*(char *)p);
    5088:	eaffee54 	b	9e0 <test_emit_token>
    508c:	40000b04 	.word	0x40000b04

00005090 <chThdWait>:
msg_t chThdWait(thread_t *tp) {
    5090:	e92d4070 	push	{r4, r5, r6, lr}
    5094:	e1a04000 	mov	r4, r0
    5098:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (tp->p_state != CH_STATE_FINAL) {
    509c:	e5d0301c 	ldrb	r3, [r0, #28]
    50a0:	e353000f 	cmp	r3, #15
    50a4:	0a000006 	beq	50c4 <chThdWait+0x34>
    list_insert(currp, &tp->p_waiting);
    50a8:	e59f302c 	ldr	r3, [pc, #44]	; 50dc <chThdWait+0x4c>
  tp->p_next = tlp->p_next;
    50ac:	e5902028 	ldr	r2, [r0, #40]	; 0x28
    50b0:	e5933018 	ldr	r3, [r3, #24]
    chSchGoSleepS(CH_STATE_WTEXIT);
    50b4:	e3a00009 	mov	r0, #9
    50b8:	e5832000 	str	r2, [r3]
  tlp->p_next = tp;
    50bc:	e5843028 	str	r3, [r4, #40]	; 0x28
    50c0:	ebfff472 	bl	2290 <chSchGoSleepS>
  msg = tp->p_u.exitcode;
    50c4:	e5945024 	ldr	r5, [r4, #36]	; 0x24
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    50c8:	e321f01f 	msr	CPSR_c, #31
  chThdRelease(tp);
    50cc:	e1a00004 	mov	r0, r4
    50d0:	ebfffd26 	bl	4570 <chThdRelease>
}
    50d4:	e1a00005 	mov	r0, r5
    50d8:	e8bd8070 	pop	{r4, r5, r6, pc}
    50dc:	40000c00 	.word	0x40000c00

000050e0 <bmk5_execute>:
static void bmk5_execute(void) {
    50e0:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  uint32_t n = 0;
    50e4:	e3a04000 	mov	r4, #0
  return ch.rlist.r_current;
    50e8:	e59f3070 	ldr	r3, [pc, #112]	; 5160 <bmk5_execute+0x80>
  return chThdGetSelfX()->p_prio;
    50ec:	e5933018 	ldr	r3, [r3, #24]
static void bmk5_execute(void) {
    50f0:	e24dd00c 	sub	sp, sp, #12
  tprio_t prio = chThdGetPriorityX() - 1;
    50f4:	e5935008 	ldr	r5, [r3, #8]
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    50f8:	e1a09004 	mov	r9, r4
  test_wait_tick();
    50fc:	ebfff993 	bl	3750 <test_wait_tick>
  test_start_timer(1000);
    5100:	ebfff186 	bl	1720 <test_start_timer.constprop.1>
    5104:	e59f8058 	ldr	r8, [pc, #88]	; 5164 <bmk5_execute+0x84>
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    5108:	e59f7058 	ldr	r7, [pc, #88]	; 5168 <bmk5_execute+0x88>
    510c:	e59f6058 	ldr	r6, [pc, #88]	; 516c <bmk5_execute+0x8c>
  tprio_t prio = chThdGetPriorityX() - 1;
    5110:	e2455001 	sub	r5, r5, #1
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    5114:	e1a03007 	mov	r3, r7
    5118:	e1a02005 	mov	r2, r5
    511c:	e3a01e13 	mov	r1, #304	; 0x130
    5120:	e58d9000 	str	r9, [sp]
    5124:	e1a00006 	mov	r0, r6
    5128:	ebfff430 	bl	21f0 <chThdCreateStatic>
    512c:	ebffffd7 	bl	5090 <chThdWait>
  } while (!test_timer_done);
    5130:	e5d83000 	ldrb	r3, [r8]
    5134:	e3530000 	cmp	r3, #0
    n++;
    5138:	e2844001 	add	r4, r4, #1
  } while (!test_timer_done);
    513c:	0afffff4 	beq	5114 <bmk5_execute+0x34>
  test_print("--- Score : ");
    5140:	e59f0028 	ldr	r0, [pc, #40]	; 5170 <bmk5_execute+0x90>
    5144:	ebffee5d 	bl	ac0 <test_print>
  test_printn(n);
    5148:	e1a00004 	mov	r0, r4
    514c:	ebffed8b 	bl	780 <test_printn>
  test_println(" threads/S");
    5150:	e59f001c 	ldr	r0, [pc, #28]	; 5174 <bmk5_execute+0x94>
}
    5154:	e28dd00c 	add	sp, sp, #12
    5158:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, lr}
  test_println(" threads/S");
    515c:	eaffee3f 	b	a60 <test_println>
    5160:	40000c00 	.word	0x40000c00
    5164:	40001418 	.word	0x40001418
    5168:	00007fb0 	.word	0x00007fb0
    516c:	40000e00 	.word	0x40000e00
    5170:	00008010 	.word	0x00008010
    5174:	00008110 	.word	0x00008110
	...

00005180 <test_wait_threads>:
void test_wait_threads(void) {
    5180:	e92d4070 	push	{r4, r5, r6, lr}
      threads[i] = NULL;
    5184:	e3a06000 	mov	r6, #0
    5188:	e59f4020 	ldr	r4, [pc, #32]	; 51b0 <test_wait_threads+0x30>
    518c:	e2845014 	add	r5, r4, #20
    if (threads[i] != NULL) {
    5190:	e4940004 	ldr	r0, [r4], #4
    5194:	e3500000 	cmp	r0, #0
    5198:	0a000001 	beq	51a4 <test_wait_threads+0x24>
      chThdWait(threads[i]);
    519c:	ebffffbb 	bl	5090 <chThdWait>
      threads[i] = NULL;
    51a0:	e5046004 	str	r6, [r4, #-4]
  for (i = 0; i < MAX_THREADS; i++)
    51a4:	e1540005 	cmp	r4, r5
    51a8:	1afffff8 	bne	5190 <test_wait_threads+0x10>
    51ac:	e8bd8070 	pop	{r4, r5, r6, pc}
    51b0:	4000141c 	.word	0x4000141c
	...

000051c0 <bmk8_execute>:
  n = 0;
    51c0:	e3a03000 	mov	r3, #0
static void bmk8_execute(void) {
    51c4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  return ch.rlist.r_current;
    51c8:	e59f80fc 	ldr	r8, [pc, #252]	; 52cc <bmk8_execute+0x10c>
    51cc:	e24dd010 	sub	sp, sp, #16
  n = 0;
    51d0:	e28d4010 	add	r4, sp, #16
    51d4:	e5243004 	str	r3, [r4, #-4]!
  test_wait_tick();
    51d8:	ebfff95c 	bl	3750 <test_wait_tick>
  return chThdGetSelfX()->p_prio;
    51dc:	e5983018 	ldr	r3, [r8, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    51e0:	e59f70e8 	ldr	r7, [pc, #232]	; 52d0 <bmk8_execute+0x110>
    51e4:	e59f60e8 	ldr	r6, [pc, #232]	; 52d4 <bmk8_execute+0x114>
    51e8:	e5932008 	ldr	r2, [r3, #8]
    51ec:	e1a00006 	mov	r0, r6
    51f0:	e1a03007 	mov	r3, r7
    51f4:	e2422001 	sub	r2, r2, #1
    51f8:	e58d4000 	str	r4, [sp]
    51fc:	e3a01e13 	mov	r1, #304	; 0x130
    5200:	ebfff3fa 	bl	21f0 <chThdCreateStatic>
    5204:	e5983018 	ldr	r3, [r8, #24]
    5208:	e59f50c8 	ldr	r5, [pc, #200]	; 52d8 <bmk8_execute+0x118>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    520c:	e5932008 	ldr	r2, [r3, #8]
    5210:	e3a01e13 	mov	r1, #304	; 0x130
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    5214:	e5850000 	str	r0, [r5]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    5218:	e1a03007 	mov	r3, r7
    521c:	e2422001 	sub	r2, r2, #1
    5220:	e58d4000 	str	r4, [sp]
    5224:	e2860e13 	add	r0, r6, #304	; 0x130
    5228:	ebfff3f0 	bl	21f0 <chThdCreateStatic>
    522c:	e5983018 	ldr	r3, [r8, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    5230:	e5932008 	ldr	r2, [r3, #8]
    5234:	e3a01e13 	mov	r1, #304	; 0x130
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    5238:	e5850004 	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    523c:	e1a03007 	mov	r3, r7
    5240:	e2422001 	sub	r2, r2, #1
    5244:	e58d4000 	str	r4, [sp]
    5248:	e2860e26 	add	r0, r6, #608	; 0x260
    524c:	ebfff3e7 	bl	21f0 <chThdCreateStatic>
    5250:	e5983018 	ldr	r3, [r8, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    5254:	e5932008 	ldr	r2, [r3, #8]
    5258:	e3a01e13 	mov	r1, #304	; 0x130
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    525c:	e5850008 	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    5260:	e1a03007 	mov	r3, r7
    5264:	e2422001 	sub	r2, r2, #1
    5268:	e58d4000 	str	r4, [sp]
    526c:	e2860e39 	add	r0, r6, #912	; 0x390
    5270:	ebfff3de 	bl	21f0 <chThdCreateStatic>
    5274:	e5983018 	ldr	r3, [r8, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    5278:	e5932008 	ldr	r2, [r3, #8]
    527c:	e3a01e13 	mov	r1, #304	; 0x130
    5280:	e2422001 	sub	r2, r2, #1
    5284:	e1a03007 	mov	r3, r7
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    5288:	e585000c 	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
    528c:	e58d4000 	str	r4, [sp]
    5290:	e2860d13 	add	r0, r6, #1216	; 0x4c0
    5294:	ebfff3d5 	bl	21f0 <chThdCreateStatic>
    5298:	e5850010 	str	r0, [r5, #16]
  chThdSleepSeconds(1);
    529c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
    52a0:	ebfff87e 	bl	34a0 <chThdSleep>
  test_terminate_threads();
    52a4:	ebffed75 	bl	880 <test_terminate_threads>
  test_wait_threads();
    52a8:	ebffffb4 	bl	5180 <test_wait_threads>
  test_print("--- Score : ");
    52ac:	e59f0028 	ldr	r0, [pc, #40]	; 52dc <bmk8_execute+0x11c>
    52b0:	ebffee02 	bl	ac0 <test_print>
  test_printn(n);
    52b4:	e59d000c 	ldr	r0, [sp, #12]
    52b8:	ebffed30 	bl	780 <test_printn>
  test_println(" ctxswc/S");
    52bc:	e59f001c 	ldr	r0, [pc, #28]	; 52e0 <bmk8_execute+0x120>
    52c0:	ebffede6 	bl	a60 <test_println>
}
    52c4:	e28dd010 	add	sp, sp, #16
    52c8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    52cc:	40000c00 	.word	0x40000c00
    52d0:	00001b30 	.word	0x00001b30
    52d4:	40000e00 	.word	0x40000e00
    52d8:	4000141c 	.word	0x4000141c
    52dc:	00008010 	.word	0x00008010
    52e0:	00008140 	.word	0x00008140
	...

000052f0 <bmk7_execute>:
static void bmk7_execute(void) {
    52f0:	e92d4070 	push	{r4, r5, r6, lr}
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
    52f4:	e3a04000 	mov	r4, #0
  return ch.rlist.r_current;
    52f8:	e59f6144 	ldr	r6, [pc, #324]	; 5444 <bmk7_execute+0x154>
  return chThdGetSelfX()->p_prio;
    52fc:	e5963018 	ldr	r3, [r6, #24]
    5300:	e5932008 	ldr	r2, [r3, #8]
static void bmk7_execute(void) {
    5304:	e24dd008 	sub	sp, sp, #8
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
    5308:	e59f3138 	ldr	r3, [pc, #312]	; 5448 <bmk7_execute+0x158>
    530c:	e2822005 	add	r2, r2, #5
    5310:	e3a01e13 	mov	r1, #304	; 0x130
    5314:	e58d4000 	str	r4, [sp]
    5318:	e59f012c 	ldr	r0, [pc, #300]	; 544c <bmk7_execute+0x15c>
    531c:	ebfff3b3 	bl	21f0 <chThdCreateStatic>
    5320:	e5963018 	ldr	r3, [r6, #24]
    5324:	e59f5124 	ldr	r5, [pc, #292]	; 5450 <bmk7_execute+0x160>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
    5328:	e5932008 	ldr	r2, [r3, #8]
    532c:	e3a01e13 	mov	r1, #304	; 0x130
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
    5330:	e5850000 	str	r0, [r5]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
    5334:	e2822004 	add	r2, r2, #4
    5338:	e59f3108 	ldr	r3, [pc, #264]	; 5448 <bmk7_execute+0x158>
    533c:	e58d4000 	str	r4, [sp]
    5340:	e59f010c 	ldr	r0, [pc, #268]	; 5454 <bmk7_execute+0x164>
    5344:	ebfff3a9 	bl	21f0 <chThdCreateStatic>
    5348:	e5963018 	ldr	r3, [r6, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
    534c:	e5932008 	ldr	r2, [r3, #8]
    5350:	e3a01e13 	mov	r1, #304	; 0x130
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
    5354:	e5850004 	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
    5358:	e2822003 	add	r2, r2, #3
    535c:	e59f30e4 	ldr	r3, [pc, #228]	; 5448 <bmk7_execute+0x158>
    5360:	e58d4000 	str	r4, [sp]
    5364:	e59f00ec 	ldr	r0, [pc, #236]	; 5458 <bmk7_execute+0x168>
    5368:	ebfff3a0 	bl	21f0 <chThdCreateStatic>
    536c:	e5963018 	ldr	r3, [r6, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
    5370:	e5932008 	ldr	r2, [r3, #8]
    5374:	e3a01e13 	mov	r1, #304	; 0x130
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
    5378:	e5850008 	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
    537c:	e2822002 	add	r2, r2, #2
    5380:	e59f30c0 	ldr	r3, [pc, #192]	; 5448 <bmk7_execute+0x158>
    5384:	e58d4000 	str	r4, [sp]
    5388:	e59f00cc 	ldr	r0, [pc, #204]	; 545c <bmk7_execute+0x16c>
    538c:	ebfff397 	bl	21f0 <chThdCreateStatic>
    5390:	e5963018 	ldr	r3, [r6, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
    5394:	e5932008 	ldr	r2, [r3, #8]
    5398:	e3a01e13 	mov	r1, #304	; 0x130
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
    539c:	e585000c 	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
    53a0:	e2822001 	add	r2, r2, #1
    53a4:	e59f309c 	ldr	r3, [pc, #156]	; 5448 <bmk7_execute+0x158>
    53a8:	e58d4000 	str	r4, [sp]
    53ac:	e59f00ac 	ldr	r0, [pc, #172]	; 5460 <bmk7_execute+0x170>
    53b0:	ebfff38e 	bl	21f0 <chThdCreateStatic>
    53b4:	e5850010 	str	r0, [r5, #16]
  test_wait_tick();
    53b8:	ebfff8e4 	bl	3750 <test_wait_tick>
  test_start_timer(1000);
    53bc:	ebfff0d7 	bl	1720 <test_start_timer.constprop.1>
    53c0:	e59f609c 	ldr	r6, [pc, #156]	; 5464 <bmk7_execute+0x174>
  chSemResetI(sp, n);
    53c4:	e59f509c 	ldr	r5, [pc, #156]	; 5468 <bmk7_execute+0x178>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    53c8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    53cc:	e3a01000 	mov	r1, #0
    53d0:	e1a00005 	mov	r0, r5
    53d4:	ebfff08d 	bl	1610 <chSemResetI>
  chSchRescheduleS();
    53d8:	ebfff200 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    53dc:	e321f01f 	msr	CPSR_c, #31
  } while (!test_timer_done);
    53e0:	e5d63000 	ldrb	r3, [r6]
    53e4:	e3530000 	cmp	r3, #0
    n++;
    53e8:	e2844001 	add	r4, r4, #1
  } while (!test_timer_done);
    53ec:	0afffff5 	beq	53c8 <bmk7_execute+0xd8>
  test_terminate_threads();
    53f0:	ebffed22 	bl	880 <test_terminate_threads>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    53f4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chSemResetI(sp, n);
    53f8:	e3a01000 	mov	r1, #0
    53fc:	e59f0064 	ldr	r0, [pc, #100]	; 5468 <bmk7_execute+0x178>
    5400:	ebfff082 	bl	1610 <chSemResetI>
  chSchRescheduleS();
    5404:	ebfff1f5 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5408:	e321f01f 	msr	CPSR_c, #31
  test_wait_threads();
    540c:	ebffff5b 	bl	5180 <test_wait_threads>
  test_print("--- Score : ");
    5410:	e59f0054 	ldr	r0, [pc, #84]	; 546c <bmk7_execute+0x17c>
    5414:	ebffeda9 	bl	ac0 <test_print>
  test_printn(n);
    5418:	e1a00004 	mov	r0, r4
    541c:	ebffecd7 	bl	780 <test_printn>
  test_printn(n * 6);
    5420:	e0844084 	add	r4, r4, r4, lsl #1
  test_print(" reschedules/S, ");
    5424:	e59f0044 	ldr	r0, [pc, #68]	; 5470 <bmk7_execute+0x180>
    5428:	ebffeda4 	bl	ac0 <test_print>
  test_printn(n * 6);
    542c:	e1a00084 	lsl	r0, r4, #1
    5430:	ebffecd2 	bl	780 <test_printn>
  test_println(" ctxswc/S");
    5434:	e59f0038 	ldr	r0, [pc, #56]	; 5474 <bmk7_execute+0x184>
}
    5438:	e28dd008 	add	sp, sp, #8
    543c:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_println(" ctxswc/S");
    5440:	eaffed86 	b	a60 <test_println>
    5444:	40000c00 	.word	0x40000c00
    5448:	00004e60 	.word	0x00004e60
    544c:	40000e00 	.word	0x40000e00
    5450:	4000141c 	.word	0x4000141c
    5454:	40000f30 	.word	0x40000f30
    5458:	40001060 	.word	0x40001060
    545c:	40001190 	.word	0x40001190
    5460:	400012c0 	.word	0x400012c0
    5464:	40001418 	.word	0x40001418
    5468:	40000df0 	.word	0x40000df0
    546c:	00008010 	.word	0x00008010
    5470:	00008120 	.word	0x00008120
    5474:	00008140 	.word	0x00008140
	...

00005480 <bmk4_execute>:
static void bmk4_execute(void) {
    5480:	e92d4070 	push	{r4, r5, r6, lr}
  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
    5484:	e3a05000 	mov	r5, #0
  return ch.rlist.r_current;
    5488:	e59f30b8 	ldr	r3, [pc, #184]	; 5548 <bmk4_execute+0xc8>
  return chThdGetSelfX()->p_prio;
    548c:	e5933018 	ldr	r3, [r3, #24]
    5490:	e5932008 	ldr	r2, [r3, #8]
static void bmk4_execute(void) {
    5494:	e24dd008 	sub	sp, sp, #8
  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
    5498:	e2822001 	add	r2, r2, #1
    549c:	e3a01e13 	mov	r1, #304	; 0x130
    54a0:	e59f30a4 	ldr	r3, [pc, #164]	; 554c <bmk4_execute+0xcc>
    54a4:	e58d5000 	str	r5, [sp]
    54a8:	e59f00a0 	ldr	r0, [pc, #160]	; 5550 <bmk4_execute+0xd0>
    54ac:	ebfff34f 	bl	21f0 <chThdCreateStatic>
    54b0:	e59f309c 	ldr	r3, [pc, #156]	; 5554 <bmk4_execute+0xd4>
    54b4:	e1a04000 	mov	r4, r0
    54b8:	e5830000 	str	r0, [r3]
  test_wait_tick();
    54bc:	ebfff8a3 	bl	3750 <test_wait_tick>
  test_start_timer(1000);
    54c0:	ebfff096 	bl	1720 <test_start_timer.constprop.1>
    54c4:	e59f608c 	ldr	r6, [pc, #140]	; 5558 <bmk4_execute+0xd8>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    54c8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    chSchWakeupS(tp, MSG_OK);
    54cc:	e3a01000 	mov	r1, #0
    54d0:	e1a00004 	mov	r0, r4
    54d4:	ebfff299 	bl	1f40 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
    54d8:	e1a00004 	mov	r0, r4
    54dc:	e3a01000 	mov	r1, #0
    54e0:	ebfff296 	bl	1f40 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
    54e4:	e1a00004 	mov	r0, r4
    54e8:	e3a01000 	mov	r1, #0
    54ec:	ebfff293 	bl	1f40 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
    54f0:	e1a00004 	mov	r0, r4
    54f4:	e3a01000 	mov	r1, #0
    54f8:	ebfff290 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    54fc:	e321f01f 	msr	CPSR_c, #31
  } while (!test_timer_done);
    5500:	e5d63000 	ldrb	r3, [r6]
    5504:	e3530000 	cmp	r3, #0
    n += 4;
    5508:	e2855004 	add	r5, r5, #4
  } while (!test_timer_done);
    550c:	0affffed 	beq	54c8 <bmk4_execute+0x48>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5510:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chSchWakeupS(tp, MSG_TIMEOUT);
    5514:	e3e01000 	mvn	r1, #0
    5518:	e1a00004 	mov	r0, r4
    551c:	ebfff287 	bl	1f40 <chSchWakeupS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5520:	e321f01f 	msr	CPSR_c, #31
  test_wait_threads();
    5524:	ebffff15 	bl	5180 <test_wait_threads>
  test_print("--- Score : ");
    5528:	e59f002c 	ldr	r0, [pc, #44]	; 555c <bmk4_execute+0xdc>
    552c:	ebffed63 	bl	ac0 <test_print>
  test_printn(n * 2);
    5530:	e1a00085 	lsl	r0, r5, #1
    5534:	ebffec91 	bl	780 <test_printn>
  test_println(" ctxswc/S");
    5538:	e59f0020 	ldr	r0, [pc, #32]	; 5560 <bmk4_execute+0xe0>
}
    553c:	e28dd008 	add	sp, sp, #8
    5540:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_println(" ctxswc/S");
    5544:	eaffed45 	b	a60 <test_println>
    5548:	40000c00 	.word	0x40000c00
    554c:	000024f0 	.word	0x000024f0
    5550:	40000e00 	.word	0x40000e00
    5554:	4000141c 	.word	0x4000141c
    5558:	40001418 	.word	0x40001418
    555c:	00008010 	.word	0x00008010
    5560:	00008140 	.word	0x00008140
	...

00005570 <bmk3_execute>:
static void bmk3_execute(void) {
    5570:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
    5574:	e3a06000 	mov	r6, #0
  return ch.rlist.r_current;
    5578:	e59f7100 	ldr	r7, [pc, #256]	; 5680 <bmk3_execute+0x110>
  return chThdGetSelfX()->p_prio;
    557c:	e5973018 	ldr	r3, [r7, #24]
    5580:	e59f50fc 	ldr	r5, [pc, #252]	; 5684 <bmk3_execute+0x114>
    5584:	e5932008 	ldr	r2, [r3, #8]
static void bmk3_execute(void) {
    5588:	e24dd008 	sub	sp, sp, #8
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
    558c:	e1a00005 	mov	r0, r5
    5590:	e2822001 	add	r2, r2, #1
    5594:	e58d6000 	str	r6, [sp]
    5598:	e59f30e8 	ldr	r3, [pc, #232]	; 5688 <bmk3_execute+0x118>
    559c:	e3a01e13 	mov	r1, #304	; 0x130
    55a0:	ebfff312 	bl	21f0 <chThdCreateStatic>
    55a4:	e5973018 	ldr	r3, [r7, #24]
    55a8:	e59f40dc 	ldr	r4, [pc, #220]	; 568c <bmk3_execute+0x11c>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
    55ac:	e5932008 	ldr	r2, [r3, #8]
    55b0:	e59f80d8 	ldr	r8, [pc, #216]	; 5690 <bmk3_execute+0x120>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
    55b4:	e5840000 	str	r0, [r4]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
    55b8:	e1a03008 	mov	r3, r8
    55bc:	e2422002 	sub	r2, r2, #2
    55c0:	e58d6000 	str	r6, [sp]
    55c4:	e2850e13 	add	r0, r5, #304	; 0x130
    55c8:	e3a01e13 	mov	r1, #304	; 0x130
    55cc:	ebfff307 	bl	21f0 <chThdCreateStatic>
    55d0:	e5973018 	ldr	r3, [r7, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
    55d4:	e5932008 	ldr	r2, [r3, #8]
    55d8:	e3a01e13 	mov	r1, #304	; 0x130
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
    55dc:	e5840004 	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
    55e0:	e1a03008 	mov	r3, r8
    55e4:	e2422003 	sub	r2, r2, #3
    55e8:	e58d6000 	str	r6, [sp]
    55ec:	e2850e26 	add	r0, r5, #608	; 0x260
    55f0:	ebfff2fe 	bl	21f0 <chThdCreateStatic>
    55f4:	e5973018 	ldr	r3, [r7, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
    55f8:	e5932008 	ldr	r2, [r3, #8]
    55fc:	e3a01e13 	mov	r1, #304	; 0x130
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
    5600:	e5840008 	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
    5604:	e1a03008 	mov	r3, r8
    5608:	e2422004 	sub	r2, r2, #4
    560c:	e58d6000 	str	r6, [sp]
    5610:	e2850e39 	add	r0, r5, #912	; 0x390
    5614:	ebfff2f5 	bl	21f0 <chThdCreateStatic>
    5618:	e5973018 	ldr	r3, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
    561c:	e5932008 	ldr	r2, [r3, #8]
    5620:	e3a01e13 	mov	r1, #304	; 0x130
    5624:	e2422005 	sub	r2, r2, #5
    5628:	e1a03008 	mov	r3, r8
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
    562c:	e584000c 	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
    5630:	e58d6000 	str	r6, [sp]
    5634:	e2850d13 	add	r0, r5, #1216	; 0x4c0
    5638:	ebfff2ec 	bl	21f0 <chThdCreateStatic>
    563c:	e5840010 	str	r0, [r4, #16]
  n = msg_loop_test(threads[0]);
    5640:	e5940000 	ldr	r0, [r4]
    5644:	ebfff97d 	bl	3c40 <msg_loop_test>
    5648:	e1a04000 	mov	r4, r0
  test_wait_threads();
    564c:	ebfffecb 	bl	5180 <test_wait_threads>
  test_print("--- Score : ");
    5650:	e59f003c 	ldr	r0, [pc, #60]	; 5694 <bmk3_execute+0x124>
    5654:	ebffed19 	bl	ac0 <test_print>
  test_printn(n);
    5658:	e1a00004 	mov	r0, r4
    565c:	ebffec47 	bl	780 <test_printn>
  test_print(" msgs/S, ");
    5660:	e59f0030 	ldr	r0, [pc, #48]	; 5698 <bmk3_execute+0x128>
    5664:	ebffed15 	bl	ac0 <test_print>
  test_printn(n << 1);
    5668:	e1a00084 	lsl	r0, r4, #1
    566c:	ebffec43 	bl	780 <test_printn>
  test_println(" ctxswc/S");
    5670:	e59f0024 	ldr	r0, [pc, #36]	; 569c <bmk3_execute+0x12c>
}
    5674:	e28dd008 	add	sp, sp, #8
    5678:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  test_println(" ctxswc/S");
    567c:	eaffecf7 	b	a60 <test_println>
    5680:	40000c00 	.word	0x40000c00
    5684:	40000e00 	.word	0x40000e00
    5688:	00003af0 	.word	0x00003af0
    568c:	4000141c 	.word	0x4000141c
    5690:	00007fb0 	.word	0x00007fb0
    5694:	00008010 	.word	0x00008010
    5698:	00008100 	.word	0x00008100
    569c:	00008140 	.word	0x00008140

000056a0 <bmk2_execute>:
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
    56a0:	e3a01000 	mov	r1, #0
static void bmk2_execute(void) {
    56a4:	e92d4010 	push	{r4, lr}
  return ch.rlist.r_current;
    56a8:	e59f3064 	ldr	r3, [pc, #100]	; 5714 <bmk2_execute+0x74>
  return chThdGetSelfX()->p_prio;
    56ac:	e5933018 	ldr	r3, [r3, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
    56b0:	e5932008 	ldr	r2, [r3, #8]
static void bmk2_execute(void) {
    56b4:	e24dd008 	sub	sp, sp, #8
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
    56b8:	e2822001 	add	r2, r2, #1
    56bc:	e58d1000 	str	r1, [sp]
    56c0:	e59f3050 	ldr	r3, [pc, #80]	; 5718 <bmk2_execute+0x78>
    56c4:	e3a01e13 	mov	r1, #304	; 0x130
    56c8:	e59f004c 	ldr	r0, [pc, #76]	; 571c <bmk2_execute+0x7c>
    56cc:	ebfff2c7 	bl	21f0 <chThdCreateStatic>
    56d0:	e59f3048 	ldr	r3, [pc, #72]	; 5720 <bmk2_execute+0x80>
    56d4:	e5830000 	str	r0, [r3]
  n = msg_loop_test(threads[0]);
    56d8:	ebfff958 	bl	3c40 <msg_loop_test>
    56dc:	e1a04000 	mov	r4, r0
  test_wait_threads();
    56e0:	ebfffea6 	bl	5180 <test_wait_threads>
  test_print("--- Score : ");
    56e4:	e59f0038 	ldr	r0, [pc, #56]	; 5724 <bmk2_execute+0x84>
    56e8:	ebffecf4 	bl	ac0 <test_print>
  test_printn(n);
    56ec:	e1a00004 	mov	r0, r4
    56f0:	ebffec22 	bl	780 <test_printn>
  test_print(" msgs/S, ");
    56f4:	e59f002c 	ldr	r0, [pc, #44]	; 5728 <bmk2_execute+0x88>
    56f8:	ebffecf0 	bl	ac0 <test_print>
  test_printn(n << 1);
    56fc:	e1a00084 	lsl	r0, r4, #1
    5700:	ebffec1e 	bl	780 <test_printn>
  test_println(" ctxswc/S");
    5704:	e59f0020 	ldr	r0, [pc, #32]	; 572c <bmk2_execute+0x8c>
}
    5708:	e28dd008 	add	sp, sp, #8
    570c:	e8bd4010 	pop	{r4, lr}
  test_println(" ctxswc/S");
    5710:	eaffecd2 	b	a60 <test_println>
    5714:	40000c00 	.word	0x40000c00
    5718:	00003af0 	.word	0x00003af0
    571c:	40000e00 	.word	0x40000e00
    5720:	4000141c 	.word	0x4000141c
    5724:	00008010 	.word	0x00008010
    5728:	00008100 	.word	0x00008100
    572c:	00008140 	.word	0x00008140

00005730 <bmk1_execute>:
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
    5730:	e3a01000 	mov	r1, #0
static void bmk1_execute(void) {
    5734:	e92d4010 	push	{r4, lr}
  return ch.rlist.r_current;
    5738:	e59f3064 	ldr	r3, [pc, #100]	; 57a4 <bmk1_execute+0x74>
  return chThdGetSelfX()->p_prio;
    573c:	e5933018 	ldr	r3, [r3, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
    5740:	e5932008 	ldr	r2, [r3, #8]
static void bmk1_execute(void) {
    5744:	e24dd008 	sub	sp, sp, #8
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
    5748:	e2422001 	sub	r2, r2, #1
    574c:	e58d1000 	str	r1, [sp]
    5750:	e59f3050 	ldr	r3, [pc, #80]	; 57a8 <bmk1_execute+0x78>
    5754:	e3a01e13 	mov	r1, #304	; 0x130
    5758:	e59f004c 	ldr	r0, [pc, #76]	; 57ac <bmk1_execute+0x7c>
    575c:	ebfff2a3 	bl	21f0 <chThdCreateStatic>
    5760:	e59f3048 	ldr	r3, [pc, #72]	; 57b0 <bmk1_execute+0x80>
    5764:	e5830000 	str	r0, [r3]
  n = msg_loop_test(threads[0]);
    5768:	ebfff934 	bl	3c40 <msg_loop_test>
    576c:	e1a04000 	mov	r4, r0
  test_wait_threads();
    5770:	ebfffe82 	bl	5180 <test_wait_threads>
  test_print("--- Score : ");
    5774:	e59f0038 	ldr	r0, [pc, #56]	; 57b4 <bmk1_execute+0x84>
    5778:	ebffecd0 	bl	ac0 <test_print>
  test_printn(n);
    577c:	e1a00004 	mov	r0, r4
    5780:	ebffebfe 	bl	780 <test_printn>
  test_print(" msgs/S, ");
    5784:	e59f002c 	ldr	r0, [pc, #44]	; 57b8 <bmk1_execute+0x88>
    5788:	ebffeccc 	bl	ac0 <test_print>
  test_printn(n << 1);
    578c:	e1a00084 	lsl	r0, r4, #1
    5790:	ebffebfa 	bl	780 <test_printn>
  test_println(" ctxswc/S");
    5794:	e59f0020 	ldr	r0, [pc, #32]	; 57bc <bmk1_execute+0x8c>
}
    5798:	e28dd008 	add	sp, sp, #8
    579c:	e8bd4010 	pop	{r4, lr}
  test_println(" ctxswc/S");
    57a0:	eaffecae 	b	a60 <test_println>
    57a4:	40000c00 	.word	0x40000c00
    57a8:	00003af0 	.word	0x00003af0
    57ac:	40000e00 	.word	0x40000e00
    57b0:	4000141c 	.word	0x4000141c
    57b4:	00008010 	.word	0x00008010
    57b8:	00008100 	.word	0x00008100
    57bc:	00008140 	.word	0x00008140

000057c0 <queues2_execute>:
}

static void queues2_execute(void) {
    57c0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    57c4:	e24dd00c 	sub	sp, sp, #12
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    57c8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    57cc:	e59f5314 	ldr	r5, [pc, #788]	; 5ae8 <queues2_execute+0x328>
    57d0:	e5952018 	ldr	r2, [r5, #24]
    57d4:	e5953014 	ldr	r3, [r5, #20]
    57d8:	e1520003 	cmp	r2, r3
    57dc:	13a01000 	movne	r1, #0
    57e0:	0a00002e 	beq	58a0 <queues2_execute+0xe0>
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
    57e4:	e3a00001 	mov	r0, #1
    57e8:	ebffec6c 	bl	9a0 <_test_assert>
    57ec:	e3500000 	cmp	r0, #0
    57f0:	1a000027 	bne	5894 <queues2_execute+0xd4>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    57f4:	e321f01f 	msr	CPSR_c, #31
    57f8:	e3a04041 	mov	r4, #65	; 0x41
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
    57fc:	e59f62e4 	ldr	r6, [pc, #740]	; 5ae8 <queues2_execute+0x328>
    5800:	e1a01004 	mov	r1, r4
    5804:	e2844001 	add	r4, r4, #1
    5808:	e3e02000 	mvn	r2, #0
    580c:	e1a00006 	mov	r0, r6
    5810:	e20440ff 	and	r4, r4, #255	; 0xff
    5814:	ebfff68d 	bl	3250 <chOQPutTimeout>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    5818:	e3540045 	cmp	r4, #69	; 0x45
    581c:	1afffff7 	bne	5800 <queues2_execute+0x40>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5820:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)(chQSpaceI(oqp) == 0U);
    5824:	e5951008 	ldr	r1, [r5, #8]
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
    5828:	e2711001 	rsbs	r1, r1, #1
    582c:	33a01000 	movcc	r1, #0
    5830:	e3a00002 	mov	r0, #2
    5834:	ebffec59 	bl	9a0 <_test_assert>
    5838:	e2507000 	subs	r7, r0, #0
    583c:	1a000014 	bne	5894 <queues2_execute+0xd4>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5840:	e321f01f 	msr	CPSR_c, #31
    5844:	e3a04004 	mov	r4, #4
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
    5848:	e59f6298 	ldr	r6, [pc, #664]	; 5ae8 <queues2_execute+0x328>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    584c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    5850:	e1a00006 	mov	r0, r6
    5854:	ebffee1d 	bl	10d0 <chOQGetI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5858:	e321f01f 	msr	CPSR_c, #31
    chSysUnlock();
    test_emit_token(c);
    585c:	e20000ff 	and	r0, r0, #255	; 0xff
    5860:	ebffec5e 	bl	9e0 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    5864:	e2544001 	subs	r4, r4, #1
    5868:	1afffff7 	bne	584c <queues2_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    586c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    5870:	e2852014 	add	r2, r5, #20
    5874:	e892000c 	ldm	r2, {r2, r3}
    5878:	e1520003 	cmp	r2, r3
    587c:	0a000095 	beq	5ad8 <queues2_execute+0x318>
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
    5880:	e1a01007 	mov	r1, r7
    5884:	e3a00003 	mov	r0, #3
    5888:	ebffec44 	bl	9a0 <_test_assert>
    588c:	e3500000 	cmp	r0, #0
    5890:	0a000006 	beq	58b0 <queues2_execute+0xf0>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5894:	e321f01f 	msr	CPSR_c, #31
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
    5898:	e28dd00c 	add	sp, sp, #12
    589c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    58a0:	e5951008 	ldr	r1, [r5, #8]
    58a4:	e2911000 	adds	r1, r1, #0
    58a8:	13a01001 	movne	r1, #1
    58ac:	eaffffcc 	b	57e4 <queues2_execute+0x24>
    58b0:	e321f01f 	msr	CPSR_c, #31
  test_assert_sequence(4, "ABCD");
    58b4:	e59f1230 	ldr	r1, [pc, #560]	; 5aec <queues2_execute+0x32c>
    58b8:	e3a00004 	mov	r0, #4
    58bc:	ebffec17 	bl	920 <_test_assert_sequence>
    58c0:	e3500000 	cmp	r0, #0
    58c4:	1afffff3 	bne	5898 <queues2_execute+0xd8>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    58c8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
    58cc:	e59f0214 	ldr	r0, [pc, #532]	; 5ae8 <queues2_execute+0x328>
    58d0:	ebffedfe 	bl	10d0 <chOQGetI>
    58d4:	e3700003 	cmn	r0, #3
    58d8:	13a01000 	movne	r1, #0
    58dc:	03a01001 	moveq	r1, #1
    58e0:	e3a00005 	mov	r0, #5
    58e4:	ebffec2d 	bl	9a0 <_test_assert>
    58e8:	e2503000 	subs	r3, r0, #0
    58ec:	1affffe8 	bne	5894 <queues2_execute+0xd4>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    58f0:	e321f01f 	msr	CPSR_c, #31
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
    58f4:	e3a02008 	mov	r2, #8
    58f8:	e59f11f0 	ldr	r1, [pc, #496]	; 5af0 <queues2_execute+0x330>
    58fc:	e59f01e4 	ldr	r0, [pc, #484]	; 5ae8 <queues2_execute+0x328>
    5900:	ebfff61a 	bl	3170 <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
    5904:	e2404004 	sub	r4, r0, #4
    5908:	e2741000 	rsbs	r1, r4, #0
    590c:	e0a11004 	adc	r1, r1, r4
    5910:	e3a00006 	mov	r0, #6
    5914:	ebffec21 	bl	9a0 <_test_assert>
    5918:	e3500000 	cmp	r0, #0
    591c:	1affffdd 	bne	5898 <queues2_execute+0xd8>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5920:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)(chQSpaceI(oqp) == 0U);
    5924:	e5951008 	ldr	r1, [r5, #8]
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
    5928:	e2711001 	rsbs	r1, r1, #1
    592c:	33a01000 	movcc	r1, #0
    5930:	e3a00007 	mov	r0, #7
    5934:	ebffec19 	bl	9a0 <_test_assert>
    5938:	e3500000 	cmp	r0, #0
    593c:	1affffd4 	bne	5894 <queues2_execute+0xd4>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5940:	e321f01f 	msr	CPSR_c, #31
  return ch.rlist.r_current;
    5944:	e59f31a8 	ldr	r3, [pc, #424]	; 5af4 <queues2_execute+0x334>
  return chThdGetSelfX()->p_prio;
    5948:	e5933018 	ldr	r3, [r3, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
    594c:	e5932008 	ldr	r2, [r3, #8]
    5950:	e3a01e13 	mov	r1, #304	; 0x130
    5954:	e58d0000 	str	r0, [sp]
    5958:	e59f3198 	ldr	r3, [pc, #408]	; 5af8 <queues2_execute+0x338>
    595c:	e2822001 	add	r2, r2, #1
    5960:	e59f0194 	ldr	r0, [pc, #404]	; 5afc <queues2_execute+0x33c>
    5964:	ebfff221 	bl	21f0 <chThdCreateStatic>
    5968:	e59f3190 	ldr	r3, [pc, #400]	; 5b00 <queues2_execute+0x340>
    596c:	e5830000 	str	r0, [r3]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5970:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
    5974:	e2853010 	add	r3, r5, #16
    5978:	e813000a 	ldmda	r3, {r1, r3}
    597c:	e0431001 	sub	r1, r3, r1
    5980:	e5953008 	ldr	r3, [r5, #8]
    5984:	e0411003 	sub	r1, r1, r3
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
    5988:	e241e004 	sub	lr, r1, #4
    598c:	e27e1000 	rsbs	r1, lr, #0
    5990:	e0a1100e 	adc	r1, r1, lr
    5994:	e3a00008 	mov	r0, #8
    5998:	ebffec00 	bl	9a0 <_test_assert>
    599c:	e3500000 	cmp	r0, #0
    59a0:	1affffbb 	bne	5894 <queues2_execute+0xd4>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    59a4:	e321f01f 	msr	CPSR_c, #31
  test_wait_threads();
    59a8:	ebfffdf4 	bl	5180 <test_wait_threads>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    59ac:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  oqp->q_counter = chQSizeX(oqp);
    59b0:	e285100c 	add	r1, r5, #12
    59b4:	e8910006 	ldm	r1, {r1, r2}
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    59b8:	e5953000 	ldr	r3, [r5]
    59bc:	e0422001 	sub	r2, r2, r1
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
    59c0:	e1530005 	cmp	r3, r5
  oqp->q_rdptr = oqp->q_buffer;
    59c4:	e5851018 	str	r1, [r5, #24]
  oqp->q_wrptr = oqp->q_buffer;
    59c8:	e5851014 	str	r1, [r5, #20]
  oqp->q_counter = chQSizeX(oqp);
    59cc:	e5852008 	str	r2, [r5, #8]
    59d0:	0a000009 	beq	59fc <queues2_execute+0x23c>
  tp->p_u.rdymsg = msg;
    59d4:	e3e04001 	mvn	r4, #1
  tqp->p_next = tp->p_next;
    59d8:	e5932000 	ldr	r2, [r3]
  (void) chSchReadyI(tp);
    59dc:	e1a00003 	mov	r0, r3
  tqp->p_next->p_prev = (thread_t *)tqp;
    59e0:	e5825004 	str	r5, [r2, #4]
  tp->p_u.rdymsg = msg;
    59e4:	e5834024 	str	r4, [r3, #36]	; 0x24
  tqp->p_next = tp->p_next;
    59e8:	e5852000 	str	r2, [r5]
  (void) chSchReadyI(tp);
    59ec:	ebffed6f 	bl	fb0 <chSchReadyI>
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    59f0:	e5953000 	ldr	r3, [r5]
    59f4:	e1530005 	cmp	r3, r5
    59f8:	1afffff6 	bne	59d8 <queues2_execute+0x218>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    59fc:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5a00:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    5a04:	e2853010 	add	r3, r5, #16
    5a08:	e813000a 	ldmda	r3, {r1, r3}
    5a0c:	e0431001 	sub	r1, r3, r1
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
    5a10:	e5953008 	ldr	r3, [r5, #8]
    5a14:	e041c003 	sub	ip, r1, r3
    5a18:	e27c1000 	rsbs	r1, ip, #0
    5a1c:	e0a1100c 	adc	r1, r1, ip
    5a20:	e3a00009 	mov	r0, #9
    5a24:	ebffebdd 	bl	9a0 <_test_assert>
    5a28:	e2503000 	subs	r3, r0, #0
    5a2c:	1affff98 	bne	5894 <queues2_execute+0xd4>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5a30:	e321f01f 	msr	CPSR_c, #31
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    5a34:	e3a02002 	mov	r2, #2
    5a38:	e59f10b0 	ldr	r1, [pc, #176]	; 5af0 <queues2_execute+0x330>
    5a3c:	e59f00a4 	ldr	r0, [pc, #164]	; 5ae8 <queues2_execute+0x328>
    5a40:	ebfff5ca 	bl	3170 <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    5a44:	e2402002 	sub	r2, r0, #2
    5a48:	e2721000 	rsbs	r1, r2, #0
    5a4c:	e0a11002 	adc	r1, r1, r2
    5a50:	e3a0000a 	mov	r0, #10
    5a54:	ebffebd1 	bl	9a0 <_test_assert>
    5a58:	e2503000 	subs	r3, r0, #0
    5a5c:	1affff8d 	bne	5898 <queues2_execute+0xd8>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    5a60:	e3a02002 	mov	r2, #2
    5a64:	e59f1084 	ldr	r1, [pc, #132]	; 5af0 <queues2_execute+0x330>
    5a68:	e59f0078 	ldr	r0, [pc, #120]	; 5ae8 <queues2_execute+0x328>
    5a6c:	ebfff5bf 	bl	3170 <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    5a70:	e2403002 	sub	r3, r0, #2
    5a74:	e2731000 	rsbs	r1, r3, #0
    5a78:	e0a11003 	adc	r1, r1, r3
    5a7c:	e3a0000b 	mov	r0, #11
    5a80:	ebffebc6 	bl	9a0 <_test_assert>
    5a84:	e3500000 	cmp	r0, #0
    5a88:	1affff82 	bne	5898 <queues2_execute+0xd8>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5a8c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)(chQSpaceI(oqp) == 0U);
    5a90:	e5951008 	ldr	r1, [r5, #8]
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
    5a94:	e2711001 	rsbs	r1, r1, #1
    5a98:	33a01000 	movcc	r1, #0
    5a9c:	e3a0000c 	mov	r0, #12
    5aa0:	ebffebbe 	bl	9a0 <_test_assert>
    5aa4:	e2501000 	subs	r1, r0, #0
    5aa8:	1affff79 	bne	5894 <queues2_execute+0xd4>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5aac:	e321f01f 	msr	CPSR_c, #31
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
    5ab0:	e3a0200a 	mov	r2, #10
    5ab4:	e59f002c 	ldr	r0, [pc, #44]	; 5ae8 <queues2_execute+0x328>
    5ab8:	ebfff5e4 	bl	3250 <chOQPutTimeout>
    5abc:	e3700001 	cmn	r0, #1
    5ac0:	13a01000 	movne	r1, #0
    5ac4:	03a01001 	moveq	r1, #1
    5ac8:	e3a0000d 	mov	r0, #13
}
    5acc:	e28dd00c 	add	sp, sp, #12
    5ad0:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
    5ad4:	eaffebb1 	b	9a0 <_test_assert>
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
    5ad8:	e5957008 	ldr	r7, [r5, #8]
    5adc:	e2977000 	adds	r7, r7, #0
    5ae0:	13a07001 	movne	r7, #1
    5ae4:	eaffff65 	b	5880 <queues2_execute+0xc0>
    5ae8:	40000ae0 	.word	0x40000ae0
    5aec:	00008530 	.word	0x00008530
    5af0:	40000f30 	.word	0x40000f30
    5af4:	40000c00 	.word	0x40000c00
    5af8:	000032e0 	.word	0x000032e0
    5afc:	40000e00 	.word	0x40000e00
    5b00:	4000141c 	.word	0x4000141c
	...

00005b10 <queues1_execute>:
static void queues1_execute(void) {
    5b10:	e92d4070 	push	{r4, r5, r6, lr}
    5b14:	e24dd008 	sub	sp, sp, #8
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5b18:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)(chQSpaceI(iqp) == 0U);
    5b1c:	e59f4364 	ldr	r4, [pc, #868]	; 5e88 <queues1_execute+0x378>
    5b20:	e5941008 	ldr	r1, [r4, #8]
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
    5b24:	e2711001 	rsbs	r1, r1, #1
    5b28:	33a01000 	movcc	r1, #0
    5b2c:	e3a00001 	mov	r0, #1
    5b30:	ebffeb9a 	bl	9a0 <_test_assert>
    5b34:	e2505000 	subs	r5, r0, #0
    5b38:	1a000018 	bne	5ba0 <queues1_execute+0x90>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5b3c:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5b40:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    chIQPutI(&iq, 'A' + i);
    5b44:	e3a01041 	mov	r1, #65	; 0x41
    5b48:	e1a00004 	mov	r0, r4
    5b4c:	ebffed37 	bl	1030 <chIQPutI>
    5b50:	e1a00004 	mov	r0, r4
    5b54:	e3a01042 	mov	r1, #66	; 0x42
    5b58:	ebffed34 	bl	1030 <chIQPutI>
    5b5c:	e1a00004 	mov	r0, r4
    5b60:	e3a01043 	mov	r1, #67	; 0x43
    5b64:	ebffed31 	bl	1030 <chIQPutI>
    5b68:	e1a00004 	mov	r0, r4
    5b6c:	e3a01044 	mov	r1, #68	; 0x44
    5b70:	ebffed2e 	bl	1030 <chIQPutI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5b74:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5b78:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
    5b7c:	e5942018 	ldr	r2, [r4, #24]
    5b80:	e5943014 	ldr	r3, [r4, #20]
    5b84:	e1520003 	cmp	r2, r3
    5b88:	0a0000ba 	beq	5e78 <queues1_execute+0x368>
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
    5b8c:	e1a01005 	mov	r1, r5
    5b90:	e3a00002 	mov	r0, #2
    5b94:	ebffeb81 	bl	9a0 <_test_assert>
    5b98:	e2501000 	subs	r1, r0, #0
    5b9c:	0a000002 	beq	5bac <queues1_execute+0x9c>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5ba0:	e321f01f 	msr	CPSR_c, #31
}
    5ba4:	e28dd008 	add	sp, sp, #8
    5ba8:	e8bd8070 	pop	{r4, r5, r6, pc}
    5bac:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5bb0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
    5bb4:	e59f02cc 	ldr	r0, [pc, #716]	; 5e88 <queues1_execute+0x378>
    5bb8:	ebffed1c 	bl	1030 <chIQPutI>
    5bbc:	e3700004 	cmn	r0, #4
    5bc0:	13a01000 	movne	r1, #0
    5bc4:	03a01001 	moveq	r1, #1
    5bc8:	e3a00003 	mov	r0, #3
    5bcc:	ebffeb73 	bl	9a0 <_test_assert>
    5bd0:	e3500000 	cmp	r0, #0
    5bd4:	1afffff1 	bne	5ba0 <queues1_execute+0x90>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5bd8:	e321f01f 	msr	CPSR_c, #31
    5bdc:	e3a05004 	mov	r5, #4
  return chIQGetTimeout(iqp, TIME_INFINITE);
    5be0:	e59f62a0 	ldr	r6, [pc, #672]	; 5e88 <queues1_execute+0x378>
    5be4:	e3e01000 	mvn	r1, #0
    5be8:	e1a00006 	mov	r0, r6
    5bec:	ebfff5ff 	bl	33f0 <chIQGetTimeout>
    test_emit_token(chIQGet(&iq));
    5bf0:	e20000ff 	and	r0, r0, #255	; 0xff
    5bf4:	ebffeb79 	bl	9e0 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    5bf8:	e2555001 	subs	r5, r5, #1
    5bfc:	1afffff8 	bne	5be4 <queues1_execute+0xd4>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5c00:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return (bool)(chQSpaceI(iqp) == 0U);
    5c04:	e5941008 	ldr	r1, [r4, #8]
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
    5c08:	e2711001 	rsbs	r1, r1, #1
    5c0c:	33a01000 	movcc	r1, #0
    5c10:	e3a00004 	mov	r0, #4
    5c14:	ebffeb61 	bl	9a0 <_test_assert>
    5c18:	e3500000 	cmp	r0, #0
    5c1c:	1affffdf 	bne	5ba0 <queues1_execute+0x90>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5c20:	e321f01f 	msr	CPSR_c, #31
  test_assert_sequence(5, "ABCD");
    5c24:	e59f1260 	ldr	r1, [pc, #608]	; 5e8c <queues1_execute+0x37c>
    5c28:	e3a00005 	mov	r0, #5
    5c2c:	ebffeb3b 	bl	920 <_test_assert_sequence>
    5c30:	e3500000 	cmp	r0, #0
    5c34:	1affffda 	bne	5ba4 <queues1_execute+0x94>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5c38:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    chIQPutI(&iq, 'A' + i);
    5c3c:	e3a01041 	mov	r1, #65	; 0x41
    5c40:	e59f0240 	ldr	r0, [pc, #576]	; 5e88 <queues1_execute+0x378>
    5c44:	ebffecf9 	bl	1030 <chIQPutI>
    5c48:	e3a01042 	mov	r1, #66	; 0x42
    5c4c:	e59f0234 	ldr	r0, [pc, #564]	; 5e88 <queues1_execute+0x378>
    5c50:	ebffecf6 	bl	1030 <chIQPutI>
    5c54:	e3a01043 	mov	r1, #67	; 0x43
    5c58:	e59f0228 	ldr	r0, [pc, #552]	; 5e88 <queues1_execute+0x378>
    5c5c:	ebffecf3 	bl	1030 <chIQPutI>
    5c60:	e3a01044 	mov	r1, #68	; 0x44
    5c64:	e59f021c 	ldr	r0, [pc, #540]	; 5e88 <queues1_execute+0x378>
    5c68:	ebffecf0 	bl	1030 <chIQPutI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5c6c:	e321f01f 	msr	CPSR_c, #31
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
    5c70:	e3a02008 	mov	r2, #8
    5c74:	e1a03005 	mov	r3, r5
    5c78:	e59f1210 	ldr	r1, [pc, #528]	; 5e90 <queues1_execute+0x380>
    5c7c:	e59f0204 	ldr	r0, [pc, #516]	; 5e88 <queues1_execute+0x378>
    5c80:	ebfff5a6 	bl	3320 <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
    5c84:	e2400004 	sub	r0, r0, #4
    5c88:	e2701000 	rsbs	r1, r0, #0
    5c8c:	e0a11000 	adc	r1, r1, r0
    5c90:	e3a00006 	mov	r0, #6
    5c94:	ebffeb41 	bl	9a0 <_test_assert>
    5c98:	e3500000 	cmp	r0, #0
    5c9c:	1affffc0 	bne	5ba4 <queues1_execute+0x94>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5ca0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    5ca4:	e5941008 	ldr	r1, [r4, #8]
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
    5ca8:	e2711001 	rsbs	r1, r1, #1
    5cac:	33a01000 	movcc	r1, #0
    5cb0:	e3a00007 	mov	r0, #7
    5cb4:	ebffeb39 	bl	9a0 <_test_assert>
    5cb8:	e3500000 	cmp	r0, #0
    5cbc:	1affffb7 	bne	5ba0 <queues1_execute+0x90>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5cc0:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5cc4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    chIQPutI(&iq, 'A' + i);
    5cc8:	e3a01041 	mov	r1, #65	; 0x41
    5ccc:	e59f01b4 	ldr	r0, [pc, #436]	; 5e88 <queues1_execute+0x378>
    5cd0:	ebffecd6 	bl	1030 <chIQPutI>
    5cd4:	e3a01042 	mov	r1, #66	; 0x42
    5cd8:	e59f01a8 	ldr	r0, [pc, #424]	; 5e88 <queues1_execute+0x378>
    5cdc:	ebffecd3 	bl	1030 <chIQPutI>
    5ce0:	e3a01043 	mov	r1, #67	; 0x43
    5ce4:	e59f019c 	ldr	r0, [pc, #412]	; 5e88 <queues1_execute+0x378>
    5ce8:	ebffecd0 	bl	1030 <chIQPutI>
    5cec:	e3a01044 	mov	r1, #68	; 0x44
    5cf0:	e59f0190 	ldr	r0, [pc, #400]	; 5e88 <queues1_execute+0x378>
    5cf4:	ebffeccd 	bl	1030 <chIQPutI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5cf8:	e321f01f 	msr	CPSR_c, #31
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    5cfc:	e3a02002 	mov	r2, #2
    5d00:	e1a03005 	mov	r3, r5
    5d04:	e59f1184 	ldr	r1, [pc, #388]	; 5e90 <queues1_execute+0x380>
    5d08:	e59f0178 	ldr	r0, [pc, #376]	; 5e88 <queues1_execute+0x378>
    5d0c:	ebfff583 	bl	3320 <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    5d10:	e2402002 	sub	r2, r0, #2
    5d14:	e2721000 	rsbs	r1, r2, #0
    5d18:	e0a11002 	adc	r1, r1, r2
    5d1c:	e3a00008 	mov	r0, #8
    5d20:	ebffeb1e 	bl	9a0 <_test_assert>
    5d24:	e3500000 	cmp	r0, #0
    5d28:	1affff9d 	bne	5ba4 <queues1_execute+0x94>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
    5d2c:	e1a03005 	mov	r3, r5
    5d30:	e3a02002 	mov	r2, #2
    5d34:	e59f1154 	ldr	r1, [pc, #340]	; 5e90 <queues1_execute+0x380>
    5d38:	e59f0148 	ldr	r0, [pc, #328]	; 5e88 <queues1_execute+0x378>
    5d3c:	ebfff577 	bl	3320 <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
    5d40:	e2403002 	sub	r3, r0, #2
    5d44:	e2731000 	rsbs	r1, r3, #0
    5d48:	e0a11003 	adc	r1, r1, r3
    5d4c:	e3a00009 	mov	r0, #9
    5d50:	ebffeb12 	bl	9a0 <_test_assert>
    5d54:	e3500000 	cmp	r0, #0
    5d58:	1affff91 	bne	5ba4 <queues1_execute+0x94>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5d5c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    5d60:	e5941008 	ldr	r1, [r4, #8]
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
    5d64:	e2711001 	rsbs	r1, r1, #1
    5d68:	33a01000 	movcc	r1, #0
    5d6c:	e3a0000a 	mov	r0, #10
    5d70:	ebffeb0a 	bl	9a0 <_test_assert>
    5d74:	e3500000 	cmp	r0, #0
    5d78:	1affff88 	bne	5ba0 <queues1_execute+0x90>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5d7c:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5d80:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chIQPutI(&iq, 0);
    5d84:	e59f00fc 	ldr	r0, [pc, #252]	; 5e88 <queues1_execute+0x378>
    5d88:	e1a01005 	mov	r1, r5
    5d8c:	ebffeca7 	bl	1030 <chIQPutI>
    5d90:	e5943000 	ldr	r3, [r4]
  iqp->q_rdptr = iqp->q_buffer;
    5d94:	e594200c 	ldr	r2, [r4, #12]
    5d98:	e1530004 	cmp	r3, r4
  iqp->q_counter = 0;
    5d9c:	e5845008 	str	r5, [r4, #8]
  iqp->q_rdptr = iqp->q_buffer;
    5da0:	e5842018 	str	r2, [r4, #24]
  iqp->q_wrptr = iqp->q_buffer;
    5da4:	e5842014 	str	r2, [r4, #20]
    5da8:	0a000009 	beq	5dd4 <queues1_execute+0x2c4>
  tp->p_u.rdymsg = msg;
    5dac:	e3e05001 	mvn	r5, #1
  tqp->p_next = tp->p_next;
    5db0:	e5932000 	ldr	r2, [r3]
  (void) chSchReadyI(tp);
    5db4:	e1a00003 	mov	r0, r3
  tqp->p_next->p_prev = (thread_t *)tqp;
    5db8:	e5824004 	str	r4, [r2, #4]
  tp->p_u.rdymsg = msg;
    5dbc:	e5835024 	str	r5, [r3, #36]	; 0x24
  tqp->p_next = tp->p_next;
    5dc0:	e5842000 	str	r2, [r4]
  (void) chSchReadyI(tp);
    5dc4:	ebffec79 	bl	fb0 <chSchReadyI>
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    5dc8:	e5943000 	ldr	r3, [r4]
    5dcc:	e1530004 	cmp	r3, r4
    5dd0:	1afffff6 	bne	5db0 <queues1_execute+0x2a0>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5dd4:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5dd8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
    5ddc:	e5941008 	ldr	r1, [r4, #8]
    5de0:	e2711001 	rsbs	r1, r1, #1
    5de4:	33a01000 	movcc	r1, #0
    5de8:	e3a0000b 	mov	r0, #11
    5dec:	ebffeaeb 	bl	9a0 <_test_assert>
    5df0:	e3500000 	cmp	r0, #0
    5df4:	1affff69 	bne	5ba0 <queues1_execute+0x90>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5df8:	e321f01f 	msr	CPSR_c, #31
  return ch.rlist.r_current;
    5dfc:	e59f3090 	ldr	r3, [pc, #144]	; 5e94 <queues1_execute+0x384>
  return chThdGetSelfX()->p_prio;
    5e00:	e5933018 	ldr	r3, [r3, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
    5e04:	e5932008 	ldr	r2, [r3, #8]
    5e08:	e3a01e13 	mov	r1, #304	; 0x130
    5e0c:	e58d0000 	str	r0, [sp]
    5e10:	e59f3080 	ldr	r3, [pc, #128]	; 5e98 <queues1_execute+0x388>
    5e14:	e2822001 	add	r2, r2, #1
    5e18:	e59f007c 	ldr	r0, [pc, #124]	; 5e9c <queues1_execute+0x38c>
    5e1c:	ebfff0f3 	bl	21f0 <chThdCreateStatic>
    5e20:	e59f3078 	ldr	r3, [pc, #120]	; 5ea0 <queues1_execute+0x390>
    5e24:	e5830000 	str	r0, [r3]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5e28:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
    5e2c:	e5941008 	ldr	r1, [r4, #8]
    5e30:	e2711001 	rsbs	r1, r1, #1
    5e34:	33a01000 	movcc	r1, #0
    5e38:	e3a0000c 	mov	r0, #12
    5e3c:	ebffead7 	bl	9a0 <_test_assert>
    5e40:	e3500000 	cmp	r0, #0
    5e44:	1affff55 	bne	5ba0 <queues1_execute+0x90>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5e48:	e321f01f 	msr	CPSR_c, #31
  test_wait_threads();
    5e4c:	ebfffccb 	bl	5180 <test_wait_threads>
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
    5e50:	e3a0100a 	mov	r1, #10
    5e54:	e59f002c 	ldr	r0, [pc, #44]	; 5e88 <queues1_execute+0x378>
    5e58:	ebfff564 	bl	33f0 <chIQGetTimeout>
    5e5c:	e3700001 	cmn	r0, #1
    5e60:	13a01000 	movne	r1, #0
    5e64:	03a01001 	moveq	r1, #1
    5e68:	e3a0000d 	mov	r0, #13
}
    5e6c:	e28dd008 	add	sp, sp, #8
    5e70:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
    5e74:	eaffeac9 	b	9a0 <_test_assert>
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
    5e78:	e5945008 	ldr	r5, [r4, #8]
    5e7c:	e2955000 	adds	r5, r5, #0
    5e80:	13a05001 	movne	r5, #1
    5e84:	eaffff40 	b	5b8c <queues1_execute+0x7c>
    5e88:	40000a68 	.word	0x40000a68
    5e8c:	00008530 	.word	0x00008530
    5e90:	40000f30 	.word	0x40000f30
    5e94:	40000c00 	.word	0x40000c00
    5e98:	00003470 	.word	0x00003470
    5e9c:	40000e00 	.word	0x40000e00
    5ea0:	4000141c 	.word	0x4000141c
	...

00005eb0 <dyn2_execute>:
  for (i = 0; i < 4; i++)
    5eb0:	e3a03000 	mov	r3, #0
  return ch.rlist.r_current;
    5eb4:	e59f213c 	ldr	r2, [pc, #316]	; 5ff8 <dyn2_execute+0x148>
  return chThdGetSelfX()->p_prio;
    5eb8:	e5921018 	ldr	r1, [r2, #24]
static void dyn2_execute(void) {
    5ebc:	e92d4070 	push	{r4, r5, r6, lr}
    5ec0:	e59f2134 	ldr	r2, [pc, #308]	; 5ffc <dyn2_execute+0x14c>
    5ec4:	e5915008 	ldr	r5, [r1, #8]
    5ec8:	e59fc130 	ldr	ip, [pc, #304]	; 6000 <dyn2_execute+0x150>
    5ecc:	e59f1130 	ldr	r1, [pc, #304]	; 6004 <dyn2_execute+0x154>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    5ed0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  php->ph_next = mp->mp_next;
    5ed4:	e5910000 	ldr	r0, [r1]
    5ed8:	e5820000 	str	r0, [r2]
  mp->mp_next = php;
    5edc:	e5812000 	str	r2, [r1]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    5ee0:	e321f01f 	msr	CPSR_c, #31
  for (i = 0; i < 4; i++)
    5ee4:	e2833001 	add	r3, r3, #1
    5ee8:	e3530004 	cmp	r3, #4
    5eec:	179c2103 	ldrne	r2, [ip, r3, lsl #2]
    5ef0:	1afffff6 	bne	5ed0 <dyn2_execute+0x20>
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
    5ef4:	e59f110c 	ldr	r1, [pc, #268]	; 6008 <dyn2_execute+0x158>
    5ef8:	e2450001 	sub	r0, r5, #1
    5efc:	ebfff03b 	bl	1ff0 <chThdCreateFromMemoryPool.constprop.48>
    5f00:	e59f4104 	ldr	r4, [pc, #260]	; 600c <dyn2_execute+0x15c>
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
    5f04:	e59f1104 	ldr	r1, [pc, #260]	; 6010 <dyn2_execute+0x160>
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
    5f08:	e5840000 	str	r0, [r4]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
    5f0c:	e2450002 	sub	r0, r5, #2
    5f10:	ebfff036 	bl	1ff0 <chThdCreateFromMemoryPool.constprop.48>
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
    5f14:	e59f10f8 	ldr	r1, [pc, #248]	; 6014 <dyn2_execute+0x164>
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
    5f18:	e5840004 	str	r0, [r4, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
    5f1c:	e2450003 	sub	r0, r5, #3
    5f20:	ebfff032 	bl	1ff0 <chThdCreateFromMemoryPool.constprop.48>
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
    5f24:	e59f10ec 	ldr	r1, [pc, #236]	; 6018 <dyn2_execute+0x168>
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
    5f28:	e5840008 	str	r0, [r4, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
    5f2c:	e2450004 	sub	r0, r5, #4
    5f30:	ebfff02e 	bl	1ff0 <chThdCreateFromMemoryPool.constprop.48>
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
    5f34:	e59f10e0 	ldr	r1, [pc, #224]	; 601c <dyn2_execute+0x16c>
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
    5f38:	e584000c 	str	r0, [r4, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
    5f3c:	e2450005 	sub	r0, r5, #5
    5f40:	ebfff02a 	bl	1ff0 <chThdCreateFromMemoryPool.constprop.48>
  test_assert(1, (threads[0] != NULL) &&
    5f44:	e5941000 	ldr	r1, [r4]
    5f48:	e3510000 	cmp	r1, #0
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
    5f4c:	e5840010 	str	r0, [r4, #16]
  test_assert(1, (threads[0] != NULL) &&
    5f50:	0a00000b 	beq	5f84 <dyn2_execute+0xd4>
    5f54:	e5941004 	ldr	r1, [r4, #4]
    5f58:	e3510000 	cmp	r1, #0
    5f5c:	0a000008 	beq	5f84 <dyn2_execute+0xd4>
    5f60:	e5941008 	ldr	r1, [r4, #8]
    5f64:	e3510000 	cmp	r1, #0
    5f68:	0a000005 	beq	5f84 <dyn2_execute+0xd4>
    5f6c:	e2700001 	rsbs	r0, r0, #1
    5f70:	33a00000 	movcc	r0, #0
    5f74:	e594100c 	ldr	r1, [r4, #12]
    5f78:	e3510000 	cmp	r1, #0
    5f7c:	11a01000 	movne	r1, r0
    5f80:	03a01000 	moveq	r1, #0
    5f84:	e3a00001 	mov	r0, #1
    5f88:	ebffea84 	bl	9a0 <_test_assert>
    5f8c:	e3500000 	cmp	r0, #0
    5f90:	18bd8070 	popne	{r4, r5, r6, pc}
  test_wait_threads();
    5f94:	ebfffc79 	bl	5180 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
    5f98:	e59f1080 	ldr	r1, [pc, #128]	; 6020 <dyn2_execute+0x170>
    5f9c:	e3a00002 	mov	r0, #2
    5fa0:	ebffea5e 	bl	920 <_test_assert_sequence>
    5fa4:	e3500000 	cmp	r0, #0
    5fa8:	18bd8070 	popne	{r4, r5, r6, pc}
    5fac:	e3a04004 	mov	r4, #4
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
    5fb0:	e59f504c 	ldr	r5, [pc, #76]	; 6004 <dyn2_execute+0x154>
    5fb4:	e1a00005 	mov	r0, r5
    5fb8:	ebffead0 	bl	b00 <chPoolAlloc>
    5fbc:	e2901000 	adds	r1, r0, #0
    5fc0:	13a01001 	movne	r1, #1
    5fc4:	e3a00003 	mov	r0, #3
    5fc8:	ebffea74 	bl	9a0 <_test_assert>
    5fcc:	e3500000 	cmp	r0, #0
    5fd0:	18bd8070 	popne	{r4, r5, r6, pc}
  for (i = 0; i < 4; i++)
    5fd4:	e2544001 	subs	r4, r4, #1
    5fd8:	1afffff5 	bne	5fb4 <dyn2_execute+0x104>
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
    5fdc:	e59f0020 	ldr	r0, [pc, #32]	; 6004 <dyn2_execute+0x154>
    5fe0:	ebffeac6 	bl	b00 <chPoolAlloc>
    5fe4:	e2701001 	rsbs	r1, r0, #1
    5fe8:	33a01000 	movcc	r1, #0
    5fec:	e3a00004 	mov	r0, #4
}
    5ff0:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
    5ff4:	eaffea69 	b	9a0 <_test_assert>
    5ff8:	40000c00 	.word	0x40000c00
    5ffc:	40000e00 	.word	0x40000e00
    6000:	00008d50 	.word	0x00008d50
    6004:	40000dd0 	.word	0x40000dd0
    6008:	000081a0 	.word	0x000081a0
    600c:	4000141c 	.word	0x4000141c
    6010:	00008190 	.word	0x00008190
    6014:	00008194 	.word	0x00008194
    6018:	00008198 	.word	0x00008198
    601c:	000083b4 	.word	0x000083b4
    6020:	00008530 	.word	0x00008530
	...

00006030 <dyn1_execute>:
static void dyn1_execute(void) {
    6030:	e92d4070 	push	{r4, r5, r6, lr}
  return ch.rlist.r_current;
    6034:	e59f3128 	ldr	r3, [pc, #296]	; 6164 <dyn1_execute+0x134>
  return chThdGetSelfX()->p_prio;
    6038:	e5933018 	ldr	r3, [r3, #24]
    603c:	e24dd008 	sub	sp, sp, #8
    6040:	e5935008 	ldr	r5, [r3, #8]
  (void)chHeapStatus(&heap1, &sz);
    6044:	e1a0100d 	mov	r1, sp
    6048:	e59f0118 	ldr	r0, [pc, #280]	; 6168 <dyn1_execute+0x138>
    604c:	ebfff8f7 	bl	4430 <chHeapStatus>
  threads[0] = chThdCreateFromHeap(&heap1,
    6050:	e59f1114 	ldr	r1, [pc, #276]	; 616c <dyn1_execute+0x13c>
    6054:	e2450001 	sub	r0, r5, #1
    6058:	ebfff9c8 	bl	4780 <chThdCreateFromHeap.constprop.49>
    605c:	e59f410c 	ldr	r4, [pc, #268]	; 6170 <dyn1_execute+0x140>
  threads[1] = chThdCreateFromHeap(&heap1,
    6060:	e59f110c 	ldr	r1, [pc, #268]	; 6174 <dyn1_execute+0x144>
  threads[0] = chThdCreateFromHeap(&heap1,
    6064:	e5840000 	str	r0, [r4]
  threads[1] = chThdCreateFromHeap(&heap1,
    6068:	e2450002 	sub	r0, r5, #2
    606c:	ebfff9c3 	bl	4780 <chThdCreateFromHeap.constprop.49>
  (void)chHeapStatus(&heap1, &n);
    6070:	e28d1004 	add	r1, sp, #4
  threads[1] = chThdCreateFromHeap(&heap1,
    6074:	e5840004 	str	r0, [r4, #4]
  (void)chHeapStatus(&heap1, &n);
    6078:	e59f00e8 	ldr	r0, [pc, #232]	; 6168 <dyn1_execute+0x138>
    607c:	ebfff8eb 	bl	4430 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
    6080:	e59d1004 	ldr	r1, [sp, #4]
    6084:	e59f00dc 	ldr	r0, [pc, #220]	; 6168 <dyn1_execute+0x138>
    6088:	ebfff984 	bl	46a0 <chHeapAlloc>
  threads[2] = chThdCreateFromHeap(&heap1,
    608c:	e59f10e4 	ldr	r1, [pc, #228]	; 6178 <dyn1_execute+0x148>
  p1 = chHeapAlloc(&heap1, n);
    6090:	e1a06000 	mov	r6, r0
  threads[2] = chThdCreateFromHeap(&heap1,
    6094:	e2450003 	sub	r0, r5, #3
    6098:	ebfff9b8 	bl	4780 <chThdCreateFromHeap.constprop.49>
    609c:	e5840008 	str	r0, [r4, #8]
  chHeapFree(p1);
    60a0:	e1a00006 	mov	r0, r6
    60a4:	ebfff8fd 	bl	44a0 <chHeapFree>
  test_assert(1, (threads[0] != NULL) &&
    60a8:	e5941000 	ldr	r1, [r4]
    60ac:	e3510000 	cmp	r1, #0
    60b0:	0a000006 	beq	60d0 <dyn1_execute+0xa0>
    60b4:	e5941004 	ldr	r1, [r4, #4]
    60b8:	e3510000 	cmp	r1, #0
    60bc:	0a000003 	beq	60d0 <dyn1_execute+0xa0>
    60c0:	e5941008 	ldr	r1, [r4, #8]
    60c4:	e3510000 	cmp	r1, #0
    60c8:	13a01000 	movne	r1, #0
    60cc:	0a00001d 	beq	6148 <dyn1_execute+0x118>
    60d0:	e3a00001 	mov	r0, #1
    60d4:	ebffea31 	bl	9a0 <_test_assert>
    60d8:	e3500000 	cmp	r0, #0
    60dc:	0a000001 	beq	60e8 <dyn1_execute+0xb8>
}
    60e0:	e28dd008 	add	sp, sp, #8
    60e4:	e8bd8070 	pop	{r4, r5, r6, pc}
  test_wait_threads();
    60e8:	ebfffc24 	bl	5180 <test_wait_threads>
  test_assert_sequence(2, "AB");
    60ec:	e59f1088 	ldr	r1, [pc, #136]	; 617c <dyn1_execute+0x14c>
    60f0:	e3a00002 	mov	r0, #2
    60f4:	ebffea09 	bl	920 <_test_assert_sequence>
    60f8:	e3500000 	cmp	r0, #0
    60fc:	1afffff7 	bne	60e0 <dyn1_execute+0xb0>
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
    6100:	e28d1004 	add	r1, sp, #4
    6104:	e59f005c 	ldr	r0, [pc, #92]	; 6168 <dyn1_execute+0x138>
    6108:	ebfff8c8 	bl	4430 <chHeapStatus>
    610c:	e2402001 	sub	r2, r0, #1
    6110:	e2721000 	rsbs	r1, r2, #0
    6114:	e0a11002 	adc	r1, r1, r2
    6118:	e3a00003 	mov	r0, #3
    611c:	ebffea1f 	bl	9a0 <_test_assert>
    6120:	e3500000 	cmp	r0, #0
    6124:	1affffed 	bne	60e0 <dyn1_execute+0xb0>
  test_assert(4, n == sz, "heap size changed");
    6128:	e59d1004 	ldr	r1, [sp, #4]
    612c:	e59d3000 	ldr	r3, [sp]
    6130:	e0413003 	sub	r3, r1, r3
    6134:	e2731000 	rsbs	r1, r3, #0
    6138:	e0a11003 	adc	r1, r1, r3
    613c:	e3a00004 	mov	r0, #4
    6140:	ebffea16 	bl	9a0 <_test_assert>
    6144:	eaffffe5 	b	60e0 <dyn1_execute+0xb0>
  test_assert(1, (threads[0] != NULL) &&
    6148:	e594300c 	ldr	r3, [r4, #12]
    614c:	e3530000 	cmp	r3, #0
    6150:	1affffde 	bne	60d0 <dyn1_execute+0xa0>
    6154:	e5941010 	ldr	r1, [r4, #16]
    6158:	e2711001 	rsbs	r1, r1, #1
    615c:	33a01000 	movcc	r1, #0
    6160:	eaffffda 	b	60d0 <dyn1_execute+0xa0>
    6164:	40000c00 	.word	0x40000c00
    6168:	40000d78 	.word	0x40000d78
    616c:	000081a0 	.word	0x000081a0
    6170:	4000141c 	.word	0x4000141c
    6174:	00008190 	.word	0x00008190
    6178:	00008194 	.word	0x00008194
    617c:	00008180 	.word	0x00008180

00006180 <evt2_execute>:
static void evt2_execute(void) {
    6180:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6184:	e24dd034 	sub	sp, sp, #52	; 0x34
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    6188:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  currp->p_epending |= events;
    618c:	e59f4380 	ldr	r4, [pc, #896]	; 6514 <evt2_execute+0x394>
    6190:	e5942018 	ldr	r2, [r4, #24]
    6194:	e5923038 	ldr	r3, [r2, #56]	; 0x38
    6198:	e3833007 	orr	r3, r3, #7
    619c:	e5823038 	str	r3, [r2, #56]	; 0x38
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    61a0:	e321f01f 	msr	CPSR_c, #31
  m = chEvtWaitOne(ALL_EVENTS);
    61a4:	ebfff0a9 	bl	2450 <chEvtWaitOne.constprop.28>
  test_assert(1, m == 1, "single event error");
    61a8:	e2407001 	sub	r7, r0, #1
    61ac:	e2771000 	rsbs	r1, r7, #0
    61b0:	e0a11007 	adc	r1, r1, r7
    61b4:	e3a00001 	mov	r0, #1
    61b8:	ebffe9f8 	bl	9a0 <_test_assert>
    61bc:	e3500000 	cmp	r0, #0
    61c0:	0a000001 	beq	61cc <evt2_execute+0x4c>
}
    61c4:	e28dd034 	add	sp, sp, #52	; 0x34
    61c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  m = chEvtWaitOne(ALL_EVENTS);
    61cc:	ebfff09f 	bl	2450 <chEvtWaitOne.constprop.28>
  test_assert(2, m == 2, "single event error");
    61d0:	e2406002 	sub	r6, r0, #2
    61d4:	e2761000 	rsbs	r1, r6, #0
    61d8:	e0a11006 	adc	r1, r1, r6
    61dc:	e3a00002 	mov	r0, #2
    61e0:	ebffe9ee 	bl	9a0 <_test_assert>
    61e4:	e3500000 	cmp	r0, #0
    61e8:	1afffff5 	bne	61c4 <evt2_execute+0x44>
  m = chEvtWaitOne(ALL_EVENTS);
    61ec:	ebfff097 	bl	2450 <chEvtWaitOne.constprop.28>
  test_assert(3, m == 4, "single event error");
    61f0:	e2405004 	sub	r5, r0, #4
    61f4:	e2751000 	rsbs	r1, r5, #0
    61f8:	e0a11005 	adc	r1, r1, r5
    61fc:	e3a00003 	mov	r0, #3
    6200:	ebffe9e6 	bl	9a0 <_test_assert>
    6204:	e3500000 	cmp	r0, #0
    6208:	1affffed 	bne	61c4 <evt2_execute+0x44>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    620c:	ebffe7e7 	bl	1b0 <chEvtGetAndClearEvents.constprop.32>
  test_assert(4, m == 0, "stuck event");
    6210:	e2701001 	rsbs	r1, r0, #1
    6214:	33a01000 	movcc	r1, #0
    6218:	e3a00004 	mov	r0, #4
    621c:	ebffe9df 	bl	9a0 <_test_assert>
    6220:	e3500000 	cmp	r0, #0
    6224:	1affffe6 	bne	61c4 <evt2_execute+0x44>
  test_wait_tick();
    6228:	ebfff548 	bl	3750 <test_wait_tick>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    622c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    6230:	e5945028 	ldr	r5, [r4, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    6234:	e321f01f 	msr	CPSR_c, #31
  return ch.rlist.r_current;
    6238:	e5941018 	ldr	r1, [r4, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
    623c:	e5912008 	ldr	r2, [r1, #8]
    6240:	e59f32d0 	ldr	r3, [pc, #720]	; 6518 <evt2_execute+0x398>
    6244:	e2422001 	sub	r2, r2, #1
    6248:	e58d1000 	str	r1, [sp]
    624c:	e59f02c8 	ldr	r0, [pc, #712]	; 651c <evt2_execute+0x39c>
    6250:	e3a01e13 	mov	r1, #304	; 0x130
    6254:	ebffefe5 	bl	21f0 <chThdCreateStatic>
    6258:	e59f62c0 	ldr	r6, [pc, #704]	; 6520 <evt2_execute+0x3a0>
    625c:	e5860000 	str	r0, [r6]
  m = chEvtWaitOne(ALL_EVENTS);
    6260:	ebfff07a 	bl	2450 <chEvtWaitOne.constprop.28>
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
    6264:	e2852037 	add	r2, r5, #55	; 0x37
  m = chEvtWaitOne(ALL_EVENTS);
    6268:	e1a07000 	mov	r7, r0
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
    626c:	e2851032 	add	r1, r5, #50	; 0x32
    6270:	e3a00005 	mov	r0, #5
    6274:	ebffe991 	bl	8c0 <_test_assert_time_window>
    6278:	e3500000 	cmp	r0, #0
    627c:	1affffd0 	bne	61c4 <evt2_execute+0x44>
  test_assert(6, m == 1, "single event error");
    6280:	e247e001 	sub	lr, r7, #1
    6284:	e27e1000 	rsbs	r1, lr, #0
    6288:	e0a1100e 	adc	r1, r1, lr
    628c:	e3a00006 	mov	r0, #6
    6290:	ebffe9c2 	bl	9a0 <_test_assert>
    6294:	e3500000 	cmp	r0, #0
    6298:	1affffc9 	bne	61c4 <evt2_execute+0x44>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    629c:	ebffe7c3 	bl	1b0 <chEvtGetAndClearEvents.constprop.32>
  test_assert(7, m == 0, "stuck event");
    62a0:	e2701001 	rsbs	r1, r0, #1
    62a4:	33a01000 	movcc	r1, #0
    62a8:	e3a00007 	mov	r0, #7
    62ac:	ebffe9bb 	bl	9a0 <_test_assert>
    62b0:	e3500000 	cmp	r0, #0
    62b4:	1affffc2 	bne	61c4 <evt2_execute+0x44>
  test_wait_threads();
    62b8:	ebfffbb0 	bl	5180 <test_wait_threads>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    62bc:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    62c0:	e5942018 	ldr	r2, [r4, #24]
    62c4:	e5923038 	ldr	r3, [r2, #56]	; 0x38
    62c8:	e3833005 	orr	r3, r3, #5
    62cc:	e5823038 	str	r3, [r2, #56]	; 0x38
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    62d0:	e321f01f 	msr	CPSR_c, #31
  m = chEvtWaitAny(ALL_EVENTS);
    62d4:	ebfff071 	bl	24a0 <chEvtWaitAny.constprop.27>
  test_assert(8, m == 5, "unexpected pending bit");
    62d8:	e240c005 	sub	ip, r0, #5
    62dc:	e27c1000 	rsbs	r1, ip, #0
    62e0:	e0a1100c 	adc	r1, r1, ip
    62e4:	e3a00008 	mov	r0, #8
    62e8:	ebffe9ac 	bl	9a0 <_test_assert>
    62ec:	e3500000 	cmp	r0, #0
    62f0:	1affffb3 	bne	61c4 <evt2_execute+0x44>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    62f4:	ebffe7ad 	bl	1b0 <chEvtGetAndClearEvents.constprop.32>
  test_assert(9, m == 0, "stuck event");
    62f8:	e2701001 	rsbs	r1, r0, #1
    62fc:	33a01000 	movcc	r1, #0
    6300:	e3a00009 	mov	r0, #9
    6304:	ebffe9a5 	bl	9a0 <_test_assert>
    6308:	e3500000 	cmp	r0, #0
    630c:	1affffac 	bne	61c4 <evt2_execute+0x44>
  test_wait_tick();
    6310:	ebfff50e 	bl	3750 <test_wait_tick>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    6314:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    6318:	e5945028 	ldr	r5, [r4, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    631c:	e321f01f 	msr	CPSR_c, #31
    6320:	e5941018 	ldr	r1, [r4, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
    6324:	e5912008 	ldr	r2, [r1, #8]
    6328:	e59f31e8 	ldr	r3, [pc, #488]	; 6518 <evt2_execute+0x398>
    632c:	e2422001 	sub	r2, r2, #1
    6330:	e58d1000 	str	r1, [sp]
    6334:	e59f01e0 	ldr	r0, [pc, #480]	; 651c <evt2_execute+0x39c>
    6338:	e3a01e13 	mov	r1, #304	; 0x130
    633c:	ebffefab 	bl	21f0 <chThdCreateStatic>
    6340:	e5860000 	str	r0, [r6]
  m = chEvtWaitAny(ALL_EVENTS);
    6344:	ebfff055 	bl	24a0 <chEvtWaitAny.constprop.27>
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
    6348:	e2852037 	add	r2, r5, #55	; 0x37
  m = chEvtWaitAny(ALL_EVENTS);
    634c:	e1a07000 	mov	r7, r0
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
    6350:	e2851032 	add	r1, r5, #50	; 0x32
    6354:	e3a0000a 	mov	r0, #10
    6358:	ebffe958 	bl	8c0 <_test_assert_time_window>
    635c:	e3500000 	cmp	r0, #0
    6360:	1affff97 	bne	61c4 <evt2_execute+0x44>
  test_assert(11, m == 1, "single event error");
    6364:	e2470001 	sub	r0, r7, #1
    6368:	e2701000 	rsbs	r1, r0, #0
    636c:	e0a11000 	adc	r1, r1, r0
    6370:	e3a0000b 	mov	r0, #11
    6374:	ebffe989 	bl	9a0 <_test_assert>
    6378:	e3500000 	cmp	r0, #0
    637c:	1affff90 	bne	61c4 <evt2_execute+0x44>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    6380:	ebffe78a 	bl	1b0 <chEvtGetAndClearEvents.constprop.32>
  test_assert(12, m == 0, "stuck event");
    6384:	e2701001 	rsbs	r1, r0, #1
    6388:	33a01000 	movcc	r1, #0
    638c:	e3a0000c 	mov	r0, #12
    6390:	ebffe982 	bl	9a0 <_test_assert>
    6394:	e250a000 	subs	sl, r0, #0
    6398:	1affff89 	bne	61c4 <evt2_execute+0x44>
  esp->es_next = (event_listener_t *)esp;
    639c:	e59f7180 	ldr	r7, [pc, #384]	; 6524 <evt2_execute+0x3a4>
    63a0:	e59f5180 	ldr	r5, [pc, #384]	; 6528 <evt2_execute+0x3a8>
  test_wait_threads();
    63a4:	ebfffb75 	bl	5180 <test_wait_threads>
    63a8:	e5877000 	str	r7, [r7]
    63ac:	e5855000 	str	r5, [r5]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    63b0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  elp->el_events   = events;
    63b4:	e3a02001 	mov	r2, #1
  elp->el_wflags   = wflags;
    63b8:	e3e03000 	mvn	r3, #0
  elp->el_next     = esp->es_next;
    63bc:	e5970000 	ldr	r0, [r7]
    63c0:	e28d9030 	add	r9, sp, #48	; 0x30
  elp->el_listener = currp;
    63c4:	e5941018 	ldr	r1, [r4, #24]
  elp->el_next     = esp->es_next;
    63c8:	e5290028 	str	r0, [r9, #-40]!	; 0xffffffd8
  elp->el_flags    = (eventflags_t)0;
    63cc:	e58da014 	str	sl, [sp, #20]
  elp->el_listener = currp;
    63d0:	e58d100c 	str	r1, [sp, #12]
  elp->el_events   = events;
    63d4:	e58d2010 	str	r2, [sp, #16]
  esp->es_next     = elp;
    63d8:	e5879000 	str	r9, [r7]
  elp->el_wflags   = wflags;
    63dc:	e58d3018 	str	r3, [sp, #24]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    63e0:	e321f01f 	msr	CPSR_c, #31
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    63e4:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  elp->el_events   = events;
    63e8:	e3a02004 	mov	r2, #4
  elp->el_next     = esp->es_next;
    63ec:	e5950000 	ldr	r0, [r5]
    63f0:	e28d8030 	add	r8, sp, #48	; 0x30
  elp->el_listener = currp;
    63f4:	e5941018 	ldr	r1, [r4, #24]
  elp->el_next     = esp->es_next;
    63f8:	e5280014 	str	r0, [r8, #-20]!	; 0xffffffec
  elp->el_flags    = (eventflags_t)0;
    63fc:	e58da028 	str	sl, [sp, #40]	; 0x28
  elp->el_wflags   = wflags;
    6400:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  elp->el_listener = currp;
    6404:	e58d1020 	str	r1, [sp, #32]
  elp->el_events   = events;
    6408:	e58d2024 	str	r2, [sp, #36]	; 0x24
  esp->es_next     = elp;
    640c:	e5858000 	str	r8, [r5]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    6410:	e321f01f 	msr	CPSR_c, #31
  test_wait_tick();
    6414:	ebfff4cd 	bl	3750 <test_wait_tick>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    6418:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    641c:	e594a028 	ldr	sl, [r4, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    6420:	e321f01f 	msr	CPSR_c, #31
  return chThdGetSelfX()->p_prio;
    6424:	e5943018 	ldr	r3, [r4, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
    6428:	e59f10fc 	ldr	r1, [pc, #252]	; 652c <evt2_execute+0x3ac>
    642c:	e5932008 	ldr	r2, [r3, #8]
    6430:	e59f00e4 	ldr	r0, [pc, #228]	; 651c <evt2_execute+0x39c>
    6434:	e58d1000 	str	r1, [sp]
    6438:	e59f30f0 	ldr	r3, [pc, #240]	; 6530 <evt2_execute+0x3b0>
    643c:	e2422001 	sub	r2, r2, #1
    6440:	e3a01e13 	mov	r1, #304	; 0x130
    6444:	ebffef69 	bl	21f0 <chThdCreateStatic>
  target_time = chVTGetSystemTime() + MS2ST(50);
    6448:	e28ab032 	add	fp, sl, #50	; 0x32
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
    644c:	e5860000 	str	r0, [r6]
  thread_t *ctp = currp;
    6450:	e5944018 	ldr	r4, [r4, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    6454:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if ((ctp->p_epending & events) != events) {
    6458:	e5943038 	ldr	r3, [r4, #56]	; 0x38
    645c:	e2032005 	and	r2, r3, #5
    6460:	e3520005 	cmp	r2, #5
    6464:	0a000004 	beq	647c <evt2_execute+0x2fc>
    ctp->p_u.ewmask = events;
    6468:	e3a03005 	mov	r3, #5
    chSchGoSleepS(CH_STATE_WTANDEVT);
    646c:	e3a0000b 	mov	r0, #11
    ctp->p_u.ewmask = events;
    6470:	e5843024 	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
    6474:	ebffef85 	bl	2290 <chSchGoSleepS>
    6478:	e5943038 	ldr	r3, [r4, #56]	; 0x38
  ctp->p_epending &= ~events;
    647c:	e3c33005 	bic	r3, r3, #5
    6480:	e5843038 	str	r3, [r4, #56]	; 0x38
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    6484:	e321f01f 	msr	CPSR_c, #31
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
    6488:	e3a0000d 	mov	r0, #13
    648c:	e28a2037 	add	r2, sl, #55	; 0x37
    6490:	e1a0100b 	mov	r1, fp
    6494:	ebffe909 	bl	8c0 <_test_assert_time_window>
    6498:	e3500000 	cmp	r0, #0
    649c:	1affff48 	bne	61c4 <evt2_execute+0x44>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
    64a0:	ebffe742 	bl	1b0 <chEvtGetAndClearEvents.constprop.32>
  test_assert(14, m == 0, "stuck event");
    64a4:	e2701001 	rsbs	r1, r0, #1
    64a8:	33a01000 	movcc	r1, #0
    64ac:	e3a0000e 	mov	r0, #14
    64b0:	ebffe93a 	bl	9a0 <_test_assert>
    64b4:	e3500000 	cmp	r0, #0
    64b8:	1affff41 	bne	61c4 <evt2_execute+0x44>
  test_wait_threads();
    64bc:	ebfffb2f 	bl	5180 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
    64c0:	e1a01009 	mov	r1, r9
    64c4:	e59f0058 	ldr	r0, [pc, #88]	; 6524 <evt2_execute+0x3a4>
    64c8:	ebffe9f0 	bl	c90 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
    64cc:	e1a01008 	mov	r1, r8
    64d0:	e59f0050 	ldr	r0, [pc, #80]	; 6528 <evt2_execute+0x3a8>
    64d4:	ebffe9ed 	bl	c90 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
    64d8:	e5971000 	ldr	r1, [r7]
    64dc:	e0412007 	sub	r2, r1, r7
    64e0:	e2721000 	rsbs	r1, r2, #0
    64e4:	e0a11002 	adc	r1, r1, r2
    64e8:	e3a0000f 	mov	r0, #15
    64ec:	ebffe92b 	bl	9a0 <_test_assert>
    64f0:	e3500000 	cmp	r0, #0
    64f4:	1affff32 	bne	61c4 <evt2_execute+0x44>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
    64f8:	e5951000 	ldr	r1, [r5]
    64fc:	e0413005 	sub	r3, r1, r5
    6500:	e2731000 	rsbs	r1, r3, #0
    6504:	e0a11003 	adc	r1, r1, r3
    6508:	e3a00010 	mov	r0, #16
    650c:	ebffe923 	bl	9a0 <_test_assert>
    6510:	eaffff2b 	b	61c4 <evt2_execute+0x44>
    6514:	40000c00 	.word	0x40000c00
    6518:	00003660 	.word	0x00003660
    651c:	40000e00 	.word	0x40000e00
    6520:	4000141c 	.word	0x4000141c
    6524:	40000a60 	.word	0x40000a60
    6528:	40000a64 	.word	0x40000a64
    652c:	000081a0 	.word	0x000081a0
    6530:	00003690 	.word	0x00003690
	...

00006540 <mtx8_execute>:

static void mtx8_execute(void) {
    6540:	e92d4070 	push	{r4, r5, r6, lr}
  return ch.rlist.r_current;
    6544:	e59f3090 	ldr	r3, [pc, #144]	; 65dc <mtx8_execute+0x9c>
  return chThdGetSelfX()->p_prio;
    6548:	e5933018 	ldr	r3, [r3, #24]

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
    654c:	e59f508c 	ldr	r5, [pc, #140]	; 65e0 <mtx8_execute+0xa0>
    6550:	e5936008 	ldr	r6, [r3, #8]
    6554:	e59f3088 	ldr	r3, [pc, #136]	; 65e4 <mtx8_execute+0xa4>
static void mtx8_execute(void) {
    6558:	e24dd008 	sub	sp, sp, #8
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
    655c:	e2862001 	add	r2, r6, #1
    6560:	e58d3000 	str	r3, [sp]
    6564:	e1a00005 	mov	r0, r5
    6568:	e59f3078 	ldr	r3, [pc, #120]	; 65e8 <mtx8_execute+0xa8>
    656c:	e3a01e13 	mov	r1, #304	; 0x130
    6570:	ebffef1e 	bl	21f0 <chThdCreateStatic>
    6574:	e59f4070 	ldr	r4, [pc, #112]	; 65ec <mtx8_execute+0xac>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
    6578:	e59f3070 	ldr	r3, [pc, #112]	; 65f0 <mtx8_execute+0xb0>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
    657c:	e5840000 	str	r0, [r4]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
    6580:	e2862002 	add	r2, r6, #2
    6584:	e58d3000 	str	r3, [sp]
    6588:	e2850e13 	add	r0, r5, #304	; 0x130
    658c:	e59f3060 	ldr	r3, [pc, #96]	; 65f4 <mtx8_execute+0xb4>
    6590:	e3a01e13 	mov	r1, #304	; 0x130
    6594:	ebffef15 	bl	21f0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
    6598:	e59f3058 	ldr	r3, [pc, #88]	; 65f8 <mtx8_execute+0xb8>
    659c:	e2862003 	add	r2, r6, #3
    65a0:	e3a01e13 	mov	r1, #304	; 0x130
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
    65a4:	e5840004 	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
    65a8:	e58d3000 	str	r3, [sp]
    65ac:	e2850e26 	add	r0, r5, #608	; 0x260
    65b0:	e59f3044 	ldr	r3, [pc, #68]	; 65fc <mtx8_execute+0xbc>
    65b4:	ebffef0d 	bl	21f0 <chThdCreateStatic>
    65b8:	e5840008 	str	r0, [r4, #8]
  chCondSignal(&c1);
    65bc:	ebffeebf 	bl	20c0 <chCondSignal.constprop.40>
  chCondSignal(&c1);
    65c0:	ebffeebe 	bl	20c0 <chCondSignal.constprop.40>
  test_wait_threads();
    65c4:	ebfffaed 	bl	5180 <test_wait_threads>
  test_assert_sequence(1, "ABC");
    65c8:	e3a00001 	mov	r0, #1
    65cc:	e59f102c 	ldr	r1, [pc, #44]	; 6600 <mtx8_execute+0xc0>
}
    65d0:	e28dd008 	add	sp, sp, #8
    65d4:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_assert_sequence(1, "ABC");
    65d8:	eaffe8d0 	b	920 <_test_assert_sequence>
    65dc:	40000c00 	.word	0x40000c00
    65e0:	40000e00 	.word	0x40000e00
    65e4:	000081a0 	.word	0x000081a0
    65e8:	00003f20 	.word	0x00003f20
    65ec:	4000141c 	.word	0x4000141c
    65f0:	00008194 	.word	0x00008194
    65f4:	00003ff0 	.word	0x00003ff0
    65f8:	00008190 	.word	0x00008190
    65fc:	00004090 	.word	0x00004090
    6600:	000081c0 	.word	0x000081c0
	...

00006610 <mtx7_execute>:
static void mtx7_execute(void) {
    6610:	e92d4030 	push	{r4, r5, lr}
  return ch.rlist.r_current;
    6614:	e59f3108 	ldr	r3, [pc, #264]	; 6724 <mtx7_execute+0x114>
  return chThdGetSelfX()->p_prio;
    6618:	e5933018 	ldr	r3, [r3, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    661c:	e59f1104 	ldr	r1, [pc, #260]	; 6728 <mtx7_execute+0x118>
    6620:	e5935008 	ldr	r5, [r3, #8]
static void mtx7_execute(void) {
    6624:	e24dd00c 	sub	sp, sp, #12
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    6628:	e2852001 	add	r2, r5, #1
    662c:	e58d1000 	str	r1, [sp]
    6630:	e59f30f4 	ldr	r3, [pc, #244]	; 672c <mtx7_execute+0x11c>
    6634:	e3a01e13 	mov	r1, #304	; 0x130
    6638:	e59f00f0 	ldr	r0, [pc, #240]	; 6730 <mtx7_execute+0x120>
    663c:	ebffeeeb 	bl	21f0 <chThdCreateStatic>
    6640:	e59f40ec 	ldr	r4, [pc, #236]	; 6734 <mtx7_execute+0x124>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    6644:	e59f30ec 	ldr	r3, [pc, #236]	; 6738 <mtx7_execute+0x128>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    6648:	e5840000 	str	r0, [r4]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    664c:	e2852002 	add	r2, r5, #2
    6650:	e58d3000 	str	r3, [sp]
    6654:	e3a01e13 	mov	r1, #304	; 0x130
    6658:	e59f30cc 	ldr	r3, [pc, #204]	; 672c <mtx7_execute+0x11c>
    665c:	e59f00d8 	ldr	r0, [pc, #216]	; 673c <mtx7_execute+0x12c>
    6660:	ebffeee2 	bl	21f0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    6664:	e59f30d4 	ldr	r3, [pc, #212]	; 6740 <mtx7_execute+0x130>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    6668:	e5840004 	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    666c:	e2852003 	add	r2, r5, #3
    6670:	e58d3000 	str	r3, [sp]
    6674:	e3a01e13 	mov	r1, #304	; 0x130
    6678:	e59f30ac 	ldr	r3, [pc, #172]	; 672c <mtx7_execute+0x11c>
    667c:	e59f00c0 	ldr	r0, [pc, #192]	; 6744 <mtx7_execute+0x134>
    6680:	ebffeeda 	bl	21f0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    6684:	e59f30bc 	ldr	r3, [pc, #188]	; 6748 <mtx7_execute+0x138>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    6688:	e5840008 	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    668c:	e2852004 	add	r2, r5, #4
    6690:	e58d3000 	str	r3, [sp]
    6694:	e3a01e13 	mov	r1, #304	; 0x130
    6698:	e59f308c 	ldr	r3, [pc, #140]	; 672c <mtx7_execute+0x11c>
    669c:	e59f00a8 	ldr	r0, [pc, #168]	; 674c <mtx7_execute+0x13c>
    66a0:	ebffeed2 	bl	21f0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
    66a4:	e59f30a4 	ldr	r3, [pc, #164]	; 6750 <mtx7_execute+0x140>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    66a8:	e584000c 	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
    66ac:	e2852005 	add	r2, r5, #5
    66b0:	e58d3000 	str	r3, [sp]
    66b4:	e3a01e13 	mov	r1, #304	; 0x130
    66b8:	e59f306c 	ldr	r3, [pc, #108]	; 672c <mtx7_execute+0x11c>
    66bc:	e59f0090 	ldr	r0, [pc, #144]	; 6754 <mtx7_execute+0x144>
    66c0:	ebffeeca 	bl	21f0 <chThdCreateStatic>
    66c4:	e5840010 	str	r0, [r4, #16]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    66c8:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    66cc:	e59f4084 	ldr	r4, [pc, #132]	; 6758 <mtx7_execute+0x148>
    66d0:	e5943000 	ldr	r3, [r4]
  while (queue_notempty(&cp->c_queue)) {
    66d4:	e1530004 	cmp	r3, r4
    66d8:	0a000009 	beq	6704 <mtx7_execute+0xf4>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
    66dc:	e3e05001 	mvn	r5, #1
  tqp->p_next = tp->p_next;
    66e0:	e5932000 	ldr	r2, [r3]
    66e4:	e1a00003 	mov	r0, r3
  tqp->p_next->p_prev = (thread_t *)tqp;
    66e8:	e5824004 	str	r4, [r2, #4]
  tqp->p_next = tp->p_next;
    66ec:	e5842000 	str	r2, [r4]
    66f0:	ebffea2e 	bl	fb0 <chSchReadyI>
  return (bool)(tqp->p_next != (const thread_t *)tqp);
    66f4:	e5943000 	ldr	r3, [r4]
  while (queue_notempty(&cp->c_queue)) {
    66f8:	e1530004 	cmp	r3, r4
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
    66fc:	e5805024 	str	r5, [r0, #36]	; 0x24
  while (queue_notempty(&cp->c_queue)) {
    6700:	1afffff6 	bne	66e0 <mtx7_execute+0xd0>
  chSchRescheduleS();
    6704:	ebffed35 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    6708:	e321f01f 	msr	CPSR_c, #31
  test_wait_threads();
    670c:	ebfffa9b 	bl	5180 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    6710:	e3a00001 	mov	r0, #1
    6714:	e59f1040 	ldr	r1, [pc, #64]	; 675c <mtx7_execute+0x14c>
}
    6718:	e28dd00c 	add	sp, sp, #12
    671c:	e8bd4030 	pop	{r4, r5, lr}
  test_assert_sequence(1, "ABCDE");
    6720:	eaffe87e 	b	920 <_test_assert_sequence>
    6724:	40000c00 	.word	0x40000c00
    6728:	000083b4 	.word	0x000083b4
    672c:	00003ff0 	.word	0x00003ff0
    6730:	40000e00 	.word	0x40000e00
    6734:	4000141c 	.word	0x4000141c
    6738:	00008198 	.word	0x00008198
    673c:	40000f30 	.word	0x40000f30
    6740:	00008194 	.word	0x00008194
    6744:	40001060 	.word	0x40001060
    6748:	00008190 	.word	0x00008190
    674c:	40001190 	.word	0x40001190
    6750:	000081a0 	.word	0x000081a0
    6754:	400012c0 	.word	0x400012c0
    6758:	40000a58 	.word	0x40000a58
    675c:	000083b0 	.word	0x000083b0

00006760 <mtx6_execute>:
static void mtx6_execute(void) {
    6760:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  return ch.rlist.r_current;
    6764:	e59f30ec 	ldr	r3, [pc, #236]	; 6858 <mtx6_execute+0xf8>
  return chThdGetSelfX()->p_prio;
    6768:	e5933018 	ldr	r3, [r3, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    676c:	e59f60e8 	ldr	r6, [pc, #232]	; 685c <mtx6_execute+0xfc>
    6770:	e5937008 	ldr	r7, [r3, #8]
    6774:	e59f50e4 	ldr	r5, [pc, #228]	; 6860 <mtx6_execute+0x100>
    6778:	e59f10e4 	ldr	r1, [pc, #228]	; 6864 <mtx6_execute+0x104>
static void mtx6_execute(void) {
    677c:	e24dd00c 	sub	sp, sp, #12
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    6780:	e2872001 	add	r2, r7, #1
    6784:	e1a03006 	mov	r3, r6
    6788:	e58d1000 	str	r1, [sp]
    678c:	e1a00005 	mov	r0, r5
    6790:	e3a01e13 	mov	r1, #304	; 0x130
    6794:	ebffee95 	bl	21f0 <chThdCreateStatic>
    6798:	e59f40c8 	ldr	r4, [pc, #200]	; 6868 <mtx6_execute+0x108>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    679c:	e59f10c8 	ldr	r1, [pc, #200]	; 686c <mtx6_execute+0x10c>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
    67a0:	e5840000 	str	r0, [r4]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    67a4:	e2872002 	add	r2, r7, #2
    67a8:	e1a03006 	mov	r3, r6
    67ac:	e58d1000 	str	r1, [sp]
    67b0:	e2850e13 	add	r0, r5, #304	; 0x130
    67b4:	e3a01e13 	mov	r1, #304	; 0x130
    67b8:	ebffee8c 	bl	21f0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    67bc:	e59f10ac 	ldr	r1, [pc, #172]	; 6870 <mtx6_execute+0x110>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
    67c0:	e5840004 	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    67c4:	e2872003 	add	r2, r7, #3
    67c8:	e1a03006 	mov	r3, r6
    67cc:	e58d1000 	str	r1, [sp]
    67d0:	e2850e26 	add	r0, r5, #608	; 0x260
    67d4:	e3a01e13 	mov	r1, #304	; 0x130
    67d8:	ebffee84 	bl	21f0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    67dc:	e59f1090 	ldr	r1, [pc, #144]	; 6874 <mtx6_execute+0x114>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
    67e0:	e5840008 	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    67e4:	e2872004 	add	r2, r7, #4
    67e8:	e1a03006 	mov	r3, r6
    67ec:	e58d1000 	str	r1, [sp]
    67f0:	e2850e39 	add	r0, r5, #912	; 0x390
    67f4:	e3a01e13 	mov	r1, #304	; 0x130
    67f8:	ebffee7c 	bl	21f0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
    67fc:	e59f1074 	ldr	r1, [pc, #116]	; 6878 <mtx6_execute+0x118>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
    6800:	e584000c 	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
    6804:	e58d1000 	str	r1, [sp]
    6808:	e2872005 	add	r2, r7, #5
    680c:	e1a03006 	mov	r3, r6
    6810:	e2850d13 	add	r0, r5, #1216	; 0x4c0
    6814:	e3a01e13 	mov	r1, #304	; 0x130
    6818:	ebffee74 	bl	21f0 <chThdCreateStatic>
    681c:	e5840010 	str	r0, [r4, #16]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    6820:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chCondSignalI(&c1);
    6824:	ebffe9f5 	bl	1000 <chCondSignalI.constprop.39>
  chCondSignalI(&c1);
    6828:	ebffe9f4 	bl	1000 <chCondSignalI.constprop.39>
  chCondSignalI(&c1);
    682c:	ebffe9f3 	bl	1000 <chCondSignalI.constprop.39>
  chCondSignalI(&c1);
    6830:	ebffe9f2 	bl	1000 <chCondSignalI.constprop.39>
  chCondSignalI(&c1);
    6834:	ebffe9f1 	bl	1000 <chCondSignalI.constprop.39>
  chSchRescheduleS();
    6838:	ebffece8 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    683c:	e321f01f 	msr	CPSR_c, #31
  test_wait_threads();
    6840:	ebfffa4e 	bl	5180 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    6844:	e3a00001 	mov	r0, #1
    6848:	e59f102c 	ldr	r1, [pc, #44]	; 687c <mtx6_execute+0x11c>
}
    684c:	e28dd00c 	add	sp, sp, #12
    6850:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  test_assert_sequence(1, "ABCDE");
    6854:	eaffe831 	b	920 <_test_assert_sequence>
    6858:	40000c00 	.word	0x40000c00
    685c:	00003ff0 	.word	0x00003ff0
    6860:	40000e00 	.word	0x40000e00
    6864:	000083b4 	.word	0x000083b4
    6868:	4000141c 	.word	0x4000141c
    686c:	00008198 	.word	0x00008198
    6870:	00008194 	.word	0x00008194
    6874:	00008190 	.word	0x00008190
    6878:	000081a0 	.word	0x000081a0
    687c:	000083b0 	.word	0x000083b0

00006880 <mtx4_execute>:
static void mtx4_execute(void) {
    6880:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  return ch.rlist.r_current;
    6884:	e59f5318 	ldr	r5, [pc, #792]	; 6ba4 <mtx4_execute+0x324>
  return chThdGetSelfX()->p_prio;
    6888:	e5953018 	ldr	r3, [r5, #24]
    688c:	e5934008 	ldr	r4, [r3, #8]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
    6890:	e59f3310 	ldr	r3, [pc, #784]	; 6ba8 <mtx4_execute+0x328>
static void mtx4_execute(void) {
    6894:	e24dd008 	sub	sp, sp, #8
  p1 = p + 1;
    6898:	e2847001 	add	r7, r4, #1
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
    689c:	e1a02007 	mov	r2, r7
    68a0:	e58d3000 	str	r3, [sp]
    68a4:	e3a01e13 	mov	r1, #304	; 0x130
    68a8:	e59f32fc 	ldr	r3, [pc, #764]	; 6bac <mtx4_execute+0x32c>
    68ac:	e59f02fc 	ldr	r0, [pc, #764]	; 6bb0 <mtx4_execute+0x330>
    68b0:	ebffee4e 	bl	21f0 <chThdCreateStatic>
    68b4:	e59f62f8 	ldr	r6, [pc, #760]	; 6bb4 <mtx4_execute+0x334>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
    68b8:	e59f32f8 	ldr	r3, [pc, #760]	; 6bb8 <mtx4_execute+0x338>
  p2 = p + 2;
    68bc:	e2848002 	add	r8, r4, #2
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
    68c0:	e5860000 	str	r0, [r6]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
    68c4:	e1a02008 	mov	r2, r8
    68c8:	e3a01e13 	mov	r1, #304	; 0x130
    68cc:	e58d3000 	str	r3, [sp]
    68d0:	e59f02e4 	ldr	r0, [pc, #740]	; 6bbc <mtx4_execute+0x33c>
    68d4:	e59f32e4 	ldr	r3, [pc, #740]	; 6bc0 <mtx4_execute+0x340>
    68d8:	ebffee44 	bl	21f0 <chThdCreateStatic>
    68dc:	e5860004 	str	r0, [r6, #4]
  chMtxLock(&m2);
    68e0:	e59f02dc 	ldr	r0, [pc, #732]	; 6bc4 <mtx4_execute+0x344>
    68e4:	ebfff55d 	bl	3e60 <chMtxLock>
    68e8:	e5953018 	ldr	r3, [r5, #24]
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
    68ec:	e5931008 	ldr	r1, [r3, #8]
    68f0:	e0413004 	sub	r3, r1, r4
    68f4:	e2731000 	rsbs	r1, r3, #0
    68f8:	e0a11003 	adc	r1, r1, r3
    68fc:	e3a00001 	mov	r0, #1
    6900:	ebffe826 	bl	9a0 <_test_assert>
    6904:	e3500000 	cmp	r0, #0
    6908:	0a000001 	beq	6914 <mtx4_execute+0x94>
}
    690c:	e28dd008 	add	sp, sp, #8
    6910:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  chThdSleepMilliseconds(100);
    6914:	e3a00064 	mov	r0, #100	; 0x64
    6918:	ebfff2e0 	bl	34a0 <chThdSleep>
    691c:	e5953018 	ldr	r3, [r5, #24]
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
    6920:	e5931008 	ldr	r1, [r3, #8]
    6924:	e041e007 	sub	lr, r1, r7
    6928:	e27e1000 	rsbs	r1, lr, #0
    692c:	e0a1100e 	adc	r1, r1, lr
    6930:	e3a00002 	mov	r0, #2
    6934:	ebffe819 	bl	9a0 <_test_assert>
    6938:	e3500000 	cmp	r0, #0
    693c:	1afffff2 	bne	690c <mtx4_execute+0x8c>
  chMtxLock(&m1);
    6940:	e59f0280 	ldr	r0, [pc, #640]	; 6bc8 <mtx4_execute+0x348>
    6944:	ebfff545 	bl	3e60 <chMtxLock>
    6948:	e5953018 	ldr	r3, [r5, #24]
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
    694c:	e5931008 	ldr	r1, [r3, #8]
    6950:	e041c007 	sub	ip, r1, r7
    6954:	e27c1000 	rsbs	r1, ip, #0
    6958:	e0a1100c 	adc	r1, r1, ip
    695c:	e3a00003 	mov	r0, #3
    6960:	ebffe80e 	bl	9a0 <_test_assert>
    6964:	e3500000 	cmp	r0, #0
    6968:	1affffe7 	bne	690c <mtx4_execute+0x8c>
  chThdSleepMilliseconds(100);
    696c:	e3a00064 	mov	r0, #100	; 0x64
    6970:	ebfff2ca 	bl	34a0 <chThdSleep>
    6974:	e5953018 	ldr	r3, [r5, #24]
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
    6978:	e5931008 	ldr	r1, [r3, #8]
    697c:	e0412008 	sub	r2, r1, r8
    6980:	e2721000 	rsbs	r1, r2, #0
    6984:	e0a11002 	adc	r1, r1, r2
    6988:	e3a00004 	mov	r0, #4
    698c:	ebffe803 	bl	9a0 <_test_assert>
    6990:	e3500000 	cmp	r0, #0
    6994:	1affffdc 	bne	690c <mtx4_execute+0x8c>
  chMtxUnlock(&m1);
    6998:	e59f0228 	ldr	r0, [pc, #552]	; 6bc8 <mtx4_execute+0x348>
    699c:	ebffedd7 	bl	2100 <chMtxUnlock>
    69a0:	e5953018 	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
    69a4:	e5931008 	ldr	r1, [r3, #8]
    69a8:	e0413007 	sub	r3, r1, r7
    69ac:	e2731000 	rsbs	r1, r3, #0
    69b0:	e0a11003 	adc	r1, r1, r3
    69b4:	e3a00005 	mov	r0, #5
    69b8:	ebffe7f8 	bl	9a0 <_test_assert>
    69bc:	e3500000 	cmp	r0, #0
    69c0:	1affffd1 	bne	690c <mtx4_execute+0x8c>
  chThdSleepMilliseconds(100);
    69c4:	e3a00064 	mov	r0, #100	; 0x64
    69c8:	ebfff2b4 	bl	34a0 <chThdSleep>
    69cc:	e5953018 	ldr	r3, [r5, #24]
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
    69d0:	e5931008 	ldr	r1, [r3, #8]
    69d4:	e041e007 	sub	lr, r1, r7
    69d8:	e27e1000 	rsbs	r1, lr, #0
    69dc:	e0a1100e 	adc	r1, r1, lr
    69e0:	e3a00006 	mov	r0, #6
    69e4:	ebffe7ed 	bl	9a0 <_test_assert>
    69e8:	e3500000 	cmp	r0, #0
    69ec:	1affffc6 	bne	690c <mtx4_execute+0x8c>
  chMtxUnlockAll();
    69f0:	ebffec92 	bl	1c40 <chMtxUnlockAll>
    69f4:	e5953018 	ldr	r3, [r5, #24]
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
    69f8:	e5931008 	ldr	r1, [r3, #8]
    69fc:	e041c004 	sub	ip, r1, r4
    6a00:	e27c1000 	rsbs	r1, ip, #0
    6a04:	e0a1100c 	adc	r1, r1, ip
    6a08:	e3a00007 	mov	r0, #7
    6a0c:	ebffe7e3 	bl	9a0 <_test_assert>
    6a10:	e3500000 	cmp	r0, #0
    6a14:	1affffbc 	bne	690c <mtx4_execute+0x8c>
  test_wait_threads();
    6a18:	ebfff9d8 	bl	5180 <test_wait_threads>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
    6a1c:	e59f21a8 	ldr	r2, [pc, #424]	; 6bcc <mtx4_execute+0x34c>
    6a20:	e59f3184 	ldr	r3, [pc, #388]	; 6bac <mtx4_execute+0x32c>
    6a24:	e58d2000 	str	r2, [sp]
    6a28:	e3a01e13 	mov	r1, #304	; 0x130
    6a2c:	e1a02007 	mov	r2, r7
    6a30:	e59f0178 	ldr	r0, [pc, #376]	; 6bb0 <mtx4_execute+0x330>
    6a34:	ebffeded 	bl	21f0 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
    6a38:	e59f3190 	ldr	r3, [pc, #400]	; 6bd0 <mtx4_execute+0x350>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
    6a3c:	e5860000 	str	r0, [r6]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
    6a40:	e1a02008 	mov	r2, r8
    6a44:	e3a01e13 	mov	r1, #304	; 0x130
    6a48:	e58d3000 	str	r3, [sp]
    6a4c:	e59f0168 	ldr	r0, [pc, #360]	; 6bbc <mtx4_execute+0x33c>
    6a50:	e59f3168 	ldr	r3, [pc, #360]	; 6bc0 <mtx4_execute+0x340>
    6a54:	ebffede5 	bl	21f0 <chThdCreateStatic>
    6a58:	e5860004 	str	r0, [r6, #4]
  chMtxLock(&m2);
    6a5c:	e59f0160 	ldr	r0, [pc, #352]	; 6bc4 <mtx4_execute+0x344>
    6a60:	ebfff4fe 	bl	3e60 <chMtxLock>
    6a64:	e5953018 	ldr	r3, [r5, #24]
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
    6a68:	e5931008 	ldr	r1, [r3, #8]
    6a6c:	e0412004 	sub	r2, r1, r4
    6a70:	e2721000 	rsbs	r1, r2, #0
    6a74:	e0a11002 	adc	r1, r1, r2
    6a78:	e3a00008 	mov	r0, #8
    6a7c:	ebffe7c7 	bl	9a0 <_test_assert>
    6a80:	e3500000 	cmp	r0, #0
    6a84:	1affffa0 	bne	690c <mtx4_execute+0x8c>
  chThdSleepMilliseconds(100);
    6a88:	e3a00064 	mov	r0, #100	; 0x64
    6a8c:	ebfff283 	bl	34a0 <chThdSleep>
    6a90:	e5953018 	ldr	r3, [r5, #24]
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
    6a94:	e5931008 	ldr	r1, [r3, #8]
    6a98:	e0413007 	sub	r3, r1, r7
    6a9c:	e2731000 	rsbs	r1, r3, #0
    6aa0:	e0a11003 	adc	r1, r1, r3
    6aa4:	e3a00009 	mov	r0, #9
    6aa8:	ebffe7bc 	bl	9a0 <_test_assert>
    6aac:	e3500000 	cmp	r0, #0
    6ab0:	1affff95 	bne	690c <mtx4_execute+0x8c>
  chMtxLock(&m1);
    6ab4:	e59f010c 	ldr	r0, [pc, #268]	; 6bc8 <mtx4_execute+0x348>
    6ab8:	ebfff4e8 	bl	3e60 <chMtxLock>
    6abc:	e5953018 	ldr	r3, [r5, #24]
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
    6ac0:	e5931008 	ldr	r1, [r3, #8]
    6ac4:	e0416007 	sub	r6, r1, r7
    6ac8:	e2761000 	rsbs	r1, r6, #0
    6acc:	e0a11006 	adc	r1, r1, r6
    6ad0:	e3a0000a 	mov	r0, #10
    6ad4:	ebffe7b1 	bl	9a0 <_test_assert>
    6ad8:	e3500000 	cmp	r0, #0
    6adc:	1affff8a 	bne	690c <mtx4_execute+0x8c>
  chThdSleepMilliseconds(100);
    6ae0:	e3a00064 	mov	r0, #100	; 0x64
    6ae4:	ebfff26d 	bl	34a0 <chThdSleep>
    6ae8:	e5953018 	ldr	r3, [r5, #24]
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
    6aec:	e5931008 	ldr	r1, [r3, #8]
    6af0:	e041e008 	sub	lr, r1, r8
    6af4:	e27e1000 	rsbs	r1, lr, #0
    6af8:	e0a1100e 	adc	r1, r1, lr
    6afc:	e3a0000b 	mov	r0, #11
    6b00:	ebffe7a6 	bl	9a0 <_test_assert>
    6b04:	e3500000 	cmp	r0, #0
    6b08:	1affff7f 	bne	690c <mtx4_execute+0x8c>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    6b0c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  chMtxUnlockS(&m1);
    6b10:	e59f00b0 	ldr	r0, [pc, #176]	; 6bc8 <mtx4_execute+0x348>
    6b14:	ebffea41 	bl	1420 <chMtxUnlockS>
  chSchRescheduleS();
    6b18:	ebffec30 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    6b1c:	e321f01f 	msr	CPSR_c, #31
    6b20:	e5953018 	ldr	r3, [r5, #24]
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
    6b24:	e5931008 	ldr	r1, [r3, #8]
    6b28:	e041c007 	sub	ip, r1, r7
    6b2c:	e27c1000 	rsbs	r1, ip, #0
    6b30:	e0a1100c 	adc	r1, r1, ip
    6b34:	e3a0000c 	mov	r0, #12
    6b38:	ebffe798 	bl	9a0 <_test_assert>
    6b3c:	e3500000 	cmp	r0, #0
    6b40:	1affff71 	bne	690c <mtx4_execute+0x8c>
  chThdSleepMilliseconds(100);
    6b44:	e3a00064 	mov	r0, #100	; 0x64
    6b48:	ebfff254 	bl	34a0 <chThdSleep>
    6b4c:	e5953018 	ldr	r3, [r5, #24]
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
    6b50:	e5931008 	ldr	r1, [r3, #8]
    6b54:	e0412007 	sub	r2, r1, r7
    6b58:	e2721000 	rsbs	r1, r2, #0
    6b5c:	e0a11002 	adc	r1, r1, r2
    6b60:	e3a0000d 	mov	r0, #13
    6b64:	ebffe78d 	bl	9a0 <_test_assert>
    6b68:	e3500000 	cmp	r0, #0
    6b6c:	1affff66 	bne	690c <mtx4_execute+0x8c>
  chMtxUnlockAll();
    6b70:	ebffec32 	bl	1c40 <chMtxUnlockAll>
    6b74:	e5953018 	ldr	r3, [r5, #24]
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
    6b78:	e5931008 	ldr	r1, [r3, #8]
    6b7c:	e0413004 	sub	r3, r1, r4
    6b80:	e2731000 	rsbs	r1, r3, #0
    6b84:	e0a11003 	adc	r1, r1, r3
    6b88:	e3a0000e 	mov	r0, #14
    6b8c:	ebffe783 	bl	9a0 <_test_assert>
    6b90:	e3500000 	cmp	r0, #0
    6b94:	1affff5c 	bne	690c <mtx4_execute+0x8c>
}
    6b98:	e28dd008 	add	sp, sp, #8
    6b9c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  test_wait_threads();
    6ba0:	eafff976 	b	5180 <test_wait_threads>
    6ba4:	40000c00 	.word	0x40000c00
    6ba8:	00008190 	.word	0x00008190
    6bac:	00004210 	.word	0x00004210
    6bb0:	40000e00 	.word	0x40000e00
    6bb4:	4000141c 	.word	0x4000141c
    6bb8:	000081a0 	.word	0x000081a0
    6bbc:	40000f30 	.word	0x40000f30
    6bc0:	00004240 	.word	0x00004240
    6bc4:	40000a9c 	.word	0x40000a9c
    6bc8:	40000a8c 	.word	0x40000a8c
    6bcc:	00008198 	.word	0x00008198
    6bd0:	00008194 	.word	0x00008194
	...

00006be0 <mtx3_execute>:
static void mtx3_execute(void) {
    6be0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    6be4:	e24dd00c 	sub	sp, sp, #12
  test_wait_tick();
    6be8:	ebfff2d8 	bl	3750 <test_wait_tick>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    6bec:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    6bf0:	e59f40f8 	ldr	r4, [pc, #248]	; 6cf0 <mtx3_execute+0x110>
    6bf4:	e5947028 	ldr	r7, [r4, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    6bf8:	e321f01f 	msr	CPSR_c, #31
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread3LL, 0);
    6bfc:	e3a06000 	mov	r6, #0
    6c00:	e5943018 	ldr	r3, [r4, #24]
    6c04:	e5932008 	ldr	r2, [r3, #8]
    6c08:	e3a01e13 	mov	r1, #304	; 0x130
    6c0c:	e59f30e0 	ldr	r3, [pc, #224]	; 6cf4 <mtx3_execute+0x114>
    6c10:	e2422005 	sub	r2, r2, #5
    6c14:	e58d6000 	str	r6, [sp]
    6c18:	e59f00d8 	ldr	r0, [pc, #216]	; 6cf8 <mtx3_execute+0x118>
    6c1c:	ebffed73 	bl	21f0 <chThdCreateStatic>
    6c20:	e5943018 	ldr	r3, [r4, #24]
    6c24:	e59f50d0 	ldr	r5, [pc, #208]	; 6cfc <mtx3_execute+0x11c>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread3L, 0);
    6c28:	e5932008 	ldr	r2, [r3, #8]
    6c2c:	e3a01e13 	mov	r1, #304	; 0x130
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread3LL, 0);
    6c30:	e5850000 	str	r0, [r5]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread3L, 0);
    6c34:	e2422004 	sub	r2, r2, #4
    6c38:	e59f30c0 	ldr	r3, [pc, #192]	; 6d00 <mtx3_execute+0x120>
    6c3c:	e58d6000 	str	r6, [sp]
    6c40:	e59f00bc 	ldr	r0, [pc, #188]	; 6d04 <mtx3_execute+0x124>
    6c44:	ebffed69 	bl	21f0 <chThdCreateStatic>
    6c48:	e5943018 	ldr	r3, [r4, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread3M, 0);
    6c4c:	e5932008 	ldr	r2, [r3, #8]
    6c50:	e3a01e13 	mov	r1, #304	; 0x130
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread3L, 0);
    6c54:	e5850004 	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread3M, 0);
    6c58:	e2422003 	sub	r2, r2, #3
    6c5c:	e59f30a4 	ldr	r3, [pc, #164]	; 6d08 <mtx3_execute+0x128>
    6c60:	e58d6000 	str	r6, [sp]
    6c64:	e59f00a0 	ldr	r0, [pc, #160]	; 6d0c <mtx3_execute+0x12c>
    6c68:	ebffed60 	bl	21f0 <chThdCreateStatic>
    6c6c:	e5943018 	ldr	r3, [r4, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread3H, 0);
    6c70:	e5932008 	ldr	r2, [r3, #8]
    6c74:	e3a01e13 	mov	r1, #304	; 0x130
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread3M, 0);
    6c78:	e5850008 	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread3H, 0);
    6c7c:	e2422002 	sub	r2, r2, #2
    6c80:	e59f3088 	ldr	r3, [pc, #136]	; 6d10 <mtx3_execute+0x130>
    6c84:	e58d6000 	str	r6, [sp]
    6c88:	e59f0084 	ldr	r0, [pc, #132]	; 6d14 <mtx3_execute+0x134>
    6c8c:	ebffed57 	bl	21f0 <chThdCreateStatic>
    6c90:	e5943018 	ldr	r3, [r4, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread3HH, 0);
    6c94:	e5932008 	ldr	r2, [r3, #8]
    6c98:	e3a01e13 	mov	r1, #304	; 0x130
    6c9c:	e2422001 	sub	r2, r2, #1
    6ca0:	e59f3070 	ldr	r3, [pc, #112]	; 6d18 <mtx3_execute+0x138>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread3H, 0);
    6ca4:	e585000c 	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread3HH, 0);
    6ca8:	e58d6000 	str	r6, [sp]
    6cac:	e59f0068 	ldr	r0, [pc, #104]	; 6d1c <mtx3_execute+0x13c>
    6cb0:	ebffed4e 	bl	21f0 <chThdCreateStatic>
    6cb4:	e5850010 	str	r0, [r5, #16]
  test_wait_threads();
    6cb8:	ebfff930 	bl	5180 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    6cbc:	e59f105c 	ldr	r1, [pc, #92]	; 6d20 <mtx3_execute+0x140>
    6cc0:	e3a00001 	mov	r0, #1
    6cc4:	ebffe715 	bl	920 <_test_assert_sequence>
    6cc8:	e1500006 	cmp	r0, r6
    6ccc:	0a000001 	beq	6cd8 <mtx3_execute+0xf8>
}
    6cd0:	e28dd00c 	add	sp, sp, #12
    6cd4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  test_assert_time_window(2, time + MS2ST(110), time + MS2ST(110) + ALLOWED_DELAY);
    6cd8:	e3a00002 	mov	r0, #2
    6cdc:	e2872073 	add	r2, r7, #115	; 0x73
    6ce0:	e287106e 	add	r1, r7, #110	; 0x6e
}
    6ce4:	e28dd00c 	add	sp, sp, #12
    6ce8:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  test_assert_time_window(2, time + MS2ST(110), time + MS2ST(110) + ALLOWED_DELAY);
    6cec:	eaffe6f3 	b	8c0 <_test_assert_time_window>
    6cf0:	40000c00 	.word	0x40000c00
    6cf4:	00004270 	.word	0x00004270
    6cf8:	40000e00 	.word	0x40000e00
    6cfc:	4000141c 	.word	0x4000141c
    6d00:	000042a0 	.word	0x000042a0
    6d04:	40000f30 	.word	0x40000f30
    6d08:	00004300 	.word	0x00004300
    6d0c:	40001060 	.word	0x40001060
    6d10:	000036e0 	.word	0x000036e0
    6d14:	40001190 	.word	0x40001190
    6d18:	00004340 	.word	0x00004340
    6d1c:	400012c0 	.word	0x400012c0
    6d20:	000083b0 	.word	0x000083b0
	...

00006d30 <mtx2_execute>:
static void mtx2_execute(void) {
    6d30:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    6d34:	e24dd00c 	sub	sp, sp, #12
  test_wait_tick();
    6d38:	ebfff284 	bl	3750 <test_wait_tick>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    6d3c:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    6d40:	e59f40b0 	ldr	r4, [pc, #176]	; 6df8 <mtx2_execute+0xc8>
    6d44:	e5947028 	ldr	r7, [r4, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    6d48:	e321f01f 	msr	CPSR_c, #31
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2H, 0);
    6d4c:	e3a06000 	mov	r6, #0
    6d50:	e5943018 	ldr	r3, [r4, #24]
    6d54:	e5932008 	ldr	r2, [r3, #8]
    6d58:	e3a01e13 	mov	r1, #304	; 0x130
    6d5c:	e59f3098 	ldr	r3, [pc, #152]	; 6dfc <mtx2_execute+0xcc>
    6d60:	e2422001 	sub	r2, r2, #1
    6d64:	e58d6000 	str	r6, [sp]
    6d68:	e59f0090 	ldr	r0, [pc, #144]	; 6e00 <mtx2_execute+0xd0>
    6d6c:	ebffed1f 	bl	21f0 <chThdCreateStatic>
    6d70:	e5943018 	ldr	r3, [r4, #24]
    6d74:	e59f5088 	ldr	r5, [pc, #136]	; 6e04 <mtx2_execute+0xd4>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread2M, 0);
    6d78:	e5932008 	ldr	r2, [r3, #8]
    6d7c:	e3a01e13 	mov	r1, #304	; 0x130
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2H, 0);
    6d80:	e5850000 	str	r0, [r5]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread2M, 0);
    6d84:	e2422002 	sub	r2, r2, #2
    6d88:	e59f3078 	ldr	r3, [pc, #120]	; 6e08 <mtx2_execute+0xd8>
    6d8c:	e58d6000 	str	r6, [sp]
    6d90:	e59f0074 	ldr	r0, [pc, #116]	; 6e0c <mtx2_execute+0xdc>
    6d94:	ebffed15 	bl	21f0 <chThdCreateStatic>
    6d98:	e5943018 	ldr	r3, [r4, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread2L, 0);
    6d9c:	e5932008 	ldr	r2, [r3, #8]
    6da0:	e3a01e13 	mov	r1, #304	; 0x130
    6da4:	e2422003 	sub	r2, r2, #3
    6da8:	e59f3060 	ldr	r3, [pc, #96]	; 6e10 <mtx2_execute+0xe0>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread2M, 0);
    6dac:	e5850004 	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread2L, 0);
    6db0:	e58d6000 	str	r6, [sp]
    6db4:	e59f0058 	ldr	r0, [pc, #88]	; 6e14 <mtx2_execute+0xe4>
    6db8:	ebffed0c 	bl	21f0 <chThdCreateStatic>
    6dbc:	e5850008 	str	r0, [r5, #8]
  test_wait_threads();
    6dc0:	ebfff8ee 	bl	5180 <test_wait_threads>
  test_assert_sequence(1, "ABC");
    6dc4:	e59f104c 	ldr	r1, [pc, #76]	; 6e18 <mtx2_execute+0xe8>
    6dc8:	e3a00001 	mov	r0, #1
    6dcc:	ebffe6d3 	bl	920 <_test_assert_sequence>
    6dd0:	e1500006 	cmp	r0, r6
    6dd4:	0a000001 	beq	6de0 <mtx2_execute+0xb0>
}
    6dd8:	e28dd00c 	add	sp, sp, #12
    6ddc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  test_assert_time_window(2, time + MS2ST(100), time + MS2ST(100) + ALLOWED_DELAY);
    6de0:	e3a00002 	mov	r0, #2
    6de4:	e2872069 	add	r2, r7, #105	; 0x69
    6de8:	e2871064 	add	r1, r7, #100	; 0x64
}
    6dec:	e28dd00c 	add	sp, sp, #12
    6df0:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  test_assert_time_window(2, time + MS2ST(100), time + MS2ST(100) + ALLOWED_DELAY);
    6df4:	eaffe6b1 	b	8c0 <_test_assert_time_window>
    6df8:	40000c00 	.word	0x40000c00
    6dfc:	00004380 	.word	0x00004380
    6e00:	40000e00 	.word	0x40000e00
    6e04:	4000141c 	.word	0x4000141c
    6e08:	00003700 	.word	0x00003700
    6e0c:	40000f30 	.word	0x40000f30
    6e10:	000043c0 	.word	0x000043c0
    6e14:	40001060 	.word	0x40001060
    6e18:	000081c0 	.word	0x000081c0
    6e1c:	00000000 	.word	0x00000000

00006e20 <mtx1_execute>:
static void mtx1_execute(void) {
    6e20:	e92d4070 	push	{r4, r5, r6, lr}
  return ch.rlist.r_current;
    6e24:	e59f6100 	ldr	r6, [pc, #256]	; 6f2c <mtx1_execute+0x10c>
  return chThdGetSelfX()->p_prio;
    6e28:	e5963018 	ldr	r3, [r6, #24]
    6e2c:	e24dd008 	sub	sp, sp, #8
  chMtxLock(&m1);
    6e30:	e59f00f8 	ldr	r0, [pc, #248]	; 6f30 <mtx1_execute+0x110>
    6e34:	e5934008 	ldr	r4, [r3, #8]
    6e38:	ebfff408 	bl	3e60 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    6e3c:	e59f30f0 	ldr	r3, [pc, #240]	; 6f34 <mtx1_execute+0x114>
    6e40:	e2842001 	add	r2, r4, #1
    6e44:	e58d3000 	str	r3, [sp]
    6e48:	e3a01e13 	mov	r1, #304	; 0x130
    6e4c:	e59f30e4 	ldr	r3, [pc, #228]	; 6f38 <mtx1_execute+0x118>
    6e50:	e59f00e4 	ldr	r0, [pc, #228]	; 6f3c <mtx1_execute+0x11c>
    6e54:	ebffece5 	bl	21f0 <chThdCreateStatic>
    6e58:	e59f50e0 	ldr	r5, [pc, #224]	; 6f40 <mtx1_execute+0x120>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    6e5c:	e59f30e0 	ldr	r3, [pc, #224]	; 6f44 <mtx1_execute+0x124>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    6e60:	e5850000 	str	r0, [r5]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    6e64:	e2842002 	add	r2, r4, #2
    6e68:	e58d3000 	str	r3, [sp]
    6e6c:	e3a01e13 	mov	r1, #304	; 0x130
    6e70:	e59f30c0 	ldr	r3, [pc, #192]	; 6f38 <mtx1_execute+0x118>
    6e74:	e59f00cc 	ldr	r0, [pc, #204]	; 6f48 <mtx1_execute+0x128>
    6e78:	ebffecdc 	bl	21f0 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    6e7c:	e59f30c8 	ldr	r3, [pc, #200]	; 6f4c <mtx1_execute+0x12c>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    6e80:	e5850004 	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    6e84:	e2842003 	add	r2, r4, #3
    6e88:	e58d3000 	str	r3, [sp]
    6e8c:	e3a01e13 	mov	r1, #304	; 0x130
    6e90:	e59f30a0 	ldr	r3, [pc, #160]	; 6f38 <mtx1_execute+0x118>
    6e94:	e59f00b4 	ldr	r0, [pc, #180]	; 6f50 <mtx1_execute+0x130>
    6e98:	ebffecd4 	bl	21f0 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
    6e9c:	e59f30b0 	ldr	r3, [pc, #176]	; 6f54 <mtx1_execute+0x134>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    6ea0:	e5850008 	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
    6ea4:	e2842004 	add	r2, r4, #4
    6ea8:	e58d3000 	str	r3, [sp]
    6eac:	e3a01e13 	mov	r1, #304	; 0x130
    6eb0:	e59f3080 	ldr	r3, [pc, #128]	; 6f38 <mtx1_execute+0x118>
    6eb4:	e59f009c 	ldr	r0, [pc, #156]	; 6f58 <mtx1_execute+0x138>
    6eb8:	ebffeccc 	bl	21f0 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
    6ebc:	e59f3098 	ldr	r3, [pc, #152]	; 6f5c <mtx1_execute+0x13c>
    6ec0:	e2842005 	add	r2, r4, #5
    6ec4:	e3a01e13 	mov	r1, #304	; 0x130
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
    6ec8:	e585000c 	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
    6ecc:	e58d3000 	str	r3, [sp]
    6ed0:	e59f0088 	ldr	r0, [pc, #136]	; 6f60 <mtx1_execute+0x140>
    6ed4:	e59f305c 	ldr	r3, [pc, #92]	; 6f38 <mtx1_execute+0x118>
    6ed8:	ebffecc4 	bl	21f0 <chThdCreateStatic>
    6edc:	e5850010 	str	r0, [r5, #16]
  chMtxUnlock(&m1);
    6ee0:	e59f0048 	ldr	r0, [pc, #72]	; 6f30 <mtx1_execute+0x110>
    6ee4:	ebffec85 	bl	2100 <chMtxUnlock>
  test_wait_threads();
    6ee8:	ebfff8a4 	bl	5180 <test_wait_threads>
    6eec:	e5963018 	ldr	r3, [r6, #24]
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
    6ef0:	e5931008 	ldr	r1, [r3, #8]
    6ef4:	e0413004 	sub	r3, r1, r4
    6ef8:	e2731000 	rsbs	r1, r3, #0
    6efc:	e0a11003 	adc	r1, r1, r3
    6f00:	e3a00001 	mov	r0, #1
    6f04:	ebffe6a5 	bl	9a0 <_test_assert>
    6f08:	e3500000 	cmp	r0, #0
    6f0c:	0a000001 	beq	6f18 <mtx1_execute+0xf8>
}
    6f10:	e28dd008 	add	sp, sp, #8
    6f14:	e8bd8070 	pop	{r4, r5, r6, pc}
  test_assert_sequence(2, "ABCDE");
    6f18:	e3a00002 	mov	r0, #2
    6f1c:	e59f1040 	ldr	r1, [pc, #64]	; 6f64 <mtx1_execute+0x144>
}
    6f20:	e28dd008 	add	sp, sp, #8
    6f24:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_assert_sequence(2, "ABCDE");
    6f28:	eaffe67c 	b	920 <_test_assert_sequence>
    6f2c:	40000c00 	.word	0x40000c00
    6f30:	40000a8c 	.word	0x40000a8c
    6f34:	000083b4 	.word	0x000083b4
    6f38:	00004400 	.word	0x00004400
    6f3c:	40000e00 	.word	0x40000e00
    6f40:	4000141c 	.word	0x4000141c
    6f44:	00008198 	.word	0x00008198
    6f48:	40000f30 	.word	0x40000f30
    6f4c:	00008194 	.word	0x00008194
    6f50:	40001060 	.word	0x40001060
    6f54:	00008190 	.word	0x00008190
    6f58:	40001190 	.word	0x40001190
    6f5c:	000081a0 	.word	0x000081a0
    6f60:	400012c0 	.word	0x400012c0
    6f64:	000083b0 	.word	0x000083b0
	...

00006f70 <sem2_execute>:
static void sem2_execute(void) {
    6f70:	e92d4070 	push	{r4, r5, r6, lr}
    6f74:	e24dd008 	sub	sp, sp, #8
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    6f78:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  if (--sp->s_cnt < (cnt_t)0) {
    6f7c:	e59f41b0 	ldr	r4, [pc, #432]	; 7134 <sem2_execute+0x1c4>
    6f80:	e5943008 	ldr	r3, [r4, #8]
    6f84:	e2533001 	subs	r3, r3, #1
    6f88:	55843008 	strpl	r3, [r4, #8]
    6f8c:	53a01000 	movpl	r1, #0
    6f90:	43a01001 	movmi	r1, #1
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    6f94:	e321f01f 	msr	CPSR_c, #31
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
    6f98:	e3a00001 	mov	r0, #1
    6f9c:	ebffe67f 	bl	9a0 <_test_assert>
    6fa0:	e3500000 	cmp	r0, #0
    6fa4:	0a000001 	beq	6fb0 <sem2_execute+0x40>
}
    6fa8:	e28dd008 	add	sp, sp, #8
    6fac:	e8bd8070 	pop	{r4, r5, r6, pc}
  return (bool)(tqp->p_next == (const thread_t *)tqp);
    6fb0:	e5941000 	ldr	r1, [r4]
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
    6fb4:	e041c004 	sub	ip, r1, r4
    6fb8:	e27c1000 	rsbs	r1, ip, #0
    6fbc:	e0a1100c 	adc	r1, r1, ip
    6fc0:	e3a00002 	mov	r0, #2
    6fc4:	ebffe675 	bl	9a0 <_test_assert>
    6fc8:	e3500000 	cmp	r0, #0
    6fcc:	1afffff5 	bne	6fa8 <sem2_execute+0x38>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
    6fd0:	e5941008 	ldr	r1, [r4, #8]
    6fd4:	e2711001 	rsbs	r1, r1, #1
    6fd8:	33a01000 	movcc	r1, #0
    6fdc:	e3a00003 	mov	r0, #3
    6fe0:	ebffe66e 	bl	9a0 <_test_assert>
    6fe4:	e3500000 	cmp	r0, #0
    6fe8:	1affffee 	bne	6fa8 <sem2_execute+0x38>
  return ch.rlist.r_current;
    6fec:	e59f5144 	ldr	r5, [pc, #324]	; 7138 <sem2_execute+0x1c8>
  return chThdGetSelfX()->p_prio;
    6ff0:	e5953018 	ldr	r3, [r5, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
    6ff4:	e5932008 	ldr	r2, [r3, #8]
    6ff8:	e3a01e13 	mov	r1, #304	; 0x130
    6ffc:	e2422001 	sub	r2, r2, #1
    7000:	e59f3134 	ldr	r3, [pc, #308]	; 713c <sem2_execute+0x1cc>
    7004:	e58d0000 	str	r0, [sp]
    7008:	e59f0130 	ldr	r0, [pc, #304]	; 7140 <sem2_execute+0x1d0>
    700c:	ebffec77 	bl	21f0 <chThdCreateStatic>
    7010:	e59f312c 	ldr	r3, [pc, #300]	; 7144 <sem2_execute+0x1d4>
    7014:	e5830000 	str	r0, [r3]
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
    7018:	e3a00f7d 	mov	r0, #500	; 0x1f4
    701c:	ebffed5b 	bl	2590 <chSemWaitTimeout.constprop.46>
    7020:	e1a06000 	mov	r6, r0
  test_wait_threads();
    7024:	ebfff855 	bl	5180 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
    7028:	e2761001 	rsbs	r1, r6, #1
    702c:	33a01000 	movcc	r1, #0
    7030:	e3a00004 	mov	r0, #4
    7034:	ebffe659 	bl	9a0 <_test_assert>
    7038:	e3500000 	cmp	r0, #0
    703c:	1affffd9 	bne	6fa8 <sem2_execute+0x38>
    7040:	e5941000 	ldr	r1, [r4]
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
    7044:	e0412004 	sub	r2, r1, r4
    7048:	e2721000 	rsbs	r1, r2, #0
    704c:	e0a11002 	adc	r1, r1, r2
    7050:	e3a00005 	mov	r0, #5
    7054:	ebffe651 	bl	9a0 <_test_assert>
    7058:	e3500000 	cmp	r0, #0
    705c:	1affffd1 	bne	6fa8 <sem2_execute+0x38>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
    7060:	e5941008 	ldr	r1, [r4, #8]
    7064:	e2711001 	rsbs	r1, r1, #1
    7068:	33a01000 	movcc	r1, #0
    706c:	e3a00006 	mov	r0, #6
    7070:	ebffe64a 	bl	9a0 <_test_assert>
    7074:	e3500000 	cmp	r0, #0
    7078:	1affffca 	bne	6fa8 <sem2_execute+0x38>
  test_wait_tick();
    707c:	ebfff1b3 	bl	3750 <test_wait_tick>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    7080:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    7084:	e5956028 	ldr	r6, [r5, #40]	; 0x28
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    7088:	e321f01f 	msr	CPSR_c, #31
    708c:	e3a05041 	mov	r5, #65	; 0x41
    test_emit_token('A' + i);
    7090:	e1a00005 	mov	r0, r5
    7094:	ebffe651 	bl	9e0 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    7098:	e3a00032 	mov	r0, #50	; 0x32
    709c:	ebffed3b 	bl	2590 <chSemWaitTimeout.constprop.46>
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    70a0:	e3700001 	cmn	r0, #1
    70a4:	13a01000 	movne	r1, #0
    70a8:	03a01001 	moveq	r1, #1
    70ac:	e3a00007 	mov	r0, #7
    70b0:	ebffe63a 	bl	9a0 <_test_assert>
    70b4:	e3500000 	cmp	r0, #0
    70b8:	1affffba 	bne	6fa8 <sem2_execute+0x38>
    70bc:	e5941000 	ldr	r1, [r4]
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    70c0:	e0413004 	sub	r3, r1, r4
    70c4:	e2731000 	rsbs	r1, r3, #0
    70c8:	e0a11003 	adc	r1, r1, r3
    70cc:	e3a00008 	mov	r0, #8
    70d0:	ebffe632 	bl	9a0 <_test_assert>
    70d4:	e3500000 	cmp	r0, #0
    70d8:	1affffb2 	bne	6fa8 <sem2_execute+0x38>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
    70dc:	e5941008 	ldr	r1, [r4, #8]
    70e0:	e2711001 	rsbs	r1, r1, #1
    70e4:	33a01000 	movcc	r1, #0
    70e8:	e3a00009 	mov	r0, #9
    70ec:	ebffe62b 	bl	9a0 <_test_assert>
    70f0:	e2855001 	add	r5, r5, #1
    70f4:	e3500000 	cmp	r0, #0
    70f8:	e20550ff 	and	r5, r5, #255	; 0xff
    70fc:	1affffa9 	bne	6fa8 <sem2_execute+0x38>
  for (i = 0; i < 5; i++) {
    7100:	e3550046 	cmp	r5, #70	; 0x46
    7104:	1affffe1 	bne	7090 <sem2_execute+0x120>
  test_assert_sequence(10, "ABCDE");
    7108:	e59f1038 	ldr	r1, [pc, #56]	; 7148 <sem2_execute+0x1d8>
    710c:	e3a0000a 	mov	r0, #10
    7110:	ebffe602 	bl	920 <_test_assert_sequence>
    7114:	e3500000 	cmp	r0, #0
    7118:	1affffa2 	bne	6fa8 <sem2_execute+0x38>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
    711c:	e3a0000b 	mov	r0, #11
    7120:	e28620fc 	add	r2, r6, #252	; 0xfc
    7124:	e28610fa 	add	r1, r6, #250	; 0xfa
}
    7128:	e28dd008 	add	sp, sp, #8
    712c:	e8bd4070 	pop	{r4, r5, r6, lr}
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
    7130:	eaffe5e2 	b	8c0 <_test_assert_time_window>
    7134:	40000b04 	.word	0x40000b04
    7138:	40000c00 	.word	0x40000c00
    713c:	00003720 	.word	0x00003720
    7140:	40000e00 	.word	0x40000e00
    7144:	4000141c 	.word	0x4000141c
    7148:	000083b0 	.word	0x000083b0
    714c:	00000000 	.word	0x00000000

00007150 <sem1_execute>:
static void sem1_execute(void) {
    7150:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  return ch.rlist.r_current;
    7154:	e59f51bc 	ldr	r5, [pc, #444]	; 7318 <sem1_execute+0x1c8>
  return chThdGetSelfX()->p_prio;
    7158:	e5953018 	ldr	r3, [r5, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    715c:	e59f61b8 	ldr	r6, [pc, #440]	; 731c <sem1_execute+0x1cc>
    7160:	e5932008 	ldr	r2, [r3, #8]
static void sem1_execute(void) {
    7164:	e24dd00c 	sub	sp, sp, #12
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    7168:	e59f31b0 	ldr	r3, [pc, #432]	; 7320 <sem1_execute+0x1d0>
    716c:	e2822005 	add	r2, r2, #5
    7170:	e3a01e13 	mov	r1, #304	; 0x130
    7174:	e58d6000 	str	r6, [sp]
    7178:	e59f01a4 	ldr	r0, [pc, #420]	; 7324 <sem1_execute+0x1d4>
    717c:	ebffec1b 	bl	21f0 <chThdCreateStatic>
    7180:	e5953018 	ldr	r3, [r5, #24]
    7184:	e59f419c 	ldr	r4, [pc, #412]	; 7328 <sem1_execute+0x1d8>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    7188:	e5932008 	ldr	r2, [r3, #8]
    718c:	e59f3198 	ldr	r3, [pc, #408]	; 732c <sem1_execute+0x1dc>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    7190:	e5840000 	str	r0, [r4]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    7194:	e2822001 	add	r2, r2, #1
    7198:	e58d3000 	str	r3, [sp]
    719c:	e3a01e13 	mov	r1, #304	; 0x130
    71a0:	e59f3178 	ldr	r3, [pc, #376]	; 7320 <sem1_execute+0x1d0>
    71a4:	e59f0184 	ldr	r0, [pc, #388]	; 7330 <sem1_execute+0x1e0>
    71a8:	ebffec10 	bl	21f0 <chThdCreateStatic>
    71ac:	e5952018 	ldr	r2, [r5, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    71b0:	e59f317c 	ldr	r3, [pc, #380]	; 7334 <sem1_execute+0x1e4>
    71b4:	e5922008 	ldr	r2, [r2, #8]
    71b8:	e3a01e13 	mov	r1, #304	; 0x130
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    71bc:	e5840004 	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    71c0:	e2822003 	add	r2, r2, #3
    71c4:	e58d3000 	str	r3, [sp]
    71c8:	e59f0168 	ldr	r0, [pc, #360]	; 7338 <sem1_execute+0x1e8>
    71cc:	e59f314c 	ldr	r3, [pc, #332]	; 7320 <sem1_execute+0x1d0>
    71d0:	ebffec06 	bl	21f0 <chThdCreateStatic>
    71d4:	e5952018 	ldr	r2, [r5, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
    71d8:	e59f315c 	ldr	r3, [pc, #348]	; 733c <sem1_execute+0x1ec>
    71dc:	e5922008 	ldr	r2, [r2, #8]
    71e0:	e3a01e13 	mov	r1, #304	; 0x130
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    71e4:	e5840008 	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
    71e8:	e2822004 	add	r2, r2, #4
    71ec:	e58d3000 	str	r3, [sp]
    71f0:	e59f0148 	ldr	r0, [pc, #328]	; 7340 <sem1_execute+0x1f0>
    71f4:	e59f3124 	ldr	r3, [pc, #292]	; 7320 <sem1_execute+0x1d0>
    71f8:	ebffebfc 	bl	21f0 <chThdCreateStatic>
    71fc:	e5952018 	ldr	r2, [r5, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
    7200:	e59f313c 	ldr	r3, [pc, #316]	; 7344 <sem1_execute+0x1f4>
    7204:	e5922008 	ldr	r2, [r2, #8]
    7208:	e3a01e13 	mov	r1, #304	; 0x130
    720c:	e2822002 	add	r2, r2, #2
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
    7210:	e584000c 	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
    7214:	e58d3000 	str	r3, [sp]
    7218:	e59f0128 	ldr	r0, [pc, #296]	; 7348 <sem1_execute+0x1f8>
    721c:	e59f30fc 	ldr	r3, [pc, #252]	; 7320 <sem1_execute+0x1d0>
    7220:	ebffebf2 	bl	21f0 <chThdCreateStatic>
    7224:	e5840010 	str	r0, [r4, #16]
  chSemSignal(&sem1);
    7228:	e59f011c 	ldr	r0, [pc, #284]	; 734c <sem1_execute+0x1fc>
    722c:	ebffebdb 	bl	21a0 <chSemSignal>
  chSemSignal(&sem1);
    7230:	e59f0114 	ldr	r0, [pc, #276]	; 734c <sem1_execute+0x1fc>
    7234:	ebffebd9 	bl	21a0 <chSemSignal>
  chSemSignal(&sem1);
    7238:	e59f010c 	ldr	r0, [pc, #268]	; 734c <sem1_execute+0x1fc>
    723c:	ebffebd7 	bl	21a0 <chSemSignal>
  chSemSignal(&sem1);
    7240:	e59f0104 	ldr	r0, [pc, #260]	; 734c <sem1_execute+0x1fc>
    7244:	ebffebd5 	bl	21a0 <chSemSignal>
  chSemSignal(&sem1);
    7248:	e59f00fc 	ldr	r0, [pc, #252]	; 734c <sem1_execute+0x1fc>
    724c:	ebffebd3 	bl	21a0 <chSemSignal>
  test_wait_threads();
    7250:	ebfff7ca 	bl	5180 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    7254:	e59f10f4 	ldr	r1, [pc, #244]	; 7350 <sem1_execute+0x200>
    7258:	e3a00001 	mov	r0, #1
    725c:	ebffe5af 	bl	920 <_test_assert_sequence>
    7260:	e2507000 	subs	r7, r0, #0
    7264:	0a000001 	beq	7270 <sem1_execute+0x120>
}
    7268:	e28dd00c 	add	sp, sp, #12
    726c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    7270:	e5953018 	ldr	r3, [r5, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    7274:	e5932008 	ldr	r2, [r3, #8]
    7278:	e3a01e13 	mov	r1, #304	; 0x130
    727c:	e59f309c 	ldr	r3, [pc, #156]	; 7320 <sem1_execute+0x1d0>
    7280:	e2822005 	add	r2, r2, #5
    7284:	e58d6000 	str	r6, [sp]
    7288:	e59f0094 	ldr	r0, [pc, #148]	; 7324 <sem1_execute+0x1d4>
    728c:	ebffebd7 	bl	21f0 <chThdCreateStatic>
    7290:	e5840000 	str	r0, [r4]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    7294:	e321f09f 	msr	CPSR_c, #159	; 0x9f
    7298:	e3a05002 	mov	r5, #2
    729c:	e59f40a8 	ldr	r4, [pc, #168]	; 734c <sem1_execute+0x1fc>
    72a0:	ea000002 	b	72b0 <sem1_execute+0x160>
  while (n > (cnt_t)0) {
    72a4:	e3550001 	cmp	r5, #1
    72a8:	0a00000d 	beq	72e4 <sem1_execute+0x194>
    72ac:	e3a05001 	mov	r5, #1
    if (++sp->s_cnt <= (cnt_t)0) {
    72b0:	e5943008 	ldr	r3, [r4, #8]
    72b4:	e2833001 	add	r3, r3, #1
    72b8:	e3530000 	cmp	r3, #0
    72bc:	e5843008 	str	r3, [r4, #8]
    72c0:	cafffff7 	bgt	72a4 <sem1_execute+0x154>
  thread_t *tp = tqp->p_next;
    72c4:	e5940000 	ldr	r0, [r4]
  tqp->p_next = tp->p_next;
    72c8:	e5903000 	ldr	r3, [r0]
  tqp->p_next->p_prev = (thread_t *)tqp;
    72cc:	e5834004 	str	r4, [r3, #4]
  tqp->p_next = tp->p_next;
    72d0:	e5843000 	str	r3, [r4]
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
    72d4:	ebffe735 	bl	fb0 <chSchReadyI>
  while (n > (cnt_t)0) {
    72d8:	e3550001 	cmp	r5, #1
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
    72dc:	e5807024 	str	r7, [r0, #36]	; 0x24
  while (n > (cnt_t)0) {
    72e0:	1afffff1 	bne	72ac <sem1_execute+0x15c>
  chSchRescheduleS();
    72e4:	ebffea3d 	bl	1be0 <chSchRescheduleS>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    72e8:	e321f01f 	msr	CPSR_c, #31
  test_wait_threads();
    72ec:	ebfff7a3 	bl	5180 <test_wait_threads>
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    72f0:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
    72f4:	e5941008 	ldr	r1, [r4, #8]
    72f8:	e2413001 	sub	r3, r1, #1
    72fc:	e2731000 	rsbs	r1, r3, #0
    7300:	e0a11003 	adc	r1, r1, r3
    7304:	e3a00002 	mov	r0, #2
    7308:	ebffe5a4 	bl	9a0 <_test_assert>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    730c:	e321f01f 	msr	CPSR_c, #31
}
    7310:	e28dd00c 	add	sp, sp, #12
    7314:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    7318:	40000c00 	.word	0x40000c00
    731c:	000081a0 	.word	0x000081a0
    7320:	00005070 	.word	0x00005070
    7324:	40000e00 	.word	0x40000e00
    7328:	4000141c 	.word	0x4000141c
    732c:	00008190 	.word	0x00008190
    7330:	40000f30 	.word	0x40000f30
    7334:	00008194 	.word	0x00008194
    7338:	40001060 	.word	0x40001060
    733c:	00008198 	.word	0x00008198
    7340:	40001190 	.word	0x40001190
    7344:	000083b4 	.word	0x000083b4
    7348:	400012c0 	.word	0x400012c0
    734c:	40000b04 	.word	0x40000b04
    7350:	000083b0 	.word	0x000083b0
	...

00007360 <thd2_execute>:
static void thd2_execute(void) {
    7360:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  return ch.rlist.r_current;
    7364:	e59f5164 	ldr	r5, [pc, #356]	; 74d0 <thd2_execute+0x170>
  return chThdGetSelfX()->p_prio;
    7368:	e5953018 	ldr	r3, [r5, #24]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    736c:	e59f7160 	ldr	r7, [pc, #352]	; 74d4 <thd2_execute+0x174>
    7370:	e59f4160 	ldr	r4, [pc, #352]	; 74d8 <thd2_execute+0x178>
    7374:	e5932008 	ldr	r2, [r3, #8]
    7378:	e59f115c 	ldr	r1, [pc, #348]	; 74dc <thd2_execute+0x17c>
static void thd2_execute(void) {
    737c:	e24dd008 	sub	sp, sp, #8
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    7380:	e1a03007 	mov	r3, r7
    7384:	e58d1000 	str	r1, [sp]
    7388:	e2422004 	sub	r2, r2, #4
    738c:	e2840e13 	add	r0, r4, #304	; 0x130
    7390:	e3a01e13 	mov	r1, #304	; 0x130
    7394:	ebffeb95 	bl	21f0 <chThdCreateStatic>
    7398:	e5953018 	ldr	r3, [r5, #24]
    739c:	e59f613c 	ldr	r6, [pc, #316]	; 74e0 <thd2_execute+0x180>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    73a0:	e5932008 	ldr	r2, [r3, #8]
    73a4:	e59f1138 	ldr	r1, [pc, #312]	; 74e4 <thd2_execute+0x184>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    73a8:	e5860004 	str	r0, [r6, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    73ac:	e1a03007 	mov	r3, r7
    73b0:	e58d1000 	str	r1, [sp]
    73b4:	e2422005 	sub	r2, r2, #5
    73b8:	e1a00004 	mov	r0, r4
    73bc:	e3a01e13 	mov	r1, #304	; 0x130
    73c0:	ebffeb8a 	bl	21f0 <chThdCreateStatic>
    73c4:	e5953018 	ldr	r3, [r5, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    73c8:	e59f1118 	ldr	r1, [pc, #280]	; 74e8 <thd2_execute+0x188>
    73cc:	e5932008 	ldr	r2, [r3, #8]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    73d0:	e5860000 	str	r0, [r6]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    73d4:	e1a03007 	mov	r3, r7
    73d8:	e58d1000 	str	r1, [sp]
    73dc:	e2422001 	sub	r2, r2, #1
    73e0:	e2840d13 	add	r0, r4, #1216	; 0x4c0
    73e4:	e3a01e13 	mov	r1, #304	; 0x130
    73e8:	ebffeb80 	bl	21f0 <chThdCreateStatic>
    73ec:	e5953018 	ldr	r3, [r5, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    73f0:	e59f10f4 	ldr	r1, [pc, #244]	; 74ec <thd2_execute+0x18c>
    73f4:	e5932008 	ldr	r2, [r3, #8]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    73f8:	e5860010 	str	r0, [r6, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    73fc:	e58d1000 	str	r1, [sp]
    7400:	e2422002 	sub	r2, r2, #2
    7404:	e1a03007 	mov	r3, r7
    7408:	e2840e39 	add	r0, r4, #912	; 0x390
    740c:	e3a01e13 	mov	r1, #304	; 0x130
    7410:	ebffeb76 	bl	21f0 <chThdCreateStatic>
    7414:	e586000c 	str	r0, [r6, #12]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    7418:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  tp->p_state = CH_STATE_WTSTART;
    741c:	e3a0c002 	mov	ip, #2
  tp->p_mtxlist = NULL;
    7420:	e3a03000 	mov	r3, #0
  tp->p_refs = (trefs_t)1;
    7424:	e3a08001 	mov	r8, #1
    7428:	e5952018 	ldr	r2, [r5, #24]
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    742c:	e5922008 	ldr	r2, [r2, #8]
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    7430:	e59f10b8 	ldr	r1, [pc, #184]	; 74f0 <thd2_execute+0x190>
    7434:	e2422003 	sub	r2, r2, #3
  tp->p_prio = prio;
    7438:	e5842268 	str	r2, [r4, #616]	; 0x268
  tp->p_realprio = prio;
    743c:	e58422a0 	str	r2, [r4, #672]	; 0x2a0
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    7440:	e2840fdb 	add	r0, r4, #876	; 0x36c
    7444:	e59f20a8 	ldr	r2, [pc, #168]	; 74f4 <thd2_execute+0x194>
    7448:	e584026c 	str	r0, [r4, #620]	; 0x26c
    744c:	e5841370 	str	r1, [r4, #880]	; 0x370
  REG_INSERT(tp);
    7450:	e5950014 	ldr	r0, [r5, #20]
  tp->p_state = CH_STATE_WTSTART;
    7454:	e2841f9f 	add	r1, r4, #636	; 0x27c
    7458:	e1c1c0b0 	strh	ip, [r1]
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    745c:	e584238c 	str	r2, [r4, #908]	; 0x38c
  tqp->p_next = (thread_t *)tqp;
    7460:	e2841fa3 	add	r1, r4, #652	; 0x28c
  REG_INSERT(tp);
    7464:	e2842e26 	add	r2, r4, #608	; 0x260
  tlp->p_next = (thread_t *)tlp;
    7468:	e284cfa2 	add	ip, r4, #648	; 0x288
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
    746c:	e584736c 	str	r7, [r4, #876]	; 0x36c
  REG_INSERT(tp);
    7470:	e5845270 	str	r5, [r4, #624]	; 0x270
    7474:	e5840274 	str	r0, [r4, #628]	; 0x274
  tp->p_mtxlist = NULL;
    7478:	e584329c 	str	r3, [r4, #668]	; 0x29c
  tp->p_epending = (eventmask_t)0;
    747c:	e5843298 	str	r3, [r4, #664]	; 0x298
  tp->p_time = (systime_t)0;
    7480:	e5843280 	str	r3, [r4, #640]	; 0x280
  tp->p_name = NULL;
    7484:	e5843278 	str	r3, [r4, #632]	; 0x278
  tp->p_refs = (trefs_t)1;
    7488:	e5c4827e 	strb	r8, [r4, #638]	; 0x27e
  REG_INSERT(tp);
    748c:	e5802010 	str	r2, [r0, #16]
    7490:	e5852014 	str	r2, [r5, #20]
    7494:	e5862008 	str	r2, [r6, #8]
    7498:	e584c288 	str	ip, [r4, #648]	; 0x288
  tqp->p_next = (thread_t *)tqp;
    749c:	e584128c 	str	r1, [r4, #652]	; 0x28c
  tqp->p_prev = (thread_t *)tqp;
    74a0:	e5841290 	str	r1, [r4, #656]	; 0x290
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    74a4:	e321f01f 	msr	CPSR_c, #31
  chThdStart(threads[2]);
    74a8:	e5960008 	ldr	r0, [r6, #8]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    74ac:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  return chSchReadyI(tp);
    74b0:	ebffe6be 	bl	fb0 <chSchReadyI>
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    74b4:	e321f01f 	msr	CPSR_c, #31
  test_wait_threads();
    74b8:	ebfff730 	bl	5180 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    74bc:	e1a00008 	mov	r0, r8
    74c0:	e59f1030 	ldr	r1, [pc, #48]	; 74f8 <thd2_execute+0x198>
}
    74c4:	e28dd008 	add	sp, sp, #8
    74c8:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  test_assert_sequence(1, "ABCDE");
    74cc:	eaffe513 	b	920 <_test_assert_sequence>
    74d0:	40000c00 	.word	0x40000c00
    74d4:	00000a40 	.word	0x00000a40
    74d8:	40000e00 	.word	0x40000e00
    74dc:	00008198 	.word	0x00008198
    74e0:	4000141c 	.word	0x4000141c
    74e4:	000083b4 	.word	0x000083b4
    74e8:	000081a0 	.word	0x000081a0
    74ec:	00008190 	.word	0x00008190
    74f0:	00008194 	.word	0x00008194
    74f4:	00000180 	.word	0x00000180
    74f8:	000083b0 	.word	0x000083b0
    74fc:	00000000 	.word	0x00000000

00007500 <thd1_execute>:
static void thd1_execute(void) {
    7500:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  return ch.rlist.r_current;
    7504:	e59f70ec 	ldr	r7, [pc, #236]	; 75f8 <thd1_execute+0xf8>
  return chThdGetSelfX()->p_prio;
    7508:	e5973018 	ldr	r3, [r7, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    750c:	e59f60e8 	ldr	r6, [pc, #232]	; 75fc <thd1_execute+0xfc>
    7510:	e59f50e8 	ldr	r5, [pc, #232]	; 7600 <thd1_execute+0x100>
    7514:	e5932008 	ldr	r2, [r3, #8]
    7518:	e59f10e4 	ldr	r1, [pc, #228]	; 7604 <thd1_execute+0x104>
static void thd1_execute(void) {
    751c:	e24dd00c 	sub	sp, sp, #12
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    7520:	e1a03006 	mov	r3, r6
    7524:	e58d1000 	str	r1, [sp]
    7528:	e2422005 	sub	r2, r2, #5
    752c:	e1a00005 	mov	r0, r5
    7530:	e3a01e13 	mov	r1, #304	; 0x130
    7534:	ebffeb2d 	bl	21f0 <chThdCreateStatic>
    7538:	e5973018 	ldr	r3, [r7, #24]
    753c:	e59f40c4 	ldr	r4, [pc, #196]	; 7608 <thd1_execute+0x108>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    7540:	e5932008 	ldr	r2, [r3, #8]
    7544:	e59f10c0 	ldr	r1, [pc, #192]	; 760c <thd1_execute+0x10c>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    7548:	e5840000 	str	r0, [r4]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    754c:	e1a03006 	mov	r3, r6
    7550:	e58d1000 	str	r1, [sp]
    7554:	e2422004 	sub	r2, r2, #4
    7558:	e2850e13 	add	r0, r5, #304	; 0x130
    755c:	e3a01e13 	mov	r1, #304	; 0x130
    7560:	ebffeb22 	bl	21f0 <chThdCreateStatic>
    7564:	e5973018 	ldr	r3, [r7, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    7568:	e59f10a0 	ldr	r1, [pc, #160]	; 7610 <thd1_execute+0x110>
    756c:	e5932008 	ldr	r2, [r3, #8]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    7570:	e5840004 	str	r0, [r4, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    7574:	e1a03006 	mov	r3, r6
    7578:	e58d1000 	str	r1, [sp]
    757c:	e2422003 	sub	r2, r2, #3
    7580:	e2850e26 	add	r0, r5, #608	; 0x260
    7584:	e3a01e13 	mov	r1, #304	; 0x130
    7588:	ebffeb18 	bl	21f0 <chThdCreateStatic>
    758c:	e5973018 	ldr	r3, [r7, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    7590:	e59f107c 	ldr	r1, [pc, #124]	; 7614 <thd1_execute+0x114>
    7594:	e5932008 	ldr	r2, [r3, #8]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    7598:	e5840008 	str	r0, [r4, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    759c:	e1a03006 	mov	r3, r6
    75a0:	e58d1000 	str	r1, [sp]
    75a4:	e2422002 	sub	r2, r2, #2
    75a8:	e2850e39 	add	r0, r5, #912	; 0x390
    75ac:	e3a01e13 	mov	r1, #304	; 0x130
    75b0:	ebffeb0e 	bl	21f0 <chThdCreateStatic>
    75b4:	e5973018 	ldr	r3, [r7, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    75b8:	e59f1058 	ldr	r1, [pc, #88]	; 7618 <thd1_execute+0x118>
    75bc:	e5932008 	ldr	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    75c0:	e584000c 	str	r0, [r4, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    75c4:	e2422001 	sub	r2, r2, #1
    75c8:	e1a03006 	mov	r3, r6
    75cc:	e58d1000 	str	r1, [sp]
    75d0:	e2850d13 	add	r0, r5, #1216	; 0x4c0
    75d4:	e3a01e13 	mov	r1, #304	; 0x130
    75d8:	ebffeb04 	bl	21f0 <chThdCreateStatic>
    75dc:	e5840010 	str	r0, [r4, #16]
  test_wait_threads();
    75e0:	ebfff6e6 	bl	5180 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
    75e4:	e3a00001 	mov	r0, #1
    75e8:	e59f102c 	ldr	r1, [pc, #44]	; 761c <thd1_execute+0x11c>
}
    75ec:	e28dd00c 	add	sp, sp, #12
    75f0:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
  test_assert_sequence(1, "ABCDE");
    75f4:	eaffe4c9 	b	920 <_test_assert_sequence>
    75f8:	40000c00 	.word	0x40000c00
    75fc:	00000a40 	.word	0x00000a40
    7600:	40000e00 	.word	0x40000e00
    7604:	000083b4 	.word	0x000083b4
    7608:	4000141c 	.word	0x4000141c
    760c:	00008198 	.word	0x00008198
    7610:	00008194 	.word	0x00008194
    7614:	00008190 	.word	0x00008190
    7618:	000081a0 	.word	0x000081a0
    761c:	000083b0 	.word	0x000083b0

00007620 <main>:
 */
void vic_init(void) {
  int i;

  VIC *vic = VICBase;
  vic->VIC_IntSelect = 0;               /* All sources assigned to IRQ. */
    7620:	e3e03c0f 	mvn	r3, #3840	; 0xf00
    7624:	e3a02000 	mov	r2, #0
  vic->VIC_SoftIntClear = ALLINTMASK;   /* No interrupts enforced */
  vic->VIC_IntEnClear = ALLINTMASK;     /* All sources disabled. */
  for (i = 0; i < 16; i++) {
    vic->VIC_VectCntls[i] = 0;
    vic->VIC_VectAddrs[i] = 0;
    vic->VIC_VectAddr = 0;
    7628:	e1a05003 	mov	r5, r3
}

/*
 * Application entry point.
 */
int main(void) {
    762c:	e92d4880 	push	{r7, fp, lr}
  for (i = 0; i < 16; i++) {
    7630:	e1a06002 	mov	r6, r2
  vic->VIC_IntSelect = 0;               /* All sources assigned to IRQ. */
    7634:	e50320f3 	str	r2, [r3, #-243]	; 0xffffff0d
    vic->VIC_VectCntls[i] = 0;
    7638:	e1a04002 	mov	r4, r2
    vic->VIC_VectAddr = 0;
    763c:	e1a01002 	mov	r1, r2
  vic->VIC_SoftIntClear = ALLINTMASK;   /* No interrupts enforced */
    7640:	e59f273c 	ldr	r2, [pc, #1852]	; 7d84 <__ram0_size__+0xa4>
    7644:	e50320e3 	str	r2, [r3, #-227]	; 0xffffff1d
  vic->VIC_IntEnClear = ALLINTMASK;     /* All sources disabled. */
    7648:	e50320eb 	str	r2, [r3, #-235]	; 0xffffff15
    764c:	e24dd01c 	sub	sp, sp, #28
    7650:	e1a03106 	lsl	r3, r6, #2
  for (i = 0; i < 16; i++) {
    7654:	e2866001 	add	r6, r6, #1
    7658:	e3560010 	cmp	r6, #16
    vic->VIC_VectCntls[i] = 0;
    765c:	e5034e00 	str	r4, [r3, #-3584]	; 0xfffff200
    vic->VIC_VectAddrs[i] = 0;
    7660:	e5034f00 	str	r4, [r3, #-3840]	; 0xfffff100
    vic->VIC_VectAddr = 0;
    7664:	e50510cf 	str	r1, [r5, #-207]	; 0xffffff31
  for (i = 0; i < 16; i++) {
    7668:	1afffff8 	bne	7650 <main+0x30>
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {

  /* Enables the access through the fast registers.*/
  SCS = 3;
    766c:	e3a0b003 	mov	fp, #3

  /* I/O pads initial assignment, device drivers may change this setup at a
   * later time.*/
  PINSEL0 = config->pinsel0;
  PINSEL1 = config->pinsel1;
  PINSEL2 = config->pinsel2;
    7670:	e3a0c004 	mov	ip, #4

  /* I/O pads direction initial setting.*/
  FIO0Base->FIO_MASK = 0;
  FIO0Base->FIO_PIN = config->P0Data.pin;
    7674:	e3e09000 	mvn	r9, #0
  PINSEL0 = config->pinsel0;
    7678:	e59f2708 	ldr	r2, [pc, #1800]	; 7d88 <__ram0_size__+0xa8>
    767c:	e59fe708 	ldr	lr, [pc, #1800]	; 7d8c <__ram0_size__+0xac>
 * @notapi
 */
void hal_lld_init(void) {

  vic_init();
  VICDefVectAddr = (IOREG32)irq_handler;
    7680:	e59f3708 	ldr	r3, [pc, #1800]	; 7d90 <__ram0_size__+0xb0>
  SCS = 3;
    7684:	e59f8708 	ldr	r8, [pc, #1800]	; 7d94 <__ram0_size__+0xb4>
  PINSEL1 = config->pinsel1;
    7688:	e59f1708 	ldr	r1, [pc, #1800]	; 7d98 <__ram0_size__+0xb8>
    768c:	e50530cb 	str	r3, [r5, #-203]	; 0xffffff35
  FIO0Base->FIO_DIR = config->P0Data.dir;
    7690:	e59f0704 	ldr	r0, [pc, #1796]	; 7d9c <__ram0_size__+0xbc>
  SCS = 3;
    7694:	e588b1a0 	str	fp, [r8, #416]	; 0x1a0
  FIO0Base->FIO_MASK = 0;
    7698:	e59f3700 	ldr	r3, [pc, #1792]	; 7da0 <__ram0_size__+0xc0>
  PINSEL0 = config->pinsel0;
    769c:	e582e000 	str	lr, [r2]
  PINSEL1 = config->pinsel1;
    76a0:	e5821004 	str	r1, [r2, #4]
  FIO1Base->FIO_MASK = 0;
  FIO1Base->FIO_PIN = config->P1Data.pin;
  FIO1Base->FIO_DIR = config->P1Data.dir;
    76a4:	e59f16f8 	ldr	r1, [pc, #1784]	; 7da4 <__ram0_size__+0xc4>
  PINSEL2 = config->pinsel2;
    76a8:	e582c014 	str	ip, [r2, #20]
  FIO0Base->FIO_MASK = 0;
    76ac:	e50340ef 	str	r4, [r3, #-239]	; 0xffffff11
  FIO0Base->FIO_PIN = config->P0Data.pin;
    76b0:	e50390eb 	str	r9, [r3, #-235]	; 0xffffff15
  FIO0Base->FIO_DIR = config->P0Data.dir;
    76b4:	e50300ff 	str	r0, [r3, #-255]	; 0xffffff01
  FIO1Base->FIO_MASK = 0;
    76b8:	e50340cf 	str	r4, [r3, #-207]	; 0xffffff31
 * @notapi
 */
void sd_lld_init(void) {

#if USE_LPC214x_UART0
  sdObjectInit(&SD1, NULL, notify1);
    76bc:	e59f06e4 	ldr	r0, [pc, #1764]	; 7da8 <__ram0_size__+0xc8>
  FIO1Base->FIO_PIN = config->P1Data.pin;
    76c0:	e50390cb 	str	r9, [r3, #-203]	; 0xffffff35
  FIO1Base->FIO_DIR = config->P1Data.dir;
    76c4:	e50310df 	str	r1, [r3, #-223]	; 0xffffff21
    76c8:	e59f16dc 	ldr	r1, [pc, #1756]	; 7dac <__ram0_size__+0xcc>
    76cc:	ebffe2c3 	bl	1e0 <sdObjectInit.constprop.6>
 */
void SetVICVector(void *handler, int vector, int source) {

  VIC *vicp = VICBase;
  vicp->VIC_VectAddrs[vector] = (IOREG32)handler;
  vicp->VIC_VectCntls[vector] = (IOREG32)(source | 0x20);
    76d0:	e3a02026 	mov	r2, #38	; 0x26
  vicp->VIC_VectAddrs[vector] = (IOREG32)handler;
    76d4:	e59f16d4 	ldr	r1, [pc, #1748]	; 7db0 <__ram0_size__+0xd0>
  SD1.uart = U0Base;
  SetVICVector(UART0IrqHandler, LPC214x_UART0_PRIORITY, SOURCE_UART0);
#endif
#if USE_LPC214x_UART1
  sdObjectInit(&SD2, NULL, notify2);
    76d8:	e59fa6d4 	ldr	sl, [pc, #1748]	; 7db4 <__ram0_size__+0xd4>
    76dc:	e5851005 	str	r1, [r5, #5]
  SD1.uart = U0Base;
    76e0:	e59f36d0 	ldr	r3, [pc, #1744]	; 7db8 <__ram0_size__+0xd8>
  vicp->VIC_VectCntls[vector] = (IOREG32)(source | 0x20);
    76e4:	e5852105 	str	r2, [r5, #261]	; 0x105
    76e8:	e59f26b8 	ldr	r2, [pc, #1720]	; 7da8 <__ram0_size__+0xc8>
  sdObjectInit(&SD2, NULL, notify2);
    76ec:	e1a0000a 	mov	r0, sl
    76f0:	e59f16c4 	ldr	r1, [pc, #1732]	; 7dbc <__ram0_size__+0xdc>
  SD1.uart = U0Base;
    76f4:	e5823074 	str	r3, [r2, #116]	; 0x74
  sdObjectInit(&SD2, NULL, notify2);
    76f8:	ebffe2b8 	bl	1e0 <sdObjectInit.constprop.6>
    76fc:	e3a00027 	mov	r0, #39	; 0x27
    7700:	e3a01024 	mov	r1, #36	; 0x24
  TC *timer = T0Base;
  timer->TC_PR = VAL_TC0_PRESCALER;
  timer->TC_MR0 = (PCLK / CH_CFG_ST_FREQUENCY) / (VAL_TC0_PRESCALER + 1);
  timer->TC_MCR = 3;    /* Interrupt and clear TC on match MR0. */
  timer->TC_TCR = 2;    /* Reset counter and prescaler. */
  timer->TC_TCR = 1;    /* Timer enabled. */
    7704:	e3a02001 	mov	r2, #1
  timer->TC_TCR = 2;    /* Reset counter and prescaler. */
    7708:	e3a03002 	mov	r3, #2
  tp->p_prio = prio;
    770c:	e3a07040 	mov	r7, #64	; 0x40
  vicp->VIC_VectAddrs[vector] = (IOREG32)handler;
    7710:	e59fc6a8 	ldr	ip, [pc, #1704]	; 7dc0 <__ram0_size__+0xe0>
    7714:	e585c009 	str	ip, [r5, #9]
  vicp->VIC_VectCntls[vector] = (IOREG32)(source | 0x20);
    7718:	e5850109 	str	r0, [r5, #265]	; 0x109
  vicp->VIC_VectAddrs[vector] = (IOREG32)handler;
    771c:	e59f06a0 	ldr	r0, [pc, #1696]	; 7dc4 <__ram0_size__+0xe4>
  timer->TC_MR0 = (PCLK / CH_CFG_ST_FREQUENCY) / (VAL_TC0_PRESCALER + 1);
    7720:	e59fc6a0 	ldr	ip, [pc, #1696]	; 7dc8 <__ram0_size__+0xe8>
    7724:	e5850001 	str	r0, [r5, #1]
  vicp->VIC_VectCntls[vector] = (IOREG32)(source | 0x20);
    7728:	e5851101 	str	r1, [r5, #257]	; 0x101
  tqp->p_next = (thread_t *)tqp;
    772c:	e59f0698 	ldr	r0, [pc, #1688]	; 7dcc <__ram0_size__+0xec>
  timer->TC_PR = VAL_TC0_PRESCALER;
    7730:	e59f1698 	ldr	r1, [pc, #1688]	; 7dd0 <__ram0_size__+0xf0>
  VICIntEnable = INTMASK(SOURCE_Timer0);
    7734:	e50560ef 	str	r6, [r5, #-239]	; 0xffffff11
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
    7738:	e59fe694 	ldr	lr, [pc, #1684]	; 7dd4 <__ram0_size__+0xf4>
  timer->TC_PR = VAL_TC0_PRESCALER;
    773c:	e581400c 	str	r4, [r1, #12]
  ch.vtlist.vt_delta = (systime_t)-1;
    7740:	e5809024 	str	r9, [r0, #36]	; 0x24
  timer->TC_MR0 = (PCLK / CH_CFG_ST_FREQUENCY) / (VAL_TC0_PRESCALER + 1);
    7744:	e581c018 	str	ip, [r1, #24]
  timer->TC_MCR = 3;    /* Interrupt and clear TC on match MR0. */
    7748:	e581b014 	str	fp, [r1, #20]
  timer->TC_TCR = 2;    /* Reset counter and prescaler. */
    774c:	e5813004 	str	r3, [r1, #4]
  timer->TC_TCR = 1;    /* Timer enabled. */
    7750:	e5812004 	str	r2, [r1, #4]
  SD2.uart = U1Base;
    7754:	e2811903 	add	r1, r1, #49152	; 0xc000
    7758:	e58a1074 	str	r1, [sl, #116]	; 0x74
    775c:	e59f1674 	ldr	r1, [pc, #1652]	; 7dd8 <__ram0_size__+0xf8>
    7760:	e3cee007 	bic	lr, lr, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
    7764:	e59fc670 	ldr	ip, [pc, #1648]	; 7ddc <__ram0_size__+0xfc>
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
    7768:	e581e000 	str	lr, [r1]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
    776c:	e59f166c 	ldr	r1, [pc, #1644]	; 7de0 <__ram0_size__+0x100>
  default_heap.h_provider = chCoreAlloc;
    7770:	e59f366c 	ldr	r3, [pc, #1644]	; 7de4 <__ram0_size__+0x104>
    7774:	e3ccc007 	bic	ip, ip, #7
    7778:	e581c000 	str	ip, [r1]
    777c:	e59fc664 	ldr	ip, [pc, #1636]	; 7de8 <__ram0_size__+0x108>
    7780:	e2831010 	add	r1, r3, #16
  default_heap.h_free.h.u.next = NULL;
    7784:	e5834008 	str	r4, [r3, #8]
  default_heap.h_free.h.size = 0;
    7788:	e583400c 	str	r4, [r3, #12]
  mp->m_owner = NULL;
    778c:	e5834018 	str	r4, [r3, #24]
  default_heap.h_provider = chCoreAlloc;
    7790:	e583c000 	str	ip, [r3]
    7794:	e5831010 	str	r1, [r3, #16]
  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
    7798:	e280c01c 	add	ip, r0, #28
  tqp->p_prev = (thread_t *)tqp;
    779c:	e5831014 	str	r1, [r3, #20]
  tlp->p_next = (thread_t *)tlp;
    77a0:	e2806058 	add	r6, r0, #88	; 0x58
  REG_INSERT(tp);
    77a4:	e2803030 	add	r3, r0, #48	; 0x30
  tqp->p_next = (thread_t *)tqp;
    77a8:	e280105c 	add	r1, r0, #92	; 0x5c
  ch.vtlist.vt_systime = (systime_t)0;
    77ac:	e5804028 	str	r4, [r0, #40]	; 0x28
    77b0:	e5800000 	str	r0, [r0]
  ch.rlist.r_prio = NOPRIO;
    77b4:	e9800011 	stmib	r0, {r0, r4}
  tp->p_flags = CH_FLAG_MODE_STATIC;
    77b8:	e5c0404d 	strb	r4, [r0, #77]	; 0x4d
  tp->p_mtxlist = NULL;
    77bc:	e580406c 	str	r4, [r0, #108]	; 0x6c
  tp->p_epending = (eventmask_t)0;
    77c0:	e5804068 	str	r4, [r0, #104]	; 0x68
  tp->p_time = (systime_t)0;
    77c4:	e5804050 	str	r4, [r0, #80]	; 0x50
  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
    77c8:	e580c01c 	str	ip, [r0, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
    77cc:	e580c020 	str	ip, [r0, #32]
  tp->p_prio = prio;
    77d0:	e5807038 	str	r7, [r0, #56]	; 0x38
  tp->p_realprio = prio;
    77d4:	e5807070 	str	r7, [r0, #112]	; 0x70
  tp->p_refs = (trefs_t)1;
    77d8:	e5c0204e 	strb	r2, [r0, #78]	; 0x4e
  tlp->p_next = (thread_t *)tlp;
    77dc:	e5806058 	str	r6, [r0, #88]	; 0x58
  tp->p_name = NULL;
    77e0:	e5804048 	str	r4, [r0, #72]	; 0x48
  REG_INSERT(tp);
    77e4:	e5800040 	str	r0, [r0, #64]	; 0x40
    77e8:	e5800044 	str	r0, [r0, #68]	; 0x44
  currp->p_state = CH_STATE_CURRENT;
    77ec:	e5c0204c 	strb	r2, [r0, #76]	; 0x4c
    77f0:	e5803010 	str	r3, [r0, #16]
    77f4:	e5803014 	str	r3, [r0, #20]
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
    77f8:	e5803018 	str	r3, [r0, #24]
  tqp->p_next = (thread_t *)tqp;
    77fc:	e580105c 	str	r1, [r0, #92]	; 0x5c
  tqp->p_prev = (thread_t *)tqp;
    7800:	e5801060 	str	r1, [r0, #96]	; 0x60
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    7804:	e321f01f 	msr	CPSR_c, #31
    7808:	e59f15dc 	ldr	r1, [pc, #1500]	; 7dec <__ram0_size__+0x10c>
    780c:	e5903018 	ldr	r3, [r0, #24]
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
    7810:	e2800078 	add	r0, r0, #120	; 0x78
    7814:	e5831018 	str	r1, [r3, #24]
    7818:	e59f35d0 	ldr	r3, [pc, #1488]	; 7df0 <__ram0_size__+0x110>
    781c:	e58d4000 	str	r4, [sp]
    7820:	e3a010d0 	mov	r1, #208	; 0xd0
    7824:	ebffea71 	bl	21f0 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
    7828:	e59f35c4 	ldr	r3, [pc, #1476]	; 7df4 <__ram0_size__+0x114>
    782c:	e5803018 	str	r3, [r0, #24]
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    7830:	e321f09f 	msr	CPSR_c, #159	; 0x9f
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
    7834:	e59f256c 	ldr	r2, [pc, #1388]	; 7da8 <__ram0_size__+0xc8>
    7838:	e5d23008 	ldrb	r3, [r2, #8]
    783c:	e3530001 	cmp	r3, #1
    7840:	1a000005 	bne	785c <main+0x23c>
#if USE_LPC214x_UART0
    if (&SD1 == sdp) {
      PCONP = (PCONP & PCALL) | PCUART0;
    7844:	e59820c4 	ldr	r2, [r8, #196]	; 0xc4
    7848:	e59f35a8 	ldr	r3, [pc, #1448]	; 7df8 <__ram0_size__+0x118>
    784c:	e0033002 	and	r3, r3, r2
    7850:	e3833008 	orr	r3, r3, #8
    7854:	e58830c4 	str	r3, [r8, #196]	; 0xc4
      VICIntEnable = INTMASK(SOURCE_UART0);
    7858:	e50570ef 	str	r7, [r5, #-239]	; 0xffffff11
  u->UART_DLM = div >> 8;
    785c:	e3a04000 	mov	r4, #0
  u->UART_LCR = config->sc_lcr | LCR_DLAB;
    7860:	e3a07083 	mov	r7, #131	; 0x83
  u->UART_DLL = div;
    7864:	e3a06013 	mov	r6, #19
  u->UART_LCR = config->sc_lcr;
    7868:	e3a05003 	mov	r5, #3
  u->UART_FCR = FCR_ENABLE | FCR_RXRESET | FCR_TXRESET | config->sc_fcr;
    786c:	e3a0e007 	mov	lr, #7
  u->UART_FDR = 0x10;
    7870:	e3a0c010 	mov	ip, #16
  u->UART_TER = TER_ENABLE;
    7874:	e3a00080 	mov	r0, #128	; 0x80
  u->UART_IER = IER_RBR | IER_STATUS;
    7878:	e3a01005 	mov	r1, #5

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
    787c:	e3a02002 	mov	r2, #2
    7880:	e59f8520 	ldr	r8, [pc, #1312]	; 7da8 <__ram0_size__+0xc8>
    7884:	e5983074 	ldr	r3, [r8, #116]	; 0x74
  u->UART_LCR = config->sc_lcr | LCR_DLAB;
    7888:	e583700c 	str	r7, [r3, #12]
  u->UART_DLL = div;
    788c:	e5836000 	str	r6, [r3]
  u->UART_DLM = div >> 8;
    7890:	e5834004 	str	r4, [r3, #4]
  u->UART_LCR = config->sc_lcr;
    7894:	e583500c 	str	r5, [r3, #12]
  u->UART_FCR = FCR_ENABLE | FCR_RXRESET | FCR_TXRESET | config->sc_fcr;
    7898:	e583e008 	str	lr, [r3, #8]
  u->UART_ACR = 0;
    789c:	e5834020 	str	r4, [r3, #32]
  u->UART_FDR = 0x10;
    78a0:	e583c028 	str	ip, [r3, #40]	; 0x28
  u->UART_TER = TER_ENABLE;
    78a4:	e5830030 	str	r0, [r3, #48]	; 0x30
  u->UART_IER = IER_RBR | IER_STATUS;
    78a8:	e5831004 	str	r1, [r3, #4]
    78ac:	e5c82008 	strb	r2, [r8, #8]
  __asm volatile ("msr     CPSR_c, #0x1F" : : : "memory");
    78b0:	e321f01f 	msr	CPSR_c, #31
  sdStart(&SD1, NULL);

  /*
   * Creating blinkers threads.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
    78b4:	e59f3540 	ldr	r3, [pc, #1344]	; 7dfc <__ram0_size__+0x11c>
    78b8:	e3a02040 	mov	r2, #64	; 0x40
    78bc:	e3a01e13 	mov	r1, #304	; 0x130
    78c0:	e58d4000 	str	r4, [sp]
    78c4:	e59f0534 	ldr	r0, [pc, #1332]	; 7e00 <__ram0_size__+0x120>
    78c8:	ebffea48 	bl	21f0 <chThdCreateStatic>
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO, Thread2, NULL);
    78cc:	e58d4000 	str	r4, [sp]
    78d0:	e59f352c 	ldr	r3, [pc, #1324]	; 7e04 <__ram0_size__+0x124>
    78d4:	e3a02040 	mov	r2, #64	; 0x40
    78d8:	e3a01e13 	mov	r1, #304	; 0x130
    78dc:	e59f0524 	ldr	r0, [pc, #1316]	; 7e08 <__ram0_size__+0x128>
    78e0:	ebffea42 	bl	21f0 <chThdCreateStatic>
    78e4:	e59f7520 	ldr	r7, [pc, #1312]	; 7e0c <__ram0_size__+0x12c>
    78e8:	e59f8520 	ldr	r8, [pc, #1312]	; 7e10 <__ram0_size__+0x130>
    78ec:	e59fa520 	ldr	sl, [pc, #1312]	; 7e14 <__ram0_size__+0x134>
    78f0:	e59fb520 	ldr	fp, [pc, #1312]	; 7e18 <__ram0_size__+0x138>
    78f4:	ea000005 	b	7910 <main+0x2f0>
   * sleeping in a loop and check the buttons state and run test procedure.
   */
  while (true) {
    if (!palReadPad(IOPORT1, PA_BUTTON1))
      sdWrite(&SD1, (uint8_t *)"Hello World!\r\n", 14);
    if (!palReadPad(IOPORT1, PA_BUTTON2))
    78f8:	e59f34a0 	ldr	r3, [pc, #1184]	; 7da0 <__ram0_size__+0xc0>
    78fc:	e51330eb 	ldr	r3, [r3, #-235]	; 0xffffff15
    7900:	e3130801 	tst	r3, #65536	; 0x10000
    7904:	0a00000e 	beq	7944 <main+0x324>
      TestThread(&SD1);
    chThdSleepMilliseconds(500);
    7908:	e3a00f7d 	mov	r0, #500	; 0x1f4
    790c:	ebffeee3 	bl	34a0 <chThdSleep>
    if (!palReadPad(IOPORT1, PA_BUTTON1))
    7910:	e59f3488 	ldr	r3, [pc, #1160]	; 7da0 <__ram0_size__+0xc0>
    7914:	e51330eb 	ldr	r3, [r3, #-235]	; 0xffffff15
    7918:	e3130902 	tst	r3, #32768	; 0x8000
    791c:	1afffff5 	bne	78f8 <main+0x2d8>
      sdWrite(&SD1, (uint8_t *)"Hello World!\r\n", 14);
    7920:	e3e03000 	mvn	r3, #0
    7924:	e3a0200e 	mov	r2, #14
    7928:	e59f14ec 	ldr	r1, [pc, #1260]	; 7e1c <__ram0_size__+0x13c>
    792c:	e59f04ec 	ldr	r0, [pc, #1260]	; 7e20 <__ram0_size__+0x140>
    7930:	ebffee0e 	bl	3170 <chOQWriteTimeout>
    if (!palReadPad(IOPORT1, PA_BUTTON2))
    7934:	e59f3464 	ldr	r3, [pc, #1124]	; 7da0 <__ram0_size__+0xc0>
    7938:	e51330eb 	ldr	r3, [r3, #-235]	; 0xffffff15
    793c:	e3130801 	tst	r3, #65536	; 0x10000
    7940:	1afffff0 	bne	7908 <main+0x2e8>
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
  int i, j;

  chp = p;
    7944:	e59f345c 	ldr	r3, [pc, #1116]	; 7da8 <__ram0_size__+0xc8>
  test_println("");
    7948:	e59f04d4 	ldr	r0, [pc, #1236]	; 7e24 <__ram0_size__+0x144>
  chp = p;
    794c:	e5873000 	str	r3, [r7]
  test_println("");
    7950:	ebffe442 	bl	a60 <test_println>
  test_println("*** ChibiOS/RT test suite");
    7954:	e59f04cc 	ldr	r0, [pc, #1228]	; 7e28 <__ram0_size__+0x148>
    7958:	ebffe440 	bl	a60 <test_println>
  test_println("***");
    795c:	e59f04c8 	ldr	r0, [pc, #1224]	; 7e2c <__ram0_size__+0x14c>
    7960:	ebffe43e 	bl	a60 <test_println>
  while (*msgp)
    7964:	e3a0102a 	mov	r1, #42	; 0x2a
  test_println("***");
    7968:	e59f44c0 	ldr	r4, [pc, #1216]	; 7e30 <__ram0_size__+0x150>
    chSequentialStreamPut(chp, *msgp++);
    796c:	e5970000 	ldr	r0, [r7]
    7970:	e5903000 	ldr	r3, [r0]
    7974:	e5933008 	ldr	r3, [r3, #8]
    7978:	e1a0e00f 	mov	lr, pc
    797c:	e12fff13 	bx	r3
  while (*msgp)
    7980:	e5f41001 	ldrb	r1, [r4, #1]!
    7984:	e3510000 	cmp	r1, #0
    7988:	1afffff7 	bne	796c <main+0x34c>
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
    798c:	e59f04a0 	ldr	r0, [pc, #1184]	; 7e34 <__ram0_size__+0x154>
    7990:	ebffe432 	bl	a60 <test_println>
  while (*msgp)
    7994:	e3a0102a 	mov	r1, #42	; 0x2a
  test_println(CH_KERNEL_VERSION);
    7998:	e59f4498 	ldr	r4, [pc, #1176]	; 7e38 <__ram0_size__+0x158>
    chSequentialStreamPut(chp, *msgp++);
    799c:	e5970000 	ldr	r0, [r7]
    79a0:	e5903000 	ldr	r3, [r0]
    79a4:	e5933008 	ldr	r3, [r3, #8]
    79a8:	e1a0e00f 	mov	lr, pc
    79ac:	e12fff13 	bx	r3
  while (*msgp)
    79b0:	e5f41001 	ldrb	r1, [r4, #1]!
    79b4:	e3510000 	cmp	r1, #0
    79b8:	1afffff7 	bne	799c <main+0x37c>
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
    79bc:	e59f0478 	ldr	r0, [pc, #1144]	; 7e3c <__ram0_size__+0x15c>
    79c0:	ebffe426 	bl	a60 <test_println>
  while (*msgp)
    79c4:	e3a0102a 	mov	r1, #42	; 0x2a
  test_println(__DATE__ " - " __TIME__);
    79c8:	e59f4470 	ldr	r4, [pc, #1136]	; 7e40 <__ram0_size__+0x160>
    chSequentialStreamPut(chp, *msgp++);
    79cc:	e5970000 	ldr	r0, [r7]
    79d0:	e5903000 	ldr	r3, [r0]
    79d4:	e5933008 	ldr	r3, [r3, #8]
    79d8:	e1a0e00f 	mov	lr, pc
    79dc:	e12fff13 	bx	r3
  while (*msgp)
    79e0:	e5f41001 	ldrb	r1, [r4, #1]!
    79e4:	e3510000 	cmp	r1, #0
    79e8:	1afffff7 	bne	79cc <main+0x3ac>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
    79ec:	e59f0450 	ldr	r0, [pc, #1104]	; 7e44 <__ram0_size__+0x164>
    79f0:	ebffe41a 	bl	a60 <test_println>
  while (*msgp)
    79f4:	e3a0102a 	mov	r1, #42	; 0x2a
  test_println(PORT_COMPILER_NAME);
    79f8:	e59f4448 	ldr	r4, [pc, #1096]	; 7e48 <__ram0_size__+0x168>
    chSequentialStreamPut(chp, *msgp++);
    79fc:	e5970000 	ldr	r0, [r7]
    7a00:	e5903000 	ldr	r3, [r0]
    7a04:	e5933008 	ldr	r3, [r3, #8]
    7a08:	e1a0e00f 	mov	lr, pc
    7a0c:	e12fff13 	bx	r3
  while (*msgp)
    7a10:	e5f41001 	ldrb	r1, [r4, #1]!
    7a14:	e3510000 	cmp	r1, #0
    7a18:	1afffff7 	bne	79fc <main+0x3dc>
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
    7a1c:	e59f0428 	ldr	r0, [pc, #1064]	; 7e4c <__ram0_size__+0x16c>
    7a20:	ebffe40e 	bl	a60 <test_println>
  while (*msgp)
    7a24:	e3a0102a 	mov	r1, #42	; 0x2a
  test_println(PORT_ARCHITECTURE_NAME);
    7a28:	e59f4420 	ldr	r4, [pc, #1056]	; 7e50 <__ram0_size__+0x170>
    chSequentialStreamPut(chp, *msgp++);
    7a2c:	e5970000 	ldr	r0, [r7]
    7a30:	e5903000 	ldr	r3, [r0]
    7a34:	e5933008 	ldr	r3, [r3, #8]
    7a38:	e1a0e00f 	mov	lr, pc
    7a3c:	e12fff13 	bx	r3
  while (*msgp)
    7a40:	e5f41001 	ldrb	r1, [r4, #1]!
    7a44:	e3510000 	cmp	r1, #0
    7a48:	1afffff7 	bne	7a2c <main+0x40c>
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
    7a4c:	e59f0400 	ldr	r0, [pc, #1024]	; 7e54 <__ram0_size__+0x174>
    7a50:	ebffe402 	bl	a60 <test_println>
  while (*msgp)
    7a54:	e3a0102a 	mov	r1, #42	; 0x2a
  test_println(PORT_CORE_VARIANT_NAME);
    7a58:	e59f43f8 	ldr	r4, [pc, #1016]	; 7e58 <__ram0_size__+0x178>
    chSequentialStreamPut(chp, *msgp++);
    7a5c:	e5970000 	ldr	r0, [r7]
    7a60:	e5903000 	ldr	r3, [r0]
    7a64:	e5933008 	ldr	r3, [r3, #8]
    7a68:	e1a0e00f 	mov	lr, pc
    7a6c:	e12fff13 	bx	r3
  while (*msgp)
    7a70:	e5f41001 	ldrb	r1, [r4, #1]!
    7a74:	e3510000 	cmp	r1, #0
    7a78:	1afffff7 	bne	7a5c <main+0x43c>
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
    7a7c:	e59f03d8 	ldr	r0, [pc, #984]	; 7e5c <__ram0_size__+0x17c>
    7a80:	ebffe3f6 	bl	a60 <test_println>
  while (*msgp)
    7a84:	e3a0102a 	mov	r1, #42	; 0x2a
  test_println(PORT_INFO);
    7a88:	e59f43d0 	ldr	r4, [pc, #976]	; 7e60 <__ram0_size__+0x180>
    chSequentialStreamPut(chp, *msgp++);
    7a8c:	e5970000 	ldr	r0, [r7]
    7a90:	e5903000 	ldr	r3, [r0]
    7a94:	e5933008 	ldr	r3, [r3, #8]
    7a98:	e1a0e00f 	mov	lr, pc
    7a9c:	e12fff13 	bx	r3
  while (*msgp)
    7aa0:	e5f41001 	ldrb	r1, [r4, #1]!
    7aa4:	e3510000 	cmp	r1, #0
    7aa8:	1afffff7 	bne	7a8c <main+0x46c>
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
    7aac:	e59f03b0 	ldr	r0, [pc, #944]	; 7e64 <__ram0_size__+0x184>
    7ab0:	ebffe3ea 	bl	a60 <test_println>
  while (*msgp)
    7ab4:	e3a0102a 	mov	r1, #42	; 0x2a
  test_println(PLATFORM_NAME);
    7ab8:	e59f43a8 	ldr	r4, [pc, #936]	; 7e68 <__ram0_size__+0x188>
    chSequentialStreamPut(chp, *msgp++);
    7abc:	e5970000 	ldr	r0, [r7]
    7ac0:	e5903000 	ldr	r3, [r0]
    7ac4:	e5933008 	ldr	r3, [r3, #8]
    7ac8:	e1a0e00f 	mov	lr, pc
    7acc:	e12fff13 	bx	r3
  while (*msgp)
    7ad0:	e5f41001 	ldrb	r1, [r4, #1]!
    7ad4:	e3510000 	cmp	r1, #0
    7ad8:	1afffff7 	bne	7abc <main+0x49c>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
    7adc:	e59f0388 	ldr	r0, [pc, #904]	; 7e6c <__ram0_size__+0x18c>
    7ae0:	e58d100c 	str	r1, [sp, #12]
    7ae4:	ebffe3dd 	bl	a60 <test_println>
#endif
  test_println("");
    7ae8:	e59f0334 	ldr	r0, [pc, #820]	; 7e24 <__ram0_size__+0x144>
    7aec:	ebffe3db 	bl	a60 <test_println>

  test_global_fail = FALSE;
    7af0:	e59f3378 	ldr	r3, [pc, #888]	; 7e70 <__ram0_size__+0x190>
  i = 0;
    7af4:	e59d100c 	ldr	r1, [sp, #12]
  test_global_fail = FALSE;
    7af8:	e5c31000 	strb	r1, [r3]
    7afc:	e59f3370 	ldr	r3, [pc, #880]	; 7e74 <__ram0_size__+0x194>
    7b00:	e58d3014 	str	r3, [sp, #20]
    7b04:	e59f336c 	ldr	r3, [pc, #876]	; 7e78 <__ram0_size__+0x198>
    7b08:	e59f536c 	ldr	r5, [pc, #876]	; 7e7c <__ram0_size__+0x19c>
    7b0c:	e58d3010 	str	r3, [sp, #16]
    7b10:	e59f3368 	ldr	r3, [pc, #872]	; 7e80 <__ram0_size__+0x1a0>
    7b14:	e59d200c 	ldr	r2, [sp, #12]
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
    7b18:	e3530000 	cmp	r3, #0
    7b1c:	e2822001 	add	r2, r2, #1
    7b20:	e58d200c 	str	r2, [sp, #12]
  char *cp = tokens_buffer;
    7b24:	e3a04000 	mov	r4, #0
    while (patterns[i][j]) {
    7b28:	0a000075 	beq	7d04 <__ram0_size__+0x24>
      print_line();
    7b2c:	ebffe31f 	bl	7b0 <print_line>
  while (*msgp)
    7b30:	e3a0102d 	mov	r1, #45	; 0x2d
      print_line();
    7b34:	e59f6348 	ldr	r6, [pc, #840]	; 7e84 <__ram0_size__+0x1a4>
    chSequentialStreamPut(chp, *msgp++);
    7b38:	e5970000 	ldr	r0, [r7]
    7b3c:	e5903000 	ldr	r3, [r0]
    7b40:	e5933008 	ldr	r3, [r3, #8]
    7b44:	e1a0e00f 	mov	lr, pc
    7b48:	e12fff13 	bx	r3
  while (*msgp)
    7b4c:	e5f61001 	ldrb	r1, [r6, #1]!
    7b50:	e3510000 	cmp	r1, #0
    7b54:	1afffff7 	bne	7b38 <main+0x518>
      test_print("--- Test Case ");
      test_printn(i + 1);
    7b58:	e59d000c 	ldr	r0, [sp, #12]
    7b5c:	ebffe307 	bl	780 <test_printn>
    chSequentialStreamPut(chp, *msgp++);
    7b60:	e5970000 	ldr	r0, [r7]
    7b64:	e5903000 	ldr	r3, [r0]
    7b68:	e3a0102e 	mov	r1, #46	; 0x2e
    7b6c:	e5933008 	ldr	r3, [r3, #8]
    7b70:	e2846001 	add	r6, r4, #1
    7b74:	e1a0e00f 	mov	lr, pc
    7b78:	e12fff13 	bx	r3
      test_print(".");
      test_printn(j + 1);
    7b7c:	e1a00006 	mov	r0, r6
    7b80:	ebffe2fe 	bl	780 <test_printn>
  while (*msgp)
    7b84:	e3a01020 	mov	r1, #32
      test_printn(j + 1);
    7b88:	e59f92f8 	ldr	r9, [pc, #760]	; 7e88 <__ram0_size__+0x1a8>
    chSequentialStreamPut(chp, *msgp++);
    7b8c:	e5970000 	ldr	r0, [r7]
    7b90:	e5903000 	ldr	r3, [r0]
    7b94:	e5933008 	ldr	r3, [r3, #8]
    7b98:	e1a0e00f 	mov	lr, pc
    7b9c:	e12fff13 	bx	r3
  while (*msgp)
    7ba0:	e5f91001 	ldrb	r1, [r9, #1]!
    7ba4:	e3510000 	cmp	r1, #0
    7ba8:	1afffff7 	bne	7b8c <main+0x56c>
      test_print(" (");
      test_print(patterns[i][j]->name);
    7bac:	e7953104 	ldr	r3, [r5, r4, lsl #2]
    7bb0:	e5939000 	ldr	r9, [r3]
  while (*msgp)
    7bb4:	e5d91000 	ldrb	r1, [r9]
    7bb8:	e3510000 	cmp	r1, #0
    7bbc:	0a000007 	beq	7be0 <main+0x5c0>
    chSequentialStreamPut(chp, *msgp++);
    7bc0:	e5970000 	ldr	r0, [r7]
    7bc4:	e5903000 	ldr	r3, [r0]
    7bc8:	e5933008 	ldr	r3, [r3, #8]
    7bcc:	e1a0e00f 	mov	lr, pc
    7bd0:	e12fff13 	bx	r3
  while (*msgp)
    7bd4:	e5f91001 	ldrb	r1, [r9, #1]!
    7bd8:	e3510000 	cmp	r1, #0
    7bdc:	1afffff7 	bne	7bc0 <main+0x5a0>
      test_println(")");
    7be0:	e59f02a4 	ldr	r0, [pc, #676]	; 7e8c <__ram0_size__+0x1ac>
    7be4:	ebffe39d 	bl	a60 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
    7be8:	e3a000c8 	mov	r0, #200	; 0xc8
    7bec:	ebffee2b 	bl	34a0 <chThdSleep>
  local_fail = FALSE;
    7bf0:	e3a03000 	mov	r3, #0
#endif
      execute_test(patterns[i][j]);
    7bf4:	e7959104 	ldr	r9, [r5, r4, lsl #2]
    threads[i] = NULL;
    7bf8:	e58b3000 	str	r3, [fp]
    7bfc:	e58b3004 	str	r3, [fp, #4]
    7c00:	e58b3008 	str	r3, [fp, #8]
    7c04:	e58b300c 	str	r3, [fp, #12]
    7c08:	e58b3010 	str	r3, [fp, #16]
  if (tcp->setup != NULL)
    7c0c:	e5991004 	ldr	r1, [r9, #4]
  tokp = tokens_buffer;
    7c10:	e59f2278 	ldr	r2, [pc, #632]	; 7e90 <__ram0_size__+0x1b0>
  if (tcp->setup != NULL)
    7c14:	e1510003 	cmp	r1, r3
  tokp = tokens_buffer;
    7c18:	e5882000 	str	r2, [r8]
  local_fail = FALSE;
    7c1c:	e5ca3000 	strb	r3, [sl]
    tcp->setup();
    7c20:	11a0e00f 	movne	lr, pc
    7c24:	112fff11 	bxne	r1
  tcp->execute();
    7c28:	e599300c 	ldr	r3, [r9, #12]
    7c2c:	e1a0e00f 	mov	lr, pc
    7c30:	e12fff13 	bx	r3
  if (tcp->teardown != NULL)
    7c34:	e5993008 	ldr	r3, [r9, #8]
    7c38:	e3530000 	cmp	r3, #0
    tcp->teardown();
    7c3c:	11a0e00f 	movne	lr, pc
    7c40:	112fff13 	bxne	r3
  test_wait_threads();
    7c44:	ebfff54d 	bl	5180 <test_wait_threads>
      if (local_fail) {
    7c48:	e5da3000 	ldrb	r3, [sl]
    7c4c:	e3530000 	cmp	r3, #0
    7c50:	0a000034 	beq	7d28 <__ram0_size__+0x48>
  while (*msgp)
    7c54:	e3a0102d 	mov	r1, #45	; 0x2d
      if (local_fail) {
    7c58:	e59f9234 	ldr	r9, [pc, #564]	; 7e94 <__ram0_size__+0x1b4>
    chSequentialStreamPut(chp, *msgp++);
    7c5c:	e5970000 	ldr	r0, [r7]
    7c60:	e5903000 	ldr	r3, [r0]
    7c64:	e5933008 	ldr	r3, [r3, #8]
    7c68:	e1a0e00f 	mov	lr, pc
    7c6c:	e12fff13 	bx	r3
  while (*msgp)
    7c70:	e5f91001 	ldrb	r1, [r9, #1]!
    7c74:	e3510000 	cmp	r1, #0
    7c78:	1afffff7 	bne	7c5c <main+0x63c>
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
    7c7c:	e59f3214 	ldr	r3, [pc, #532]	; 7e98 <__ram0_size__+0x1b8>
    7c80:	e5930000 	ldr	r0, [r3]
    7c84:	ebffe2bd 	bl	780 <test_printn>
  while (*msgp)
    7c88:	e3a01020 	mov	r1, #32
        test_printn(failpoint);
    7c8c:	e59f9208 	ldr	r9, [pc, #520]	; 7e9c <__ram0_size__+0x1bc>
    chSequentialStreamPut(chp, *msgp++);
    7c90:	e5970000 	ldr	r0, [r7]
    7c94:	e5903000 	ldr	r3, [r0]
    7c98:	e5933008 	ldr	r3, [r3, #8]
    7c9c:	e1a0e00f 	mov	lr, pc
    7ca0:	e12fff13 	bx	r3
  while (*msgp)
    7ca4:	e5f91001 	ldrb	r1, [r9, #1]!
    7ca8:	e3510000 	cmp	r1, #0
    7cac:	1afffff7 	bne	7c90 <main+0x670>
  while (cp < tokp)
    7cb0:	e5983000 	ldr	r3, [r8]
    7cb4:	e59f21d4 	ldr	r2, [pc, #468]	; 7e90 <__ram0_size__+0x1b0>
    7cb8:	e1530002 	cmp	r3, r2
    7cbc:	9a000009 	bls	7ce8 <__ram0_size__+0x8>
  char *cp = tokens_buffer;
    7cc0:	e1a09002 	mov	r9, r2
    chSequentialStreamPut(chp, *cp++);
    7cc4:	e5970000 	ldr	r0, [r7]
    7cc8:	e5903000 	ldr	r3, [r0]
    7ccc:	e4d91001 	ldrb	r1, [r9], #1
    7cd0:	e5933008 	ldr	r3, [r3, #8]
    7cd4:	e1a0e00f 	mov	lr, pc
    7cd8:	e12fff13 	bx	r3
  while (cp < tokp)
    7cdc:	e5983000 	ldr	r3, [r8]
    7ce0:	e1590003 	cmp	r9, r3
    7ce4:	3afffff6 	bcc	7cc4 <main+0x6a4>
        test_print(" [");
        print_tokens();
        test_println("])");
    7ce8:	e59f01b0 	ldr	r0, [pc, #432]	; 7ea0 <__ram0_size__+0x1c0>
    7cec:	ebffe35b 	bl	a60 <test_println>
    7cf0:	e0853104 	add	r3, r5, r4, lsl #2
    7cf4:	e5933004 	ldr	r3, [r3, #4]
    while (patterns[i][j]) {
    7cf8:	e3530000 	cmp	r3, #0
  char *cp = tokens_buffer;
    7cfc:	e1a04006 	mov	r4, r6
    while (patterns[i][j]) {
    7d00:	1affff89 	bne	7b2c <main+0x50c>
  while (patterns[i]) {
    7d04:	e59d5010 	ldr	r5, [sp, #16]
    7d08:	e3550000 	cmp	r5, #0
    7d0c:	0a000008 	beq	7d34 <__ram0_size__+0x54>
      }
      else
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
    7d10:	e59d2014 	ldr	r2, [sp, #20]
    7d14:	e4921004 	ldr	r1, [r2], #4
    7d18:	e5953000 	ldr	r3, [r5]
    7d1c:	e58d1010 	str	r1, [sp, #16]
    7d20:	e58d2014 	str	r2, [sp, #20]
    7d24:	eaffff7a 	b	7b14 <main+0x4f4>
        test_println("--- Result: SUCCESS");
    7d28:	e59f0174 	ldr	r0, [pc, #372]	; 7ea4 <__ram0_size__+0x1c4>
    7d2c:	ebffe34b 	bl	a60 <test_println>
    7d30:	eaffffee 	b	7cf0 <__ram0_size__+0x10>
  }
  print_line();
    7d34:	ebffe29d 	bl	7b0 <print_line>
  test_println("");
    7d38:	e59f00e4 	ldr	r0, [pc, #228]	; 7e24 <__ram0_size__+0x144>
    7d3c:	ebffe347 	bl	a60 <test_println>
  while (*msgp)
    7d40:	e3a01046 	mov	r1, #70	; 0x46
  test_println("");
    7d44:	e59f415c 	ldr	r4, [pc, #348]	; 7ea8 <__ram0_size__+0x1c8>
    chSequentialStreamPut(chp, *msgp++);
    7d48:	e5970000 	ldr	r0, [r7]
    7d4c:	e5903000 	ldr	r3, [r0]
    7d50:	e5933008 	ldr	r3, [r3, #8]
    7d54:	e1a0e00f 	mov	lr, pc
    7d58:	e12fff13 	bx	r3
  while (*msgp)
    7d5c:	e5f41001 	ldrb	r1, [r4, #1]!
    7d60:	e3510000 	cmp	r1, #0
    7d64:	1afffff7 	bne	7d48 <__ram0_size__+0x68>
  test_print("Final result: ");
  if (test_global_fail)
    7d68:	e59f3100 	ldr	r3, [pc, #256]	; 7e70 <__ram0_size__+0x190>
    7d6c:	e5d33000 	ldrb	r3, [r3]
    7d70:	e3530000 	cmp	r3, #0
    test_println("FAILURE");
    7d74:	159f0130 	ldrne	r0, [pc, #304]	; 7eac <__ram0_size__+0x1cc>
  else
    test_println("SUCCESS");
    7d78:	059f0130 	ldreq	r0, [pc, #304]	; 7eb0 <__ram0_size__+0x1d0>
    7d7c:	ebffe337 	bl	a60 <test_println>
    7d80:	eafffee0 	b	7908 <main+0x2e8>
    7d84:	007ffffd 	.word	0x007ffffd
    7d88:	e002c000 	.word	0xe002c000
    7d8c:	00055555 	.word	0x00055555
    7d90:	00000ef0 	.word	0x00000ef0
    7d94:	e01fc000 	.word	0xe01fc000
    7d98:	100840a8 	.word	0x100840a8
    7d9c:	b0703c00 	.word	0xb0703c00
    7da0:	3fffc0ff 	.word	0x3fffc0ff
    7da4:	01ff0000 	.word	0x01ff0000
    7da8:	40000b10 	.word	0x40000b10
    7dac:	00001270 	.word	0x00001270
    7db0:	000013c0 	.word	0x000013c0
    7db4:	40000b88 	.word	0x40000b88
    7db8:	e000c000 	.word	0xe000c000
    7dbc:	00001280 	.word	0x00001280
    7dc0:	000013f0 	.word	0x000013f0
    7dc4:	00000e50 	.word	0x00000e50
    7dc8:	00002ee0 	.word	0x00002ee0
    7dcc:	40000c00 	.word	0x40000c00
    7dd0:	e0004000 	.word	0xe0004000
    7dd4:	400016e7 	.word	0x400016e7
    7dd8:	40000dec 	.word	0x40000dec
    7ddc:	40007ee0 	.word	0x40007ee0
    7de0:	40000d70 	.word	0x40000d70
    7de4:	40000d50 	.word	0x40000d50
    7de8:	000002a0 	.word	0x000002a0
    7dec:	00008160 	.word	0x00008160
    7df0:	00000290 	.word	0x00000290
    7df4:	000082b0 	.word	0x000082b0
    7df8:	801817b6 	.word	0x801817b6
    7dfc:	000034c0 	.word	0x000034c0
    7e00:	40001480 	.word	0x40001480
    7e04:	00003530 	.word	0x00003530
    7e08:	400015b0 	.word	0x400015b0
    7e0c:	40000d48 	.word	0x40000d48
    7e10:	40001440 	.word	0x40001440
    7e14:	40000dcc 	.word	0x40000dcc
    7e18:	4000141c 	.word	0x4000141c
    7e1c:	000082b8 	.word	0x000082b8
    7e20:	40000b40 	.word	0x40000b40
    7e24:	00008130 	.word	0x00008130
    7e28:	000082c8 	.word	0x000082c8
    7e2c:	000082e4 	.word	0x000082e4
    7e30:	000081d0 	.word	0x000081d0
    7e34:	000082e8 	.word	0x000082e8
    7e38:	000081e4 	.word	0x000081e4
    7e3c:	000082f0 	.word	0x000082f0
    7e40:	000081f8 	.word	0x000081f8
    7e44:	00008308 	.word	0x00008308
    7e48:	0000820c 	.word	0x0000820c
    7e4c:	00008350 	.word	0x00008350
    7e50:	00008220 	.word	0x00008220
    7e54:	00008358 	.word	0x00008358
    7e58:	00008234 	.word	0x00008234
    7e5c:	00008360 	.word	0x00008360
    7e60:	00008248 	.word	0x00008248
    7e64:	00008370 	.word	0x00008370
    7e68:	0000825c 	.word	0x0000825c
    7e6c:	00008378 	.word	0x00008378
    7e70:	400013f0 	.word	0x400013f0
    7e74:	000084a8 	.word	0x000084a8
    7e78:	00008510 	.word	0x00008510
    7e7c:	00008500 	.word	0x00008500
    7e80:	00008cc0 	.word	0x00008cc0
    7e84:	00008270 	.word	0x00008270
    7e88:	00008280 	.word	0x00008280
    7e8c:	0000838c 	.word	0x0000838c
    7e90:	40001430 	.word	0x40001430
    7e94:	00008284 	.word	0x00008284
    7e98:	40000d74 	.word	0x40000d74
    7e9c:	0000829c 	.word	0x0000829c
    7ea0:	00008390 	.word	0x00008390
    7ea4:	00008394 	.word	0x00008394
    7ea8:	000082a0 	.word	0x000082a0
    7eac:	000083a8 	.word	0x000083a8
    7eb0:	000083a0 	.word	0x000083a0
	...

00007ec0 <__early_init>:
void __early_init(void) {
    7ec0:	e92d4070 	push	{r4, r5, r6, lr}
void lpc214x_clock_init(void) {

  /*
   * All peripherals clock disabled by default in order to save power.
   */
  PCONP = PCRTC | PCTIM0;
    7ec4:	e59f3068 	ldr	r3, [pc, #104]	; 7f34 <__early_init+0x74>

  /*
   * MAM setup.
   */
  MAMTIM = 0x3;                 /* 3 cycles for flash accesses. */
    7ec8:	e3a05003 	mov	r5, #3
  MAMCR  = 0x2;                 /* MAM fully enabled. */
    7ecc:	e3a04002 	mov	r4, #2
  /*
   * PLL setup for Fosc=12MHz and CCLK=48MHz.
   * P=2 M=3.
   */
  PLL *pll = PLL0Base;
  pll->PLL_CFG  = 0x23;         /* P and M values. */
    7ed0:	e3a0e023 	mov	lr, #35	; 0x23
  pll->PLL_CON  = 0x1;          /* Enables the PLL 0. */
    7ed4:	e3a0c001 	mov	ip, #1
  pll->PLL_FEED = 0xAA;
    7ed8:	e3a000aa 	mov	r0, #170	; 0xaa
  pll->PLL_FEED = 0x55;
    7edc:	e3a01055 	mov	r1, #85	; 0x55
  while (!(pll->PLL_STAT & 0x400))
    7ee0:	e1a02003 	mov	r2, r3
  PCONP = PCRTC | PCTIM0;
    7ee4:	e59f604c 	ldr	r6, [pc, #76]	; 7f38 <__early_init+0x78>
    7ee8:	e58360c4 	str	r6, [r3, #196]	; 0xc4
  MAMTIM = 0x3;                 /* 3 cycles for flash accesses. */
    7eec:	e5835004 	str	r5, [r3, #4]
  MAMCR  = 0x2;                 /* MAM fully enabled. */
    7ef0:	e5834000 	str	r4, [r3]
  pll->PLL_CFG  = 0x23;         /* P and M values. */
    7ef4:	e583e084 	str	lr, [r3, #132]	; 0x84
  pll->PLL_CON  = 0x1;          /* Enables the PLL 0. */
    7ef8:	e583c080 	str	ip, [r3, #128]	; 0x80
  pll->PLL_FEED = 0xAA;
    7efc:	e583008c 	str	r0, [r3, #140]	; 0x8c
  pll->PLL_FEED = 0x55;
    7f00:	e583108c 	str	r1, [r3, #140]	; 0x8c
  while (!(pll->PLL_STAT & 0x400))
    7f04:	e5923088 	ldr	r3, [r2, #136]	; 0x88
    7f08:	e3130b01 	tst	r3, #1024	; 0x400
    7f0c:	0afffffc 	beq	7f04 <__early_init+0x44>
    ;                           /* Wait for PLL lock. */

  pll->PLL_CON  = 0x3;          /* Connects the PLL. */
    7f10:	e3a0c003 	mov	ip, #3
  pll->PLL_FEED = 0xAA;
    7f14:	e3a000aa 	mov	r0, #170	; 0xaa
  pll->PLL_FEED = 0x55;
    7f18:	e3a01055 	mov	r1, #85	; 0x55

  /*
   * VPB setup.
   * PCLK = CCLK / 4.
   */
  VPBDIV = VPD_D4;
    7f1c:	e3a03000 	mov	r3, #0
  pll->PLL_CON  = 0x3;          /* Connects the PLL. */
    7f20:	e582c080 	str	ip, [r2, #128]	; 0x80
  pll->PLL_FEED = 0xAA;
    7f24:	e582008c 	str	r0, [r2, #140]	; 0x8c
  pll->PLL_FEED = 0x55;
    7f28:	e582108c 	str	r1, [r2, #140]	; 0x8c
  VPBDIV = VPD_D4;
    7f2c:	e5823100 	str	r3, [r2, #256]	; 0x100
}
    7f30:	e8bd8070 	pop	{r4, r5, r6, pc}
    7f34:	e01fc000 	.word	0xe01fc000
    7f38:	00000202 	.word	0x00000202
    7f3c:	00000000 	.word	0x00000000

00007f40 <chThdExit>:
void chThdExit(msg_t msg) {
    7f40:	e92d4070 	push	{r4, r5, r6, lr}
    7f44:	e1a03000 	mov	r3, r0
  __asm volatile ("msr     CPSR_c, #0x9F" : : : "memory");
    7f48:	e321f09f 	msr	CPSR_c, #159	; 0x9f
  thread_t *tp = currp;
    7f4c:	e59f2054 	ldr	r2, [pc, #84]	; 7fa8 <chThdExit+0x68>
    7f50:	e5924018 	ldr	r4, [r2, #24]
  return (bool)(tlp->p_next != (thread_t *)tlp);
    7f54:	e5940028 	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->p_waiting)) {
    7f58:	e2845028 	add	r5, r4, #40	; 0x28
    7f5c:	e1500005 	cmp	r0, r5
  tp->p_u.exitcode = msg;
    7f60:	e5843024 	str	r3, [r4, #36]	; 0x24
  while (list_notempty(&tp->p_waiting)) {
    7f64:	0a000005 	beq	7f80 <chThdExit+0x40>
  tlp->p_next = tp->p_next;
    7f68:	e5903000 	ldr	r3, [r0]
    7f6c:	e5843028 	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->p_waiting));
    7f70:	ebffe40e 	bl	fb0 <chSchReadyI>
  return (bool)(tlp->p_next != (thread_t *)tlp);
    7f74:	e5940028 	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->p_waiting)) {
    7f78:	e1500005 	cmp	r0, r5
    7f7c:	1afffff9 	bne	7f68 <chThdExit+0x28>
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    7f80:	e5d4301d 	ldrb	r3, [r4, #29]
    7f84:	e3130003 	tst	r3, #3
    REG_REMOVE(tp);
    7f88:	02842010 	addeq	r2, r4, #16
    7f8c:	0892000c 	ldmeq	r2, {r2, r3}
    7f90:	05832010 	streq	r2, [r3, #16]
    7f94:	05942010 	ldreq	r2, [r4, #16]
  chSchGoSleepS(CH_STATE_FINAL);
    7f98:	e3a0000f 	mov	r0, #15
    REG_REMOVE(tp);
    7f9c:	05823014 	streq	r3, [r2, #20]
}
    7fa0:	e8bd4070 	pop	{r4, r5, r6, lr}
  chSchGoSleepS(CH_STATE_FINAL);
    7fa4:	eaffe8b9 	b	2290 <chSchGoSleepS>
    7fa8:	40000c00 	.word	0x40000c00
    7fac:	00000000 	.word	0x00000000

00007fb0 <thread1.lto_priv.66>:
  chThdExit((msg_t)p);
    7fb0:	eaffffe2 	b	7f40 <chThdExit>
	...

00007fc0 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
    7fc0:	eaffe6ea 	b	1b70 <chSchDoRescheduleAhead>
	...

00007fd0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
    7fd0:	eafffffe 	b	7fd0 <__default_exit>
	...

00007fe0 <__late_init>:
void __late_init(void) {}
    7fe0:	e12fff1e 	bx	lr
	...
    7ff0:	6e696c62 	.word	0x6e696c62
    7ff4:	3172656b 	.word	0x3172656b
	...
    8000:	6e696c62 	.word	0x6e696c62
    8004:	3272656b 	.word	0x3272656b
	...
    8010:	202d2d2d 	.word	0x202d2d2d
    8014:	726f6353 	.word	0x726f6353
    8018:	203a2065 	.word	0x203a2065
    801c:	00000000 	.word	0x00000000
    8020:	6d697420 	.word	0x6d697420
    8024:	2f737265 	.word	0x2f737265
    8028:	00000053 	.word	0x00000053
    802c:	00000000 	.word	0x00000000
    8030:	69617720 	.word	0x69617720
    8034:	69732b74 	.word	0x69732b74
    8038:	6c616e67 	.word	0x6c616e67
    803c:	0000532f 	.word	0x0000532f
    8040:	636f6c20 	.word	0x636f6c20
    8044:	6e752b6b 	.word	0x6e752b6b
    8048:	6b636f6c 	.word	0x6b636f6c
    804c:	0000532f 	.word	0x0000532f
    8050:	202d2d2d 	.word	0x202d2d2d
    8054:	74737953 	.word	0x74737953
    8058:	203a6d65 	.word	0x203a6d65
    805c:	00000000 	.word	0x00000000
    8060:	74796220 	.word	0x74796220
    8064:	00007365 	.word	0x00007365
    8068:	202d2d2d 	.word	0x202d2d2d
    806c:	65726854 	.word	0x65726854
    8070:	203a6461 	.word	0x203a6461
    8074:	00000000 	.word	0x00000000
    8078:	202d2d2d 	.word	0x202d2d2d
    807c:	656d6954 	.word	0x656d6954
    8080:	203a2072 	.word	0x203a2072
    8084:	00000000 	.word	0x00000000
    8088:	202d2d2d 	.word	0x202d2d2d
    808c:	616d6553 	.word	0x616d6553
    8090:	203a6870 	.word	0x203a6870
    8094:	00000000 	.word	0x00000000
    8098:	202d2d2d 	.word	0x202d2d2d
    809c:	6e657645 	.word	0x6e657645
    80a0:	203a5374 	.word	0x203a5374
    80a4:	00000000 	.word	0x00000000
    80a8:	202d2d2d 	.word	0x202d2d2d
    80ac:	6e657645 	.word	0x6e657645
    80b0:	203a4c74 	.word	0x203a4c74
    80b4:	00000000 	.word	0x00000000
    80b8:	202d2d2d 	.word	0x202d2d2d
    80bc:	6574754d 	.word	0x6574754d
    80c0:	203a2078 	.word	0x203a2078
    80c4:	00000000 	.word	0x00000000
    80c8:	202d2d2d 	.word	0x202d2d2d
    80cc:	646e6f43 	.word	0x646e6f43
    80d0:	203a2e56 	.word	0x203a2e56
    80d4:	00000000 	.word	0x00000000
    80d8:	202d2d2d 	.word	0x202d2d2d
    80dc:	75657551 	.word	0x75657551
    80e0:	203a2065 	.word	0x203a2065
    80e4:	00000000 	.word	0x00000000
    80e8:	202d2d2d 	.word	0x202d2d2d
    80ec:	6c69614d 	.word	0x6c69614d
    80f0:	203a2e42 	.word	0x203a2e42
	...
    8100:	67736d20 	.word	0x67736d20
    8104:	2c532f73 	.word	0x2c532f73
    8108:	00000020 	.word	0x00000020
    810c:	00000000 	.word	0x00000000
    8110:	72687420 	.word	0x72687420
    8114:	73646165 	.word	0x73646165
    8118:	0000532f 	.word	0x0000532f
    811c:	00000000 	.word	0x00000000
    8120:	73657220 	.word	0x73657220
    8124:	64656863 	.word	0x64656863
    8128:	73656c75 	.word	0x73656c75
    812c:	202c532f 	.word	0x202c532f
	...
    8140:	78746320 	.word	0x78746320
    8144:	2f637773 	.word	0x2f637773
    8148:	00000053 	.word	0x00000053
    814c:	00000000 	.word	0x00000000
    8150:	74796220 	.word	0x74796220
    8154:	532f7365 	.word	0x532f7365
	...

00008160 <ch_debug>:
    8160:	6e69616d 18011600 08480404 1814100c     main......H.....
    8170:	1e1d1c00 00002000 00000000 00000000     ..... ..........
    8180:	00004241 00000000 00000000 00000000     AB..............
    8190:	00000042 00000043 00000044 00000000     B...C...D.......
    81a0:	00000041 00000000 00000000 00000000     A...............

000081b0 <evhndl>:
    81b0:	00000a30 00000a20 00000a10 00000000     0... ...........
    81c0:	00434241 00000000 00000000 00000000     ABC.............
    81d0:	202a2a2a 6e72654b 203a6c65 20202020     *** Kernel:     
    81e0:	00002020 202a2a2a 706d6f43 64656c69       ..*** Compiled
    81f0:	2020203a 00002020 202a2a2a 706d6f43     :     ..*** Comp
    8200:	72656c69 2020203a 00002020 202a2a2a     iler:     ..*** 
    8210:	68637241 63657469 65727574 0000203a     Architecture: ..
    8220:	202a2a2a 65726f43 72615620 746e6169     *** Core Variant
    8230:	0000203a 202a2a2a 74726f50 666e4920     : ..*** Port Inf
    8240:	20203a6f 00002020 202a2a2a 74616c50     o:    ..*** Plat
    8250:	6d726f66 2020203a 00002020 202a2a2a     form:     ..*** 
    8260:	74736554 616f4220 203a6472 00002020     Test Board:   ..
    8270:	202d2d2d 74736554 73614320 00002065     --- Test Case ..
    8280:	00002820 202d2d2d 75736552 203a746c      (..--- Result: 
    8290:	4c494146 20455255 00002328 00005b20     FAILURE (#.. [..
    82a0:	616e6946 6572206c 746c7573 0000203a     Final result: ..
    82b0:	656c6469 00000000 6c6c6548 6f57206f     idle....Hello Wo
    82c0:	21646c72 00000a0d 202a2a2a 62696843     rld!....*** Chib
    82d0:	2f534f69 74205452 20747365 74697573     iOS/RT test suit
    82e0:	00000065 002a2a2a 2e302e33 00000030     e...***.3.0.0...
    82f0:	20727041 32203620 20383130 3631202d     Apr  6 2018 - 16
    8300:	3a30303a 00003232 20434347 2e322e37     :00:22..GCC 7.2.
    8310:	30322031 39303731 28203430 656c6572     1 20170904 (rele
    8320:	29657361 52415b20 6d652f4d 64646562     ase) [ARM/embedd
    8330:	372d6465 6172622d 2068636e 69766572     ed-7-branch revi
    8340:	6e6f6973 35353220 5d343032 00000000     sion 255204]....
    8350:	764d5241 00005434 374d5241 00000000     ARMv4T..ARM7....
    8360:	65727550 55485420 6d20424d 0065646f     Pure THUMB mode.
    8370:	3243504c 00783431 6d696c4f 4c207865     LPC214x.Olimex L
    8380:	502d4350 38343132 00000000 00000029     PC-P2148....)...
    8390:	0000295d 202d2d2d 75736552 203a746c     ])..--- Result: 
    83a0:	43435553 00535345 4c494146 00455255     SUCCESS.FAILURE.
    83b0:	44434241 00000045 00000000 00000000     ABCDE...........

000083c0 <patternbmk>:
    83c0:	00008a70 00008ac0 00008ad0 00008ae0     p...............
    83d0:	00008af0 00008b00 00008b10 00008b20     ............ ...
    83e0:	00008b30 00008a80 00008a90 00008aa0     0...............
    83f0:	00008ab0 00000000 00000000 00000000     ................

00008400 <patterndyn>:
    8400:	00008b40 00008b50 00008b60 00000000     @...P...`.......

00008410 <patternevt>:
    8410:	00008b70 00008b80 00008b90 00000000     p...............

00008420 <patternheap>:
    8420:	00008ba0 00000000 00000000 00000000     ................

00008430 <patternmbox>:
    8430:	00008bb0 00000000 00000000 00000000     ................

00008440 <patternmsg>:
    8440:	00008bc0 00000000 00000000 00000000     ................

00008450 <patternmtx>:
    8450:	00008bd0 00008be0 00008bf0 00008c00     ................
    8460:	00008c10 00008c20 00008c30 00008c40     .... ...0...@...
	...

00008480 <patternpools>:
    8480:	00008c50 00000000 00000000 00000000     P...............

00008490 <patternqueues>:
    8490:	00008c60 00008c70 00000000 00000000     `...p...........

000084a0 <patterns>:
    84a0:	00008500 00008510 000084e0 00008450     ............P...
    84b0:	00008440 00008430 00008410 00008420     @...0....... ...
    84c0:	00008480 00008400 00008490 000083c0     ................
	...

000084e0 <patternsem>:
    84e0:	00008c80 00008c90 00008ca0 00008cb0     ................
	...

00008500 <patternsys>:
    8500:	00008cc0 00008cd0 00008ce0 00000000     ................

00008510 <patternthd>:
    8510:	00008cf0 00008d00 00008d10 00008d20     ............ ...
	...
    8530:	44434241 00000000 00000000 00000000     ABCD............
    8540:	636e6542 72616d68 52202c6b 66204d41     Benchmark, RAM f
    8550:	70746f6f 746e6972 00000000 636e6542     ootprint....Benc
    8560:	72616d68 6d202c6b 78657475 6c207365     hmark, mutexes l
    8570:	2f6b636f 6f6c6e75 00006b63 636e6542     ock/unlock..Benc
    8580:	72616d68 73202c6b 70616d65 65726f68     hmark, semaphore
    8590:	61772073 732f7469 616e6769 0000006c     s wait/signal...
    85a0:	636e6542 72616d68 76202c6b 75747269     Benchmark, virtu
    85b0:	74206c61 72656d69 65732073 65722f74     al timers set/re
    85c0:	00746573 636e6542 72616d68 49202c6b     set.Benchmark, I
    85d0:	51204f2f 65756575 68742073 67756f72     /O Queues throug
    85e0:	74757068 00000000 636e6542 72616d68     hput....Benchmar
    85f0:	72202c6b 646e756f 626f7220 63206e69     k, round robin c
    8600:	65746e6f 73207478 63746977 676e6968     ontext switching
    8610:	00000000 636e6542 72616d68 6d202c6b     ....Benchmark, m
    8620:	20737361 63736572 75646568 202c656c     ass reschedule, 
    8630:	68742035 64616572 00000073 636e6542     5 threads...Benc
    8640:	72616d68 74202c6b 61657268 202c7364     hmark, threads, 
    8650:	61657263 6f206574 00796c6e 636e6542     create only.Benc
    8660:	72616d68 74202c6b 61657268 202c7364     hmark, threads, 
    8670:	6c6c7566 63796320 0000656c 636e6542     full cycle..Benc
    8680:	72616d68 63202c6b 65746e6f 73207478     hmark, context s
    8690:	63746977 00000068 636e6542 72616d68     witch...Benchmar
    86a0:	6d202c6b 61737365 20736567 00003323     k, messages #3..
    86b0:	636e6542 72616d68 6d202c6b 61737365     Benchmark, messa
    86c0:	20736567 00003223 636e6542 72616d68     ges #2..Benchmar
    86d0:	6d202c6b 61737365 20736567 00003123     k, messages #1..
    86e0:	75657551 202c7365 7074756f 71207475     Queues, output q
    86f0:	65756575 00000073 75657551 202c7365     ueues...Queues, 
    8700:	75706e69 75712074 73657565 00000000     input queues....
    8710:	616e7944 2063696d 73495041 6572202c     Dynamic APIs, re
    8720:	74736967 61207972 7220646e 72656665     gistry and refer
    8730:	65636e65 00000073 616e7944 2063696d     ences...Dynamic 
    8740:	73495041 6874202c 64616572 72632073     APIs, threads cr
    8750:	69746165 66206e6f 206d6f72 6f6d656d     eation from memo
    8760:	70207972 006c6f6f 616e7944 2063696d     ry pool.Dynamic 
    8770:	73495041 6874202c 64616572 72632073     APIs, threads cr
    8780:	69746165 66206e6f 206d6f72 70616568     eation from heap
    8790:	00000000 6f6d654d 50207972 736c6f6f     ....Memory Pools
    87a0:	7571202c 2f657565 75716564 00657565     , queue/dequeue.
    87b0:	70616548 6c61202c 61636f6c 6e6f6974     Heap, allocation
    87c0:	646e6120 61726620 6e656d67 69746174      and fragmentati
    87d0:	74206e6f 00747365 6e657645 202c7374     on test.Events, 
    87e0:	656d6974 7374756f 00000000 6e657645     timeouts....Even
    87f0:	202c7374 74696177 646e6120 6f726220     ts, wait and bro
    8800:	61636461 00007473 6e657645 202c7374     adcast..Events, 
    8810:	69676572 61727473 6e6f6974 646e6120     registration and
    8820:	73696420 63746170 00000068 6c69614d      dispatch...Mail
    8830:	65786f62 71202c73 69756575 6120676e     boxes, queuing a
    8840:	7420646e 6f656d69 00737475 7373654d     nd timeouts.Mess
    8850:	73656761 6f6c202c 0000706f 646e6f43     ages, loop..Cond
    8860:	2c726156 6f6f6220 74207473 00747365     Var, boost test.
    8870:	646e6f43 2c726156 6f726220 61636461     CondVar, broadca
    8880:	74207473 00747365 646e6f43 2c726156     st test.CondVar,
    8890:	67697320 206c616e 74736574 00000000      signal test....
    88a0:	6574754d 2c736578 61747320 00737574     Mutexes, status.
    88b0:	6574754d 2c736578 69727020 7469726f     Mutexes, priorit
    88c0:	65722079 6e727574 00000000 6574754d     y return....Mute
    88d0:	2c736578 69727020 7469726f 6e692079     xes, priority in
    88e0:	69726568 636e6174 63202c65 6c706d6f     heritance, compl
    88f0:	63207865 00657361 6574754d 2c736578     ex case.Mutexes,
    8900:	69727020 7469726f 6e692079 69726568      priority inheri
    8910:	636e6174 73202c65 6c706d69 61632065     tance, simple ca
    8920:	00006573 6574754d 2c736578 69727020     se..Mutexes, pri
    8930:	7469726f 6e652079 75657571 20676e69     ority enqueuing 
    8940:	74736574 00000000 616e6942 53207972     test....Binary S
    8950:	70616d65 65726f68 66202c73 74636e75     emaphores, funct
    8960:	616e6f69 7974696c 00000000 616d6553     ionality....Sema
    8970:	726f6870 202c7365 6d6f7461 73206369     phores, atomic s
    8980:	616e6769 61772d6c 00007469 616d6553     ignal-wait..Sema
    8990:	726f6870 202c7365 656d6974 0074756f     phores, timeout.
    89a0:	616d6553 726f6870 202c7365 75716e65     Semaphores, enqu
    89b0:	6e697565 00000067 65726854 2c736461     euing...Threads,
    89c0:	6c656420 00737961 65726854 2c736461      delays.Threads,
    89d0:	69727020 7469726f 68632079 65676e61      priority change
    89e0:	00000000 65726854 2c736461 716e6520     ....Threads, enq
    89f0:	69756575 7420676e 20747365 00003223     ueuing test #2..
    8a00:	65726854 2c736461 716e6520 69756575     Threads, enqueui
    8a10:	7420676e 20747365 00003123 74737953     ng test #1..Syst
    8a20:	202c6d65 65746e69 74697267 00000079     em, integrity...
    8a30:	74737953 202c6d65 65746e69 70757272     System, interrup
    8a40:	68207374 6c646e61 00676e69 74737953     ts handling.Syst
    8a50:	202c6d65 74697263 6c616369 6e6f7a20     em, critical zon
    8a60:	00007365 00000000 00000000 00000000     es..............

00008a70 <testbmk1>:
    8a70:	000086c8 00000000 00000000 00005730     ............0W..

00008a80 <testbmk10>:
    8a80:	000085a0 00000000 00000000 00003780     .............7..

00008a90 <testbmk11>:
    8a90:	0000857c 00000310 00000000 00004dc0     |............M..

00008aa0 <testbmk12>:
    8aa0:	0000855c 000002f0 00000000 00003e80     \............>..

00008ab0 <testbmk13>:
    8ab0:	00008540 00000000 00000000 00001970     @...........p...

00008ac0 <testbmk2>:
    8ac0:	000086b0 00000000 00000000 000056a0     .............V..

00008ad0 <testbmk3>:
    8ad0:	00008698 00000000 00000000 00005570     ............pU..

00008ae0 <testbmk4>:
    8ae0:	0000867c 00000000 00000000 00005480     |............T..

00008af0 <testbmk5>:
    8af0:	0000865c 00000000 00000000 000050e0     \............P..

00008b00 <testbmk6>:
    8b00:	0000863c 00000000 00000000 00003920     <........... 9..

00008b10 <testbmk7>:
    8b10:	00008614 00000350 00000000 000052f0     ....P........R..

00008b20 <testbmk8>:
    8b20:	000085e8 00000000 00000000 000051c0     .............Q..

00008b30 <testbmk9>:
    8b30:	000085c4 00000000 00000000 00003830     ............08..

00008b40 <testdyn1>:
    8b40:	00008768 00000460 00000000 00006030     h...`.......0`..

00008b50 <testdyn2>:
    8b50:	00008738 00000440 00000000 00005eb0     8...@........^..

00008b60 <testdyn3>:
    8b60:	00008710 000004a0 00000000 00004840     ............@H..

00008b70 <testevt1>:
    8b70:	00008808 00000520 00000000 00000cd0     .... ...........

00008b80 <testevt2>:
    8b80:	000087ec 00000540 00000000 00006180     ....@........a..

00008b90 <testevt3>:
    8b90:	000087d8 00000530 00000000 00002610     ....0........&..

00008ba0 <testheap1>:
    8ba0:	000087b0 000004e0 00000000 00004a00     .............J..

00008bb0 <testmbox1>:
    8bb0:	0000882c 00000550 00000000 000029a0     ,...P........)..

00008bc0 <testmsg1>:
    8bc0:	0000884c 00000000 00000000 00003b20     L........... ;..

00008bd0 <testmtx1>:
    8bd0:	00008924 00000670 00000000 00006e20     $...p....... n..

00008be0 <testmtx2>:
    8be0:	000088f8 000006a0 00000000 00006d30     ............0m..

00008bf0 <testmtx3>:
    8bf0:	000088cc 00000630 00000000 00006be0     ....0........k..

00008c00 <testmtx4>:
    8c00:	000088b0 00000660 00000000 00006880     ....`........h..

00008c10 <testmtx5>:
    8c10:	000088a0 00000690 00000000 000040c0     .............@..

00008c20 <testmtx6>:
    8c20:	00008888 000005f0 00000000 00006760     ............`g..

00008c30 <testmtx7>:
    8c30:	00008870 00000620 00000000 00006610     p... ........f..

00008c40 <testmtx8>:
    8c40:	0000885c 000005b0 00000000 00006540     \...........@e..

00008c50 <testpools1>:
    8c50:	00008794 000004c0 00000000 00000b50     ............P...

00008c60 <testqueues1>:
    8c60:	000086f8 000003f0 00000000 00005b10     .............[..

00008c70 <testqueues2>:
    8c70:	000086e0 000003a0 00000000 000057c0     .............W..

00008c80 <testsem1>:
    8c80:	000089a0 000006b0 00000000 00007150     ............Pq..

00008c90 <testsem2>:
    8c90:	0000898c 000006e0 00000000 00006f70     ............po..

00008ca0 <testsem3>:
    8ca0:	0000896c 000006d0 00000000 00002370     l...........p#..

00008cb0 <testsem4>:
    8cb0:	00008948 00000000 00000000 00004ea0     H............N..

00008cc0 <testsys1>:
    8cc0:	00008a4c 00000000 00000000 00003580     L............5..

00008cd0 <testsys2>:
    8cd0:	00008a30 00000000 00000000 00000370     0...........p...

00008ce0 <testsys3>:
    8ce0:	00008a1c 00000000 00000000 000018d0     ................

00008cf0 <testthd1>:
    8cf0:	00008a00 00000000 00000000 00007500     .............u..

00008d00 <testthd2>:
    8d00:	000089e4 00000000 00000000 00007360     ............`s..

00008d10 <testthd3>:
    8d10:	000089c8 00000000 00000000 00001d20     ............ ...

00008d20 <testthd4>:
    8d20:	000089b8 00000000 00000000 000039c0     .............9..

00008d30 <vmt>:
    8d30:	00003240 000033e0 00003310 00003490     @2...3...3...4..
    8d40:	00003300 00003480 00003230 000033d0     .3...4..02...3..

00008d50 <wa>:
    8d50:	40000e00 40000f30 40001060 40001190     ...@0..@`..@...@
    8d60:	400012c0                                ...@
